FUNCTION  ale#util#GetLineCount()
Called 2 times
Total time:   0.000227
 Self time:   0.000227

count  total (s)   self (s)
    2              0.000225     return len(getbufline(a:buffer, 1, '$'))

FUNCTION  airline#extensions#tabline#group_of_bufnr()
Called 3 times
Total time:   0.000149
 Self time:   0.000149

count  total (s)   self (s)
    3              0.000020   let cur = bufnr('%')
    3              0.000009   if cur == a:bufnr
    3              0.000023     if g:airline_detect_modified && getbufvar(a:bufnr, '&modified')
    3              0.000010       let group = 'airline_tabmod'
    3              0.000004     else
                                  let group = 'airline_tabsel'
                                endif
    3              0.000003   else
                                if g:airline_detect_modified && getbufvar(a:bufnr, '&modified')
                                  let group = 'airline_tabmod_unsel'
                                elseif index(a:tab_bufs, a:bufnr) > -1
                                  let group = 'airline_tab'
                                else
                                  let group = 'airline_tabhid'
                                endif
                              endif
    3              0.000007   return group

FUNCTION  <SNR>170_UpdateCacheIfNecessary()
Called 822 times
Total time:   0.015956
 Self time:   0.015956

count  total (s)   self (s)
                                " Cache is cold, so manually ask for an update.
  822              0.007060     if !has_key(g:ale_buffer_info[a:buffer], 'count')
                                    call ale#statusline#Update(   a:buffer,   g:ale_buffer_info[a:buffer].loclist)
                                endif

FUNCTION  ale#engine#HandleLoclist()
Called 2 times
Total time:   0.029215
 Self time:   0.000445

count  total (s)   self (s)
    2              0.000024     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
    2              0.000010     if empty(l:info)
                                    return
                                endif
                            
    2              0.000006     if !a:from_other_source
                                    " Remove this linter from the list of active linters.
                                    " This may have already been done when the job exits.
    2              0.000024         call filter(l:info.active_linter_list, 'v:val.name isnot# a:linter_name')
    2              0.000003     endif
                            
                                " Make some adjustments to the loclists to fix common problems, and also
                                " to set default values for loclist items.
    2   0.002060   0.000084     let l:linter_loclist = ale#engine#FixLocList(   a:buffer,   a:linter_name,   a:from_other_source,   a:loclist,)
                            
                                " Remove previous items for this linter.
    2              0.000037     call filter(l:info.loclist, 'v:val.linter_name isnot# a:linter_name')
                            
                                " We don't need to add items or sort the list when this list is empty.
    2              0.000009     if !empty(l:linter_loclist)
                                    " Add the new items.
    2              0.000013         call extend(l:info.loclist, l:linter_loclist)
                            
                                    " Sort the loclist again.
                                    " We need a sorted list so we can run a binary search against it
                                    " for efficient lookup of the messages in the cursor handler.
    2   0.000400   0.000097         call sort(l:info.loclist, 'ale#util#LocItemCompare')
    2              0.000004     endif
                            
    2   0.000563   0.000029     if ale#ShouldDoNothing(a:buffer)
                                    return
                                endif
                            
    2   0.026009   0.000052     call ale#engine#SetResults(a:buffer, l:info.loclist)

FUNCTION  ale#job#IsRunning()
Called 1 time
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
    1              0.000008     if has('nvim')
    1              0.000003         try
                                        " In NeoVim, if the job isn't running, jobpid() will throw.
    1              0.000007             call jobpid(a:job_id)
                            
    1              0.000003             return 1
                                    catch
                                    endtry
                                elseif has_key(s:job_map, a:job_id)
                                    let l:job = s:job_map[a:job_id].job
                            
                                    return job_status(l:job) is# 'run'
                                endif
                            
                                return 0

FUNCTION  ale#lsp#OnInit()
Called 1 time
Total time:   0.002423
 Self time:   0.000058

count  total (s)   self (s)
    1              0.000011     let l:conn = get(s:connections, a:conn_id, {})
                            
    1              0.000005     if empty(l:conn)
                                    return
                                endif
                            
    1              0.000003     if l:conn.initialized
    1   0.002387   0.000022         call a:Callback()
    1              0.000002     else
                                    call add(l:conn.init_queue, a:Callback)
                                endif

FUNCTION  ale#lsp#RegisterCallback()
Called 1 time
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
    1              0.000012     let l:conn = get(s:connections, a:conn_id, {})
                            
    1              0.000004     if !empty(l:conn)
                                    " Add the callback to the List if it's not there already.
    1              0.000019         call uniq(sort(add(l:conn.callback_list, a:callback)))
    1              0.000002     endif

FUNCTION  ale#lsp_linter#StartLSP()
Called 1 time
Total time:   0.005294
 Self time:   0.000160

count  total (s)   self (s)
    1              0.000006     let l:command = ''
    1              0.000004     let l:address = ''
    1   0.000644   0.000036     let l:root = ale#lsp_linter#FindProjectRoot(a:buffer, a:linter)
                            
    1              0.000007     if empty(l:root) && a:linter.lsp isnot# 'tsserver'
                                    " If there's no project root, then we can't check files with LSP,
                                    " unless we are using tsserver, which doesn't use project roots.
                                    return 0
                                endif
                            
    1              0.000013     let l:options = {   'buffer': a:buffer,   'linter': a:linter,   'callback': a:Callback,   'root': l:root,}
                            
    1              0.000005     if a:linter.lsp is# 'socket'
                                    let l:address = ale#linter#GetAddress(a:buffer, a:linter)
                            
                                    return s:StartWithAddress(l:options, l:address)
                                endif
                            
    1   0.000671   0.000018     let l:executable = ale#linter#GetExecutable(a:buffer, a:linter)
                            
    1   0.003910   0.000039     return s:StartIfExecutable(l:options, l:executable)

FUNCTION  ale#handlers#eslint#GetCommand()
Called 1 time
Total time:   0.001645
 Self time:   0.000079

count  total (s)   self (s)
    1   0.001457   0.000018     let l:executable = ale#handlers#eslint#GetExecutable(a:buffer)
                            
    1   0.000056   0.000019     let l:options = ale#Var(a:buffer, 'javascript_eslint_options')
                            
    1   0.000128   0.000037     return ale#node#Executable(a:buffer, l:executable)   . (!empty(l:options) ? ' ' . l:options : '')   . ' -f json --stdin --stdin-filename %s'

FUNCTION  <SNR>160_StopCursorTimer()
Called 1 time
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    1              0.000006     if s:cursor_timer != -1
                                    call timer_stop(s:cursor_timer)
                                    let s:cursor_timer = -1
                                endif

FUNCTION  ale#linter#Get()
Called 1 time
Total time:   0.000844
 Self time:   0.000463

count  total (s)   self (s)
    1              0.000006     let l:possibly_duplicated_linters = []
                            
                                " Handle dot-separated filetypes.
    2              0.000024     for l:original_filetype in split(a:original_filetypes, '\.')
    1   0.000202   0.000040         let l:filetype = ale#linter#ResolveFiletype(l:original_filetype)
    1   0.000119   0.000033         let l:linter_names = s:GetLinterNames(l:original_filetype)
    1   0.000163   0.000029         let l:all_linters = ale#linter#GetAll(l:filetype)
    1              0.000005         let l:filetype_linters = []
                            
    1              0.000010         if type(l:linter_names) is v:t_string && l:linter_names is# 'all'
    1              0.000005             let l:filetype_linters = l:all_linters
    1              0.000005         elseif type(l:linter_names) is v:t_list
                                        " Select only the linters we or the user has specified.
                                        for l:linter in l:all_linters
                                            let l:name_list = [l:linter.name] + l:linter.aliases
                            
                                            for l:name in l:name_list
                                                if index(l:linter_names, l:name) >= 0
                                                    call add(l:filetype_linters, l:linter)
                                                    break
                                                endif
                                            endfor
                                        endfor
                                    endif
                            
    1              0.000010         call extend(l:possibly_duplicated_linters, l:filetype_linters)
    1              0.000002     endfor
                            
    1              0.000005     let l:name_list = []
    1              0.000004     let l:combined_linters = []
                            
                                " Make sure we override linters so we don't get two with the same name,
                                " like 'eslint' for both 'javascript' and 'typescript'
                                "
                                " Note that the reverse calls here modify the List variables.
    6              0.000022     for l:linter in reverse(l:possibly_duplicated_linters)
    5              0.000034         if index(l:name_list, l:linter.name) < 0
    5              0.000032             call add(l:name_list, l:linter.name)
    5              0.000027             call add(l:combined_linters, l:linter)
    5              0.000008         endif
    5              0.000006     endfor
                            
    1              0.000006     return reverse(l:combined_linters)

FUNCTION  <SNR>148_RemoveProblemsForDisabledLinters()
Called 1 time
Total time:   0.000130
 Self time:   0.000130

count  total (s)   self (s)
                                " Figure out which linters are still enabled, and remove
                                " problems for linters which are no longer enabled.
                                " Problems from other sources will be kept.
    1              0.000006     let l:name_map = {}
                            
    6              0.000019     for l:linter in a:linters
    5              0.000033         let l:name_map[l:linter.name] = 1
    5              0.000010     endfor
                            
    1              0.000048     call filter(   get(g:ale_buffer_info[a:buffer], 'loclist', []),   'get(v:val, ''from_other_source'') || get(l:name_map, get(v:val, ''linter_name''))',)

FUNCTION  <SNR>74_Highlight_Matching_Pair()
Called 546 times
Total time:   0.120428
 Self time:   0.120428

count  total (s)   self (s)
                              " Remove any previous match.
  546              0.005359   if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
                              endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
  546              0.004999   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
  546              0.004029   let c_lnum = line('.')
  546              0.003061   let c_col = col('.')
  546              0.001696   let before = 0
                            
  546              0.003347   let text = getline(c_lnum)
  546              0.029078   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
  546              0.003117   if empty(matches)
                                let [c_before, c] = ['', '']
                              else
  546              0.005153     let [c_before, c] = matches[1:2]
  546              0.000949   endif
  546              0.017319   let plist = split(&matchpairs, '.\zs[:,]')
  546              0.004552   let i = index(plist, c)
  546              0.001703   if i < 0
                                " not found, in Insert mode try character before the cursor
  546              0.004615     if c_col > 1 && (mode() == 'i' || mode() == 'R')
  541              0.003420       let before = strlen(c_before)
  541              0.002039       let c = c_before
  541              0.003187       let i = index(plist, c)
  541              0.000873     endif
  546              0.001278     if i < 0
                                  " not found, nothing to do
  546              0.001105       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
                              else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial.
                                let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                try
                                  execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
                              endif
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  <SNR>119_InvokeCompletion()
Called 270 times
Total time:   4.924831
 Self time:   4.465333

count  total (s)   self (s)
  270              4.454222   exec s:python_command "ycm_state.SendCompletionRequest(" . "vimsupport.GetBoolValue( 's:force_semantic' ) )"
                            
  270   0.468673   0.009175   call s:PollCompletion()

FUNCTION  airline#check_mode()
Called 279 times
Total time:   0.326307
 Self time:   0.078667

count  total (s)   self (s)
  279              0.002354   if !has_key(s:contexts, a:winnr)
                                return ''
                              endif
  279              0.002423   let context = s:contexts[a:winnr]
                            
  279              0.001980   if get(w:, 'airline_active', 1)
  276              0.002032     let l:m = mode(1)
  276              0.001255     if l:m ==# "i"
  270              0.001528       let l:mode = ['insert']
  270              0.000921     elseif l:m[0] ==# "i"
                                  let l:mode = ['insert']
                                elseif l:m ==# "Rv"
                                  let l:mode =['replace']
                                elseif l:m[0] ==# "R"
                                  let l:mode = ['replace']
                                elseif l:m[0] =~# '\v(v|V||s|S|)'
                                  let l:mode = ['visual']
                                elseif l:m ==# "t"
                                  let l:mode = ['terminal']
                                elseif l:m[0] ==# "c"
    2              0.000010       let l:mode = ['commandline']
    2              0.000005     elseif l:m ==# "no"   " does not work, most likely, Vim does not refresh the statusline in OP mode
                                  let l:mode = ['normal']
                                elseif l:m[0:1] ==# 'ni'
                                  let l:mode = ['normal']
                                  let l:m = 'ni'
                                else
    4              0.000019       let l:mode = ['normal']
    4              0.000005     endif
  276              0.002827     if exists("*VMInfos") && !empty(VMInfos())
                                  " Vim plugin Multiple Cursors https://github.com/mg979/vim-visual-multi
                                  let l:m = 'multi'
                                endif
  276              0.003959     if index(['Rv', 'no', 'ni', 'ix', 'ic', 'multi'], l:m) == -1
  276              0.001755       let l:m = l:m[0]
  276              0.000449     endif
  276              0.003073     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
  276              0.000484   else
    3              0.000012     let l:mode = ['inactive']
    3              0.000022     let w:airline_current_mode = get(g:airline_mode_map, '__')
    3              0.000004   endif
                            
  279              0.001848   if g:airline_detect_modified && &modified
  270              0.002141     call add(l:mode, 'modified')
  270              0.000439   endif
                            
  279              0.001242   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
                              endif
                            
  279              0.003850   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
                              endif
                            
  279              0.001123   if g:airline_detect_spell && &spell
                                call add(l:mode, 'spell')
                              endif
                            
  279              0.000984   if &readonly || ! &modifiable
    3              0.000017     call add(l:mode, 'readonly')
    3              0.000004   endif
                            
  279              0.002996   let mode_string = join(l:mode)
  279              0.002899   if get(w:, 'airline_lastmode', '') != mode_string
    7   0.005292   0.000126     call airline#highlighter#highlight_modified_inactive(context.bufnr)
    7   0.241079   0.000270     call airline#highlighter#highlight(l:mode, context.bufnr)
    7   0.001772   0.000108     call airline#util#doautocmd('AirlineModeChanged')
    7              0.000046     let w:airline_lastmode = mode_string
    7              0.000010   endif
                            
  279              0.000592   return ''

FUNCTION  <SNR>116_evaluate_tabline()
Called 5 times
Total time:   0.000771
 Self time:   0.000475

count  total (s)   self (s)
    5              0.000018   let tabline = a:tabline
    5   0.000405   0.000109   let tabline = substitute(tabline, '%{\([^}]\+\)}', '\=eval(submatch(1))', 'g')
    5              0.000091   let tabline = substitute(tabline, '%#[^#]\+#', '', 'g')
    5              0.000048   let tabline = substitute(tabline, '%(\([^)]\+\)%)', '\1', 'g')
    5              0.000041   let tabline = substitute(tabline, '%\d\+[TX]', '', 'g')
    5              0.000037   let tabline = substitute(tabline, '%=', '', 'g')
    5              0.000038   let tabline = substitute(tabline, '%\d*\*', '', 'g')
    5              0.000021   if has('tablineat')
    5              0.000040     let tabline = substitute(tabline, '%@[^@]\+@', '', 'g')
    5              0.000007   endif
    5              0.000010   return tabline

FUNCTION  <SNR>104_GetHiCmd()
Called 34 times
Total time:   0.007495
 Self time:   0.007495

count  total (s)   self (s)
                              " a:list needs to have 5 items!
   34              0.000115   let res = ''
   34              0.000092   let i = -1
  204              0.000418   while i < 4
  170              0.000403     let i += 1
  170              0.000931     let item = get(a:list, i, '')
  170              0.000531     if item is ''
   57              0.000115       continue
                                endif
  113              0.000209     if i == 0
   27              0.000144       let res .= ' guifg='.item
   27              0.000054     elseif i == 1
   18              0.000086       let res .= ' guibg='.item
   18              0.000030     elseif i == 2
   34              0.000190       let res .= ' ctermfg='.item
   34              0.000066     elseif i == 3
   25              0.000118       let res .= ' ctermbg='.item
   25              0.000045     elseif i == 4
    9              0.000109       let res .= printf(' gui=%s cterm=%s term=%s', item, item, item)
    9              0.000016     endif
  113              0.000152   endwhile
   34              0.000093   return res

FUNCTION  airline#util#append()
Called 1932 times
Total time:   0.049511
 Self time:   0.049511

count  total (s)   self (s)
 1932              0.011942   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
                              endif
 1932              0.015287   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
 1932              0.012941   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  <SNR>101_map_keys()
Called 4 times
Total time:   0.001480
 Self time:   0.001480

count  total (s)   self (s)
    4              0.000032   let bidx_mode = get(g:, 'airline#extensions#tabline#buffer_idx_mode', 1)
    4              0.000010   if bidx_mode > 0
    4              0.000007     if bidx_mode == 1
   40              0.000137       for i in range(1, 9)
   36              0.000997         exe printf('noremap <silent> <Plug>AirlineSelectTab%d :call <SID>select_tab(%d)<CR>', i, i-1)
   36              0.000072       endfor
    4              0.000005     else
                                  for i in range(11, 99)
                                    exe printf('noremap <silent> <Plug>AirlineSelectTab%d :call <SID>select_tab(%d)<CR>', i, i-11)
                                  endfor
                                endif
    4              0.000065     noremap <silent> <Plug>AirlineSelectPrevTab :<C-u>call <SID>jump_to_tab(-v:count1)<CR>
    4              0.000053     noremap <silent> <Plug>AirlineSelectNextTab :<C-u>call <SID>jump_to_tab(v:count1)<CR>
                                " Enable this for debugging
                                " com! AirlineBufferList :echo map(copy(s:current_visible_buffers), {i,k -> k.": ".bufname(k)})
    4              0.000005   endif

FUNCTION  <SNR>119_OnInsertLeave()
Called 1 time
Total time:   0.009447
 Self time:   0.007278

count  total (s)   self (s)
    1   0.000220   0.000024   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
    1              0.000015   call timer_stop( s:pollers.completion.id )
    1              0.000005   let s:force_semantic = 0
    1              0.000020   let s:completion = s:default_completion
                            
    1   0.002009   0.000036   call s:OnFileReadyToParse()
    1              0.007142   exec s:python_command "ycm_state.OnInsertLeave()"
    1              0.000013   if g:ycm_autoclose_preview_window_after_completion || g:ycm_autoclose_preview_window_after_insertion
                                call s:ClosePreviewWindowIfNeeded()
                              endif

FUNCTION  ale#lsp#UpdateConfig()
Called 1 time
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    1              0.000012     let l:conn = get(s:connections, a:conn_id, {})
                            
    1              0.000008     if empty(l:conn) || a:config ==# l:conn.config " no-custom-checks
    1              0.000003         return 0
                                endif
                            
                                let l:conn.config = a:config
                                let l:message = ale#lsp#message#DidChangeConfiguration(a:buffer, a:config)
                            
                                call ale#lsp#Send(a:conn_id, l:message)
                            
                                return 1

FUNCTION  airline#extensions#branch#update_untracked_config()
Called 276 times
Total time:   0.008696
 Self time:   0.008696

count  total (s)   self (s)
  276              0.002574   if !has_key(s:vcs_config[a:vcs].untracked, a:file)
                                return
                              elseif s:vcs_config[a:vcs].untracked[a:file] != b:buffer_vcs_config[a:vcs].untracked
                                let b:buffer_vcs_config[a:vcs].untracked = s:vcs_config[a:vcs].untracked[a:file]
                                unlet! b:airline_head
                              endif

FUNCTION  airline#themes#get_highlight()
Called 200 times
Total time:   0.060784
 Self time:   0.003530

count  total (s)   self (s)
  200   0.060623   0.003369   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  <SNR>107_get_accented_line()
Called 7 times
Total time:   0.000493
 Self time:   0.000493

count  total (s)   self (s)
    7              0.000021   if a:self._context.active
                                " active window
    7              0.000021     let contents = []
    7              0.000078     let content_parts = split(a:contents, '__accent')
   10              0.000030     for cpart in content_parts
    3              0.000043       let accent = matchstr(cpart, '_\zs[^#]*\ze')
    3              0.000015       call add(contents, cpart)
    3              0.000009     endfor
    7              0.000038     let line = join(contents, a:group)
    7              0.000077     let line = substitute(line, '__restore__', a:group, 'g')
    7              0.000009   else
                                " inactive window
                                let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
                                let line = substitute(line, '%#__restore__#', '', 'g')
                              endif
    7              0.000013   return line

FUNCTION  ale#highlight#RemoveHighlights()
Called 2 times
Total time:   0.000329
 Self time:   0.000329

count  total (s)   self (s)
    8              0.000067     for l:match in getmatches()
    6              0.000166         if l:match.group =~? '\v^ALE(Style)?(Error|Warning|Info)(Line)?$'
    6              0.000045             call matchdelete(l:match.id)
    6              0.000011         endif
    6              0.000008     endfor

FUNCTION  <SNR>168_FixList()
Called 2 times
Total time:   0.001533
 Self time:   0.000489

count  total (s)   self (s)
    2   0.000103   0.000036     let l:format = ale#Var(a:buffer, 'loclist_msg_format')
    2              0.000009     let l:new_list = []
                            
    8              0.000027     for l:item in a:list
    6              0.000071         let l:fixed_item = copy(l:item)
                            
    6   0.001106   0.000131         let l:fixed_item.text = ale#GetLocItemMessage(l:item, l:format)
                            
    6              0.000026         if l:item.bufnr == -1
                                        " If the buffer number is invalid, remove it.
                                        call remove(l:fixed_item, 'bufnr')
                                    endif
                            
    6              0.000042         call add(l:new_list, l:fixed_item)
    6              0.000012     endfor
                            
    2              0.000006     return l:new_list

FUNCTION  FugitiveWorkTree()
Called 552 times
Total time:   0.073700
 Self time:   0.013924

count  total (s)   self (s)
  552   0.073145   0.013369   return s:Tree(FugitiveGitDir(a:0 ? a:1 : -1))

FUNCTION  <SNR>44_on_cursor_moved()
Called 1 time
Total time:   0.000192
 Self time:   0.000109

count  total (s)   self (s)
    1              0.000010   if winnr() != s:active_winnr
                                call s:on_window_changed('CursorMoved')
                              endif
    1   0.000169   0.000087   call airline#update_tabline()

FUNCTION  airline#extensions#fugitiveline#bufname()
Called 276 times
Total time:   0.068642
 Self time:   0.065808

count  total (s)   self (s)
  276              0.002379   if !exists('b:fugitive_name')
                                let b:fugitive_name = ''
                                try
                                  if bufname('%') =~? '^fugitive:' && exists('*FugitiveReal')
                                    let b:fugitive_name = FugitiveReal(bufname('%'))
                                  elseif exists('b:git_dir') && exists('*fugitive#repo')
                                    if get(b:, 'fugitive_type', '') is# 'blob'
                                      let b:fugitive_name = fugitive#repo().translate(FugitivePath(@%, ''))
                                    endif
                                  elseif exists('b:git_dir') && !exists('*fugitive#repo')
                                    let buffer = fugitive#buffer()
                                    if buffer.type('blob')
                                      let b:fugitive_name = buffer.repo().translate(buffer.path('/'))
                                    endif
                                  endif
                                catch
                                endtry
                              endif
                            
  276   0.006745   0.003910   let fmod = s:ModifierFlags()
  276              0.001518   if empty(b:fugitive_name)
  276              0.040554     return fnamemodify(bufname('%'), fmod)
                              else
                                return fnamemodify(b:fugitive_name, fmod). " [git]"
                              endif

FUNCTION  ale#node#Executable()
Called 1 time
Total time:   0.000091
 Self time:   0.000052

count  total (s)   self (s)
    1              0.000012     if has('win32') && a:executable =~? '\.js$'
                                    let l:node = ale#Var(a:buffer, 'windows_node_executable_path')
                            
                                    return ale#Escape(l:node) . ' ' . ale#Escape(a:executable)
                                endif
                            
    1   0.000060   0.000021     return ale#Escape(a:executable)

FUNCTION  ale#sign#GetSignName()
Called 4 times
Total time:   0.000616
 Self time:   0.000346

count  total (s)   self (s)
    4              0.000026     let l:priority = g:ale#util#style_warning_priority
                            
                                " Determine the highest priority item for the line.
   10              0.000035     for l:item in a:sublist
    6   0.000380   0.000110         let l:item_priority = ale#util#GetItemPriority(l:item)
                            
    6              0.000022         if l:item_priority > l:priority
    4              0.000016             let l:priority = l:item_priority
    4              0.000006         endif
    6              0.000008     endfor
                            
    4              0.000015     if l:priority is# g:ale#util#error_priority
    4              0.000011         return 'ALEErrorSign'
                                endif
                            
                                if l:priority is# g:ale#util#warning_priority
                                    return 'ALEWarningSign'
                                endif
                            
                                if l:priority is# g:ale#util#style_error_priority
                                    return 'ALEStyleErrorSign'
                                endif
                            
                                if l:priority is# g:ale#util#style_warning_priority
                                    return 'ALEStyleWarningSign'
                                endif
                            
                                if l:priority is# g:ale#util#info_priority
                                    return 'ALEInfoSign'
                                endif
                            
                                " Use the error sign for invalid severities.
                                return 'ALEErrorSign'

FUNCTION  <SNR>141_GetAliasedFiletype()
Called 1 time
Total time:   0.000113
 Self time:   0.000113

count  total (s)   self (s)
    1              0.000012     let l:buffer_aliases = get(b:, 'ale_linter_aliases', {})
                            
                                " b:ale_linter_aliases can be set to a List or String.
    1              0.000010     if type(l:buffer_aliases) is v:t_list|| type(l:buffer_aliases) is v:t_string
                                    return l:buffer_aliases
                                endif
                            
                                " Check for aliased filetypes first in a buffer variable,
                                " then the global variable,
                                " then in the default mapping,
                                " otherwise use the original filetype.
    4              0.000019     for l:dict in [   l:buffer_aliases,   g:ale_linter_aliases,   s:default_ale_linter_aliases,]
    3              0.000020         if has_key(l:dict, a:original_filetype)
                                        return l:dict[a:original_filetype]
                                    endif
    3              0.000004     endfor
                            
    1              0.000004     return a:original_filetype

FUNCTION  ale#list#SetLists()
Called 2 times
Total time:   0.000238
 Self time:   0.000154

count  total (s)   self (s)
    2              0.000050     if get(g:, 'ale_set_lists_synchronously') == 1|| getbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Update lists immediately if running a test synchronously, or if the
                                    " buffer was saved.
                                    "
                                    " The lists need to be updated immediately when saving a buffer so
                                    " that we can reliably close window automatically, if so configured.
                                    call s:SetListsImpl(-1, a:buffer, a:loclist)
                                else
    2   0.000151   0.000066         call ale#util#StartPartialTimer(   0,   function('s:SetListsImpl'),   [a:buffer, a:loclist],)
    2              0.000003     endif

FUNCTION  airline#extensions#tabline#buffers#get()
Called 4 times
Total time:   0.014160
 Self time:   0.000447

count  total (s)   self (s)
    4              0.000010   try
    4   0.001541   0.000061     call <sid>map_keys()
    4              0.000006   catch
                                " no-op
                              endtry
    4              0.000024   let cur = bufnr('%')
    4              0.000023   if cur == s:current_bufnr && &columns == s:column_width
    4              0.000034     if !g:airline_detect_modified || getbufvar(cur, '&modified') == s:current_modified
    3              0.000010       return s:current_tabline
                                endif
    1              0.000001   endif
                            
    1   0.000180   0.000023   let b = airline#extensions#tabline#new_builder()
    1              0.000005   let tab_bufs = tabpagebuflist(tabpagenr())
    1              0.000002   let show_buf_label_first = 0
                            
    1              0.000003   if get(g:, 'airline#extensions#tabline#buf_label_first', 0)
                                let show_buf_label_first = 1
                              endif
    1              0.000001   if show_buf_label_first
                                call airline#extensions#tabline#add_label(b, 'buffers', 0)
                              endif
                            
    1              0.000004   let b.tab_bufs = tabpagebuflist(tabpagenr())
                            
    1              0.000002   let b.overflow_group = 'airline_tabhid'
    1   0.000014   0.000007   let b.buffers = airline#extensions#tabline#buflist#list()
    1              0.000003   if get(g:, 'airline#extensions#tabline#current_first', 0)
                                if index(b.buffers, cur) > -1
                                  call remove(b.buffers, index(b.buffers, cur))
                                endif
                                let b.buffers = [cur] + b.buffers
                              endif
                            
    1              0.000002   function! b.get_group(i) dict
                                let bufnum = get(self.buffers, a:i, -1)
                                if bufnum == -1
                                  return ''
                                endif
                                let group = airline#extensions#tabline#group_of_bufnr(self.tab_bufs, bufnum)
                                if bufnum == bufnr('%')
                                  let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
                                endif
                                return group
                              endfunction
                            
    1              0.000004   if has("tablineat")
    1              0.000002     function! b.get_pretitle(i) dict
                                  let bufnum = get(self.buffers, a:i, -1)
                                  return '%'.bufnum.'@airline#extensions#tabline#buffers#clickbuf@'
                                endfunction
                            
    1              0.000002     function! b.get_posttitle(i) dict
                                  return '%X'
                                endfunction
    1              0.000001   endif
                            
    1              0.000001   function! b.get_title(i) dict
                                let bufnum = get(self.buffers, a:i, -1)
                                let group = self.get_group(a:i)
                                let pgroup = self.get_group(a:i - 1)
                                " always add a space when powerline_fonts are used
                                " or for the very first item
                                if get(g:, 'airline_powerline_fonts', 0) || a:i == 0
                                  let space = s:spc
                                else
                                  let space= (pgroup == group ? s:spc : '')
                                endif
                            
                                if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
                                  if len(s:number_map) > 0
                                    return space. s:get_number(a:i) . '%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)' . s:spc
                                  else
                                    return '['.(a:i+1).s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.']'
                                  endif
                                else
                                  return space.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.s:spc
                                endif
                              endfunction
                            
    1              0.000007   let current_buffer = max([index(b.buffers, cur), 0])
    1              0.000004   let last_buffer = len(b.buffers) - 1
    1   0.000035   0.000010   call b.insert_titles(current_buffer, 0, last_buffer)
                            
    1   0.000014   0.000008   call b.add_section('airline_tabfill', '')
    1   0.000011   0.000006   call b.split()
    1   0.000010   0.000005   call b.add_section('airline_tabfill', '')
    1              0.000002   if !show_buf_label_first
    1   0.000053   0.000015     call airline#extensions#tabline#add_label(b, 'buffers', 1)
    1              0.000001   endif
                            
    1   0.000032   0.000016   call airline#extensions#tabline#add_tab_label(b)
                            
    1              0.000008   let s:current_bufnr = cur
    1              0.000008   let s:column_width = &columns
    1   0.011997   0.000023   let s:current_tabline = b.build()
    1              0.000009   let s:current_visible_buffers = copy(b.buffers)
                              " Do not remove from s:current_visible_buffers, this breaks s:select_tab()
                              "if b._right_title <= last_buffer
                              "  call remove(s:current_visible_buffers, b._right_title, last_buffer)
                              "endif
                              "if b._left_title > 0
                              "  call remove(s:current_visible_buffers, 0, b._left_title)
                              "endif
    1              0.000002   return s:current_tabline

FUNCTION  <SNR>118_PlatformSlash()
Called 552 times
Total time:   0.010142
 Self time:   0.010142

count  total (s)   self (s)
  552              0.004221   if exists('+shellslash') && !&shellslash
                                return tr(a:path, '/', '\')
                              else
  552              0.001640     return a:path
                              endif

FUNCTION  airline#util#has_fugitive()
Called 276 times
Total time:   0.003061
 Self time:   0.003061

count  total (s)   self (s)
  276              0.002751   return exists('*fugitive#head') || exists('*FugitiveHead')

FUNCTION  ale#lsp#HandleMessage()
Called 1 time
Total time:   0.032069
 Self time:   0.000359

count  total (s)   self (s)
    1              0.000012     let l:conn = get(s:connections, a:conn_id, {})
                            
    1              0.000004     if empty(l:conn)
                                    return
                                endif
                            
    1              0.000008     if type(a:message) isnot v:t_string
                                    " Ignore messages that aren't strings.
                                    return
                                endif
                            
    1              0.000008     let l:conn.data .= a:message
                            
                                " Parse the objects now if we can, and keep the remaining text.
    1   0.000844   0.000040     let [l:conn.data, l:response_list] = ale#lsp#ReadMessageData(l:conn.data)
                            
                                " Look for initialize responses first.
    1              0.000004     if !l:conn.initialized
                                    for l:response in l:response_list
                                        call ale#lsp#HandleInitResponse(l:conn, l:response)
                                    endfor
                                endif
                            
                                " If the connection is marked as initialized, call the callbacks with the
                                " responses.
    1              0.000003     if l:conn.initialized
    5              0.000018         for l:response in l:response_list
                                        " Call all of the registered handlers with the response.
    8              0.000034             for l:Callback in l:conn.callback_list
    4   0.031027   0.000121                 call ale#util#GetFunction(l:Callback)(a:conn_id, l:response)
    4              0.000008             endfor
    4              0.000010         endfor
    1              0.000001     endif

FUNCTION  ale#highlight#UpdateHighlights()
Called 2 times
Total time:   0.001446
 Self time:   0.000824

count  total (s)   self (s)
    2              0.000029     let l:item_list = get(b:, 'ale_enabled', 1) && g:ale_enabled   ? get(b:, 'ale_highlight_items', [])   : []
                            
    2   0.000378   0.000049     call ale#highlight#RemoveHighlights()
                            
    8              0.000029     for l:item in l:item_list
    6              0.000026         if l:item.type is# 'W'
                                        if get(l:item, 'sub_type', '') is# 'style'
                                            let l:group = 'ALEStyleWarning'
                                        else
                                            let l:group = 'ALEWarning'
                                        endif
                                    elseif l:item.type is# 'I'
                                        let l:group = 'ALEInfo'
                                    elseif get(l:item, 'sub_type', '') is# 'style'
                                        let l:group = 'ALEStyleError'
                                    else
    6              0.000022             let l:group = 'ALEError'
    6              0.000009         endif
                            
    6              0.000113         let l:range = {   'lnum': l:item.lnum,   'col': l:item.col,   'end_lnum': get(l:item, 'end_lnum', l:item.lnum),   'end_col': get(l:item, 'end_col', l:item.col)}
                            
    6   0.000410   0.000117         call s:highlight_range(l:item.bufnr, l:range, l:group)
    6              0.000015     endfor
                            
                                " If highlights are enabled and signs are not enabled, we should still
                                " offer line highlights by adding a separate set of highlights.
    2              0.000007     if !g:ale_set_signs
                                    let l:available_groups = {   'ALEWarningLine': hlexists('ALEWarningLine'),   'ALEInfoLine': hlexists('ALEInfoLine'),   'ALEErrorLine': hlexists('ALEErrorLine'),}
                            
                                    for l:item in l:item_list
                                        if l:item.type is# 'W'
                                            let l:group = 'ALEWarningLine'
                                        elseif l:item.type is# 'I'
                                            let l:group = 'ALEInfoLine'
                                        else
                                            let l:group = 'ALEErrorLine'
                                        endif
                            
                                        if l:available_groups[l:group]
                                            call s:highlight_line(l:item.bufnr, l:item.lnum, l:group)
                                        endif
                                    endfor
                                endif

FUNCTION  ale#job#HasOpenChannel()
Called 1 time
Total time:   0.000070
 Self time:   0.000040

count  total (s)   self (s)
    1   0.000058   0.000028     if ale#job#IsRunning(a:job_id)
    1              0.000007         if has('nvim')
                                        " TODO: Implement a check for NeoVim.
    1              0.000002             return 1
                                    endif
                            
                                    " Check if the Job's channel can be written to.
                                    return ch_status(s:job_map[a:job_id].job) is# 'open'
                                endif
                            
                                return 0

FUNCTION  ale#engine#MarkLinterInactive()
Called 2 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    2              0.000033     call filter(a:info.active_linter_list, 'v:val.name isnot# a:linter_name')

FUNCTION  ale#lsp#response#ReadTSServerDiagnostics()
Called 2 times
Total time:   0.000391
 Self time:   0.000391

count  total (s)   self (s)
    2              0.000011     let l:loclist = []
                            
    4              0.000019     for l:diagnostic in a:response.body.diagnostics
    2              0.000040         let l:loclist_item = {   'text': l:diagnostic.text,   'type': 'E',   'lnum': l:diagnostic.start.line,   'col': l:diagnostic.start.offset,   'end_lnum': l:diagnostic.end.line,   'end_col': l:diagnostic.end.offset - 1,}
                            
    2              0.000013         if has_key(l:diagnostic, 'code')
    2              0.000013             if type(l:diagnostic.code) == v:t_string
                                            let l:loclist_item.code = l:diagnostic.code
                                        elseif type(l:diagnostic.code) == v:t_number && l:diagnostic.code != -1
    2              0.000024                 let l:loclist_item.code = string(l:diagnostic.code)
    2              0.000011                 let l:loclist_item.nr = l:diagnostic.code
    2              0.000004             endif
    2              0.000005         endif
                            
    2              0.000014         if get(l:diagnostic, 'category') is# 'warning'
                                        let l:loclist_item.type = 'W'
                                    endif
                            
    2              0.000013         if get(l:diagnostic, 'category') is# 'suggestion'
                                        let l:loclist_item.type = 'I'
                                    endif
                            
    2              0.000016         call add(l:loclist, l:loclist_item)
    2              0.000004     endfor
                            
    2              0.000007     return l:loclist

FUNCTION  ale#lsp#Send()
Called 2 times
Total time:   0.000851
 Self time:   0.000190

count  total (s)   self (s)
    2              0.000023     let l:conn = get(s:connections, a:conn_id, {})
                            
    2              0.000010     if empty(l:conn)
                                    return 0
                                endif
                            
    2              0.000006     if !l:conn.initialized
                                    throw 'LSP server not initialized yet!'
                                endif
                            
    2   0.000400   0.000055     let [l:id, l:data] = ale#lsp#CreateMessageData(a:message)
    2   0.000371   0.000054     call s:SendMessageData(l:conn, l:data)
                            
    2              0.000010     return l:id == 0 ? -1 : l:id

FUNCTION  airline#parts#filetype()
Called 276 times
Total time:   0.011773
 Self time:   0.005397

count  total (s)   self (s)
  276   0.011463   0.005087   return (airline#util#winwidth() < 90 && strlen(&filetype) > 3) ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? '' : '>') : &filetype

FUNCTION  airline#parts#iminsert()
Called 276 times
Total time:   0.004245
 Self time:   0.004245

count  total (s)   self (s)
  276              0.001806   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
                              endif
  276              0.000489   return ''

FUNCTION  gitgutter#hunk#summary()
Called 276 times
Total time:   0.015494
 Self time:   0.005351

count  total (s)   self (s)
  276   0.015164   0.005022   return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  ale#handlers#tslint#GetExecutable()
Called 1 time
Total time:   0.001014
 Self time:   0.000022

count  total (s)   self (s)
    1   0.001012   0.000020     return ale#node#FindExecutable(a:buffer, 'typescript_tslint', [   'node_modules/.bin/tslint',])

FUNCTION  ale#lsp_linter#CheckWithLSP()
Called 1 time
Total time:   0.005337
 Self time:   0.000043

count  total (s)   self (s)
    1   0.005336   0.000042     return ale#lsp_linter#StartLSP(a:buffer, a:linter, function('s:CheckWithLSP'))

FUNCTION  <SNR>141_GetLinterNames()
Called 1 time
Total time:   0.000085
 Self time:   0.000085

count  total (s)   self (s)
    1              0.000012     let l:buffer_ale_linters = get(b:, 'ale_linters', {})
                            
                                " b:ale_linters can be set to 'all'
    1              0.000004     if l:buffer_ale_linters is# 'all'
                                    return 'all'
                                endif
                            
                                " b:ale_linters can be set to a List.
    1              0.000006     if type(l:buffer_ale_linters) is v:t_list
                                    return l:buffer_ale_linters
                                endif
                            
                                " Try to get a buffer-local setting for the filetype
    1              0.000006     if has_key(l:buffer_ale_linters, a:original_filetype)
                                    return l:buffer_ale_linters[a:original_filetype]
                                endif
                            
                                " Try to get a global setting for the filetype
    1              0.000006     if has_key(g:ale_linters, a:original_filetype)
                                    return g:ale_linters[a:original_filetype]
                                endif
                            
                                " If the user has configured ALE to only enable linters explicitly, then
                                " don't enable any linters by default.
    1              0.000003     if g:ale_linters_explicit
                                    return []
                                endif
                            
                                " Try to get a default setting for the filetype
    1              0.000007     if has_key(s:default_ale_linters, a:original_filetype)
                                    return s:default_ale_linters[a:original_filetype]
                                endif
                            
    1              0.000002     return 'all'

FUNCTION  airline#highlighter#highlight()
Called 7 times
Total time:   0.240809
 Self time:   0.033365

count  total (s)   self (s)
    7              0.000041   let bufnr = a:0 ? a:1 : ''
    7              0.000057   let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
    7              0.000136   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
    7              0.000042   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
    7              0.000028   let airline_grouplist = []
    7              0.000100   let buffers_in_tabpage = sort(tabpagebuflist())
    7              0.000040   if exists("*uniq")
    7              0.000063     let buffers_in_tabpage = uniq(buffers_in_tabpage)
    7              0.000011   endif
                              " mapped might be something like ['normal', 'normal_modified']
                              " if a group is in both modes available, only define the second
                              " that is how this was done previously overwrite the previous definition
   17              0.000068   for mode in reverse(mapped)
   10              0.000117     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
    7              0.000055       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
  139              0.000671       for kvp in items(dict)
  132              0.000525         let mode_colors = kvp[1]
  132              0.000493         let name = kvp[0]
  132              0.000745         if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
                                      let name = 'airline_c'.bufnr
                                    endif
                                    " do not re-create highlighting for buffers that are no longer visible
                                    " in the current tabpage
  132              0.002130         if name =~# 'airline_c\d\+'
   12              0.000242           let bnr = matchstr(name, 'airline_c\zs\d\+') + 0
   12              0.000083           if bnr > 0 && index(buffers_in_tabpage, bnr) == -1
                                        continue
                                      endif
   12              0.000061         elseif (name =~# '_to_') || (name[0:10] is# 'airline_tab' && !empty(suffix))
                                      " group will be redefined below at exec_separator
                                      " or is not needed for tabline with '_inactive' suffix
                                      " since active flag is 1 for builder)
   67              0.000159           continue
                                    endif
   65   0.002272   0.001031         if s:group_not_done(airline_grouplist, name.suffix)
   55   0.030767   0.000922           call airline#highlighter#exec(name.suffix, mode_colors)
   55              0.000084         endif
                            
  195              0.000870         for accent in keys(s:accents)
  130              0.000773           if !has_key(p.accents, accent)
                                        continue
                                      endif
  130              0.001229           let colors = copy(mode_colors)
  130              0.000725           if p.accents[accent][0] != ''
   65              0.000387             let colors[0] = p.accents[accent][0]
   65              0.000093           endif
  130              0.000529           if p.accents[accent][2] != ''
   65              0.000308             let colors[2] = p.accents[accent][2]
   65              0.000081           endif
  130              0.000492           if len(colors) >= 5
  130              0.001008             let colors[4] = get(p.accents[accent], 4, '')
  130              0.000194           else
                                        call add(colors, get(p.accents[accent], 4, ''))
                                      endif
  130   0.004249   0.001969           if s:group_not_done(airline_grouplist, name.suffix.'_'.accent)
  110   0.060842   0.001914             call airline#highlighter#exec(name.suffix.'_'.accent, colors)
  110              0.000178           endif
  130              0.000179         endfor
   65              0.000083       endfor
                            
    7              0.000031       if empty(s:separators)
                                    " nothing to be done
                                    continue
                                  endif
                                  " TODO: optimize this
  102              0.000497       for sep in items(s:separators)
                                    " we cannot check, that the group already exists, else the separators
                                    " might not be correctly defined. But perhaps we can skip above groups
                                    " that match the '_to_' name, because they would be redefined here...
   95   0.116921   0.001771         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
   95              0.000178       endfor
    7              0.000007     endif
   10              0.000024   endfor

FUNCTION  <SNR>116_get_separator_change()
Called 2 times
Total time:   0.000666
 Self time:   0.000047

count  total (s)   self (s)
    2   0.000663   0.000045   return s:get_separator_change_with_end(a:new_group, a:old_group, a:end_group, a:end_group, a:sep_size, a:alt_sep_size)

FUNCTION  ale#job#ValidateArguments()
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000009     if a:options.mode isnot# 'nl' && a:options.mode isnot# 'raw'
                                    throw 'Invalid mode: ' . a:options.mode
                                endif

FUNCTION  provider#python3#Call()
Called 1481 times
Total time:   6.240716
 Self time:   6.240716

count  total (s)   self (s)
 1481              0.008655   if s:err != ''
                                return
                              endif
 1481              0.008787   if !exists('s:host')
                                let s:rpcrequest = function('rpcrequest')
                            
                                " Ensure that we can load the Python3 host before bootstrapping
                                try
                                  let s:host = remote#host#Require('legacy-python3-provider')
                                catch
                                  let s:err = v:exception
                                  echohl WarningMsg
                                  echomsg v:exception
                                  echohl None
                                  return
                                endtry
                              endif
 1481              6.166963   return call(s:rpcrequest, insert(insert(a:args, 'python_'.a:method), s:host))

FUNCTION  305()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003       return '%X'

FUNCTION  306()
Called 1 time
Total time:   0.000260
 Self time:   0.000081

count  total (s)   self (s)
    1              0.000005     let bufnum = get(self.buffers, a:i, -1)
    1   0.000097   0.000009     let group = self.get_group(a:i)
    1   0.000105   0.000013     let pgroup = self.get_group(a:i - 1)
                                " always add a space when powerline_fonts are used
                                " or for the very first item
    1              0.000007     if get(g:, 'airline_powerline_fonts', 0) || a:i == 0
    1              0.000004       let space = s:spc
    1              0.000001     else
                                  let space= (pgroup == group ? s:spc : '')
                                endif
                            
    1              0.000005     if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
                                  if len(s:number_map) > 0
                                    return space. s:get_number(a:i) . '%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)' . s:spc
                                  else
                                    return '['.(a:i+1).s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.']'
                                  endif
                                else
    1              0.000008       return space.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.s:spc
                                endif

FUNCTION  airline#extensions#tabline#buflist#list()
Called 6 times
Total time:   0.000055
 Self time:   0.000055

count  total (s)   self (s)
    6              0.000034   if exists('s:current_buffer_list')
    6              0.000013     return s:current_buffer_list
                              endif
                            
                              let exclude_buffers = get(g:, 'airline#extensions#tabline#exclude_buffers', [])
                              let exclude_paths = get(g:, 'airline#extensions#tabline#excludes', [])
                              let exclude_preview = get(g:, 'airline#extensions#tabline#exclude_preview', 1)
                            
                              let list = (exists('g:did_bufmru') && g:did_bufmru) ? BufMRUList() : range(1, bufnr("$"))
                            
                              let buffers = []
                              " If this is too slow, we can switch to a different algorithm.
                              " Basically branch 535 already does it, but since it relies on
                              " BufAdd autocommand, I'd like to avoid this if possible.
                              for nr in list
                                if buflisted(nr)
                                  " Do not add to the bufferlist, if either
                                  " 1) bufnr is exclude_buffers list
                                  " 2) buffername matches one of exclude_paths patterns
                                  " 3) buffer is a quickfix buffer
                                  " 4) when excluding preview windows:
                                  "     'bufhidden' == wipe
                                  "     'buftype' == nofile
                                  " 5) ignore buffers matching airline#extensions#tabline#ignore_bufadd_pat
                            
                                  " check buffer numbers first
                                  if index(exclude_buffers, nr) >= 0
                                    continue
                                  " check paths second
                                  elseif !empty(exclude_paths) && s:ExcludePaths(nr, exclude_paths)
                                    continue
                                  " ignore buffers matching airline#extensions#tabline#ignore_bufadd_pat
                                  elseif airline#util#ignore_buf(bufname(nr))
                                    continue
                                  " check other types last
                                  elseif s:ExcludeOther(nr, exclude_preview)
                                    continue
                                  endif
                            
                                  call add(buffers, nr)
                                endif
                              endfor
                            
                              let s:current_buffer_list = buffers
                              return buffers

FUNCTION  airline#mode_changed()
Called 7 times
Total time:   0.000365
 Self time:   0.000271

count  total (s)   self (s)
                              " airline#visual_active
                              " Boolean: for when to get visual wordcount
                              " needed for the wordcount extension
    7              0.000151   let g:airline#visual_active = (mode() =~? '[vs]')
    7   0.000183   0.000090   call airline#update_tabline()

FUNCTION  ale#ShouldDoNothing()
Called 4 times
Total time:   0.001257
 Self time:   0.000962

count  total (s)   self (s)
                                " The checks are split into separate if statements to make it possible to
                                " profile each check individually with Vim's profiling tools.
                                "
                                " Do nothing if ALE is disabled.
    4              0.000047     if !getbufvar(a:buffer, 'ale_enabled', get(g:, 'ale_enabled', 0))
                                    return 1
                                endif
                            
                                " Don't perform any checks when newer NeoVim versions are exiting.
    4              0.000095     if get(v:, 'exiting', v:null) isnot v:null
                                    return 1
                                endif
                            
    4              0.000047     let l:filetype = getbufvar(a:buffer, '&filetype')
                            
                                " Do nothing when there's no filetype.
    4              0.000018     if l:filetype is# ''
                                    return 1
                                endif
                            
                                " Do nothing for diff buffers.
    4              0.000027     if getbufvar(a:buffer, '&diff')
                                    return 1
                                endif
                            
                                " Do nothing for blacklisted files.
    4              0.000053     if index(get(g:, 'ale_filetype_blacklist', []), l:filetype) >= 0
                                    return 1
                                endif
                            
                                " Do nothing if running from command mode.
    4              0.000032     if s:getcmdwintype_exists && !empty(getcmdwintype())
                                    return 1
                                endif
                            
    4              0.000045     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
                                " Do nothing for directories.
    4              0.000017     if l:filename is# '.'
                                    return 1
                                endif
                            
                                " Don't start linting and so on when an operator is pending.
    4   0.000126   0.000077     if ale#util#Mode(1) is# 'no'
                                    return 1
                                endif
                            
                                " Do nothing if running in the sandbox.
    4   0.000208   0.000066     if ale#util#InSandbox()
                                    return 1
                                endif
                            
                                " Do nothing if the file is too large.
    4   0.000166   0.000063     if ale#FileTooLarge(a:buffer)
                                    return 1
                                endif
                            
                                " Do nothing from CtrlP buffers with CtrlP-funky.
    4              0.000076     if exists(':CtrlPFunky') is 2&& getbufvar(a:buffer, '&l:statusline') =~# 'CtrlPMode.*funky'
                                    return 1
                                endif
                            
    4              0.000007     return 0

FUNCTION  airline#extensions#ale#get_error()
Called 276 times
Total time:   0.147903
 Self time:   0.005212

count  total (s)   self (s)
  276   0.147609   0.004918   return airline#extensions#ale#get('error')

FUNCTION  ale#linter#GetCommand()
Called 2 times
Total time:   0.001728
 Self time:   0.000083

count  total (s)   self (s)
    2              0.000033     let l:Command = has_key(a:linter, 'command_callback')   ? function(a:linter.command_callback)   : a:linter.command
                            
    2   0.001690   0.000045     return type(l:Command) is v:t_func   ? l:Command(a:buffer)   : l:Command

FUNCTION  <SNR>53_SetDefaultCompletionType()
Called 1 time
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    1              0.000013   if exists('b:SuperTabDefaultCompletionType') && (!exists('b:complCommandLine') || !b:complCommandLine)
                                call SuperTabSetCompletionType(b:SuperTabDefaultCompletionType)
                              endif

FUNCTION  <SNR>167_GroupLoclistItems()
Called 2 times
Total time:   0.000329
 Self time:   0.000329

count  total (s)   self (s)
    2              0.000011     let l:grouped_items = []
    2              0.000014     let l:last_lnum = -1
                            
    8              0.000025     for l:obj in a:loclist
    6              0.000023         if l:obj.bufnr != a:buffer
                                        continue
                                    endif
                            
                                    " Create a new sub-List when we hit a new line.
    6              0.000024         if l:obj.lnum != l:last_lnum
    4              0.000027             call add(l:grouped_items, [])
    4              0.000010         endif
                            
    6              0.000045         call add(l:grouped_items[-1], l:obj)
    6              0.000025         let l:last_lnum = l:obj.lnum
    6              0.000011     endfor
                            
    2              0.000006     return l:grouped_items

FUNCTION  airline#util#ignore_buf()
Called 276 times
Total time:   0.015801
 Self time:   0.015801

count  total (s)   self (s)
  276              0.004834   let pat = '\c\v'. get(g:, 'airline#ignore_bufadd_pat', ''). get(g:, 'airline#extensions#tabline#ignore_bufadd_pat',  'gundo|undotree|vimfiler|tagbar|nerd_tree|startify|!')
  276              0.010443   return match(a:name, pat) > -1

FUNCTION  <SNR>170_BufferCacheExists()
Called 822 times
Total time:   0.016243
 Self time:   0.016243

count  total (s)   self (s)
  822              0.009762     if !exists('g:ale_buffer_info') || !has_key(g:ale_buffer_info, a:buffer)
                                    return 0
                                endif
                            
  822              0.001412     return 1

FUNCTION  <SNR>107_get_transitioned_seperator()
Called 5 times
Total time:   0.005307
 Self time:   0.000245

count  total (s)   self (s)
    5              0.000013   let line = ''
    5              0.000037   if get(a:self._context, 'tabline', 0) && get(g:, 'airline#extensions#tabline#alt_sep', 0) && a:group ==# 'airline_tabsel' && a:side
                                call airline#highlighter#add_separator(a:prev_group, a:group, 0)
                                let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
                                let line .=  a:self._context.right_sep.'%#'.a:group.'#'
                              else
    5   0.005110   0.000049     call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
    5              0.000031     let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
    5              0.000026     let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
    5              0.000021     let line .= '%#'.a:group.'#'
    5              0.000004   endif
    5              0.000007   return line

FUNCTION  <SNR>148_RunIfExecutable()
Called 4 times
Total time:   0.010334
 Self time:   0.000567

count  total (s)   self (s)
    4   0.000136   0.000081     if ale#command#IsDeferred(a:executable)
                                    let a:executable.result_callback = {   executable -> s:RunIfExecutable(a:buffer, a:linter, executable)}
                            
                                    return 1
                                endif
                            
    4   0.000935   0.000076     if ale#engine#IsExecutable(a:buffer, a:executable)
                                    " Use different job types for file or linter jobs.
    1              0.000007         let l:job_type = a:linter.lint_file ? 'file_linter' : 'linter'
    1              0.000012         call setbufvar(a:buffer, 'ale_job_type', l:job_type)
                            
    1              0.000006         if has_key(a:linter, 'command_chain')
                                        let [l:command, l:options] = ale#engine#ProcessChain(   a:buffer,   a:executable,   a:linter,   0,   [])
                            
                                        return s:RunJob(l:command, l:options)
                                    endif
                            
    1   0.001732   0.000030         let l:command = ale#linter#GetCommand(a:buffer, a:linter)
    1              0.000024         let l:options = {   'executable': a:executable,   'buffer': a:buffer,   'linter': a:linter,   'output_stream': get(a:linter, 'output_stream', 'stdout'),   'next_chain_index': 1,   'read_buffer': a:linter.read_buffer,}
                            
    1   0.007195   0.000044         return s:RunJob(l:command, l:options)
                                endif
                            
    3              0.000006     return 0

FUNCTION  ale#engine#MarkLinterActive()
Called 2 times
Total time:   0.000128
 Self time:   0.000128

count  total (s)   self (s)
    2              0.000016     let l:found = 0
                            
    3              0.000024     for l:other_linter in a:info.active_linter_list
    1              0.000010         if l:other_linter.name is# a:linter.name
                                        let l:found = 1
                                        break
                                    endif
    1              0.000002     endfor
                            
    2              0.000005     if !l:found
    2              0.000015         call add(a:info.active_linter_list, a:linter)
    2              0.000003     endif

FUNCTION  airline#util#doautocmd()
Called 7 times
Total time:   0.001664
 Self time:   0.000795

count  total (s)   self (s)
    7   0.001656   0.000787   exe printf("silent doautocmd %s User %s", s:nomodeline, a:event)

FUNCTION  36()
Called 3 times
Total time:   0.000170
 Self time:   0.000099

count  total (s)   self (s)
                            
    3   0.000123   0.000053     if nerdtree#runningWindows()
                                    if exists('+shellslash') && &shellslash
                                        return '/'
                                    endif
                            
                                    return '\'
                                endif
                            
    3              0.000005     return '/'

FUNCTION  <SNR>119_OnBlankLine()
Called 272 times
Total time:   0.243970
 Self time:   0.004381

count  total (s)   self (s)
  272   0.243621   0.004031   return s:Pyeval( 'not vim.current.line or vim.current.line.isspace()' )

FUNCTION  <SNR>170_GetCounts()
Called 548 times
Total time:   0.062188
 Self time:   0.040683

count  total (s)   self (s)
  548   0.017464   0.006700     if !s:BufferCacheExists(a:buffer)
                                    return s:CreateCountDict()
                                endif
                            
  548   0.017707   0.006966     call s:UpdateCacheIfNecessary(a:buffer)
                            
  548              0.021538     return g:ale_buffer_info[a:buffer].count

FUNCTION  <SNR>119_DisableOnLargeFile()
Called 551 times
Total time:   0.006635
 Self time:   0.006635

count  total (s)   self (s)
  551              0.003855   if exists( 'b:ycm_largefile' )
  551              0.001809     return b:ycm_largefile
                              endif
                            
                              let threshold = g:ycm_disable_for_files_larger_than_kb * 1024
                              let b:ycm_largefile = threshold > 0 && getfsize( expand( a:buffer ) ) > threshold
                              if b:ycm_largefile
                                exec s:python_command "vimsupport.PostVimMessage(" . "'YouCompleteMe is disabled in this buffer; " . "the file exceeded the max size (see YCM options).' )"
                              endif
                              return b:ycm_largefile

FUNCTION  ale#util#Writefile()
Called 1 time
Total time:   0.000406
 Self time:   0.000406

count  total (s)   self (s)
    1              0.000019     let l:corrected_lines = getbufvar(a:buffer, '&fileformat') is# 'dos'   ? map(copy(a:lines), 'substitute(v:val, ''\r*$'', ''\r'', '''')')   : a:lines
                            
    1              0.000385     call writefile(l:corrected_lines, a:filename, 'S') " no-custom-checks

FUNCTION  airline#builder#get_prev_group()
Called 12 times
Total time:   0.000302
 Self time:   0.000302

count  total (s)   self (s)
   12              0.000044   let x = a:i - 1
   16              0.000038   while x >= 0
   12              0.000050     let group = a:sections[x][0]
   12              0.000045     if group != '' && group != '|'
    8              0.000015       return group
                                endif
    4              0.000010     let x = x - 1
    4              0.000006   endwhile
    4              0.000006   return ''

FUNCTION  <SNR>157_CreateTSServerMessageData()
Called 2 times
Total time:   0.000265
 Self time:   0.000265

count  total (s)   self (s)
    2              0.000015     let l:is_notification = a:message[0]
                            
    2              0.000022     let l:obj = {   'seq': v:null,   'type': 'request',   'command': a:message[1][3:],}
                            
    2              0.000006     if !l:is_notification
                                    let l:obj.seq = ale#lsp#GetNextMessageID()
                                endif
                            
    2              0.000010     if len(a:message) > 2
    2              0.000011         let l:obj.arguments = a:message[2]
    2              0.000003     endif
                            
    2              0.000152     let l:data = json_encode(l:obj) . "\n"
                            
    2              0.000017     return [l:is_notification ? 0 : l:obj.seq, l:data]

FUNCTION  42()
Called 3 times
Total time:   0.000723
 Self time:   0.000354

count  total (s)   self (s)
    3              0.000043     let options = a:0 ? a:1 : {}
    3              0.000012     let toReturn = ""
                            
    3              0.000017     if has_key(options, 'format')
                                    let format = options['format']
                                    if has_key(self, '_strFor' . format)
                                        exec 'let toReturn = self._strFor' . format . '()'
                                    else
                                        throw 'NERDTree.UnknownFormatError: unknown format "'. format .'"'
                                    endif
                                else
    3   0.000385   0.000040         let toReturn = self._str()
    3              0.000004     endif
                            
    3   0.000064   0.000039     if nerdtree#has_opt(options, 'escape')
                                    let toReturn = shellescape(toReturn)
                                endif
                            
    3              0.000011     if has_key(options, 'truncateTo')
                                    let limit = options['truncateTo']
                                    if strdisplaywidth(toReturn) > limit-1
                                        while strdisplaywidth(toReturn) > limit-1 && strchars(toReturn) > 0
                                            let toReturn = substitute(toReturn, '^.', '', '')
                                        endwhile
                                        if len(split(toReturn, '/')) > 1
                                            let toReturn = '</' . join(split(toReturn, '/')[1:], '/') . '/'
                                        else
                                            let toReturn = '<' . toReturn
                                        endif
                                    endif
                                endif
                            
    3              0.000008     return toReturn

FUNCTION  47()
Called 3 times
Total time:   0.000345
 Self time:   0.000135

count  total (s)   self (s)
    3   0.000209   0.000039     let l:separator = s:Path.Slash()
    3              0.000012     let l:leader = l:separator
                            
    3   0.000068   0.000027     if nerdtree#runningWindows()
                                    let l:leader = self.drive . l:separator
                                endif
                            
    3              0.000034     return l:leader . join(self.pathSegments, l:separator)

FUNCTION  ale#lsp_linter#GetOptions()
Called 1 time
Total time:   0.000049
 Self time:   0.000049

count  total (s)   self (s)
    1              0.000008     if has_key(a:linter, 'initialization_options_callback')
                                    return ale#util#GetFunction(a:linter.initialization_options_callback)(a:buffer)
                                endif
                            
    1              0.000005     if has_key(a:linter, 'initialization_options')
                                    let l:Options = a:linter.initialization_options
                            
                                    if type(l:Options) is v:t_func
                                        let l:Options = l:Options(a:buffer)
                                    endif
                            
                                    return l:Options
                                endif
                            
    1              0.000002     return {}

FUNCTION  ale#lsp#Register()
Called 1 time
Total time:   0.000052
 Self time:   0.000052

count  total (s)   self (s)
    1              0.000011     let l:conn_id = a:executable_or_address . ':' . a:project
                            
    1              0.000008     if !has_key(s:connections, l:conn_id)
                                    " is_tsserver: 1 if the connection is for tsserver.
                                    " data: The message data received so far.
                                    " root: The project root.
                                    " open_documents: A Dictionary mapping buffers to b:changedtick, keeping
                                    "   track of when documents were opened, and when we last changed them.
                                    " initialized: 0 if the connection is ready, 1 otherwise.
                                    " init_request_id: The ID for the init request.
                                    " init_options: Options to send to the server.
                                    " config: Configuration settings to send to the server.
                                    " callback_list: A list of callbacks for handling LSP responses.
                                    " capabilities_queue: The list of callbacks to call with capabilities.
                                    " capabilities: Features the server supports.
                                    let s:connections[l:conn_id] = {   'id': l:conn_id,   'is_tsserver': 0,   'data': '',   'root': a:project,   'open_documents': {},   'initialized': 0,   'init_request_id': 0,   'init_options': a:init_options,   'config': {},   'callback_list': [],   'init_queue': [],   'capabilities': {       'hover': 0,       'references': 0,       'completion': 0,       'completion_trigger_characters': [],       'definition': 0,       'typeDefinition': 0,       'symbol_search': 0,   },}
                                endif
                            
    1              0.000003     return l:conn_id

FUNCTION  airline#extensions#tabline#get_buffer_name()
Called 5 times
Total time:   0.001534
 Self time:   0.000207

count  total (s)   self (s)
    5   0.000126   0.000078   let buffers = a:0 ? a:1 : airline#extensions#tabline#buflist#list()
    5              0.000033   let formatter = get(g:, 'airline#extensions#tabline#formatter', 'default')
    5   0.001367   0.000088   return airline#extensions#tabline#formatters#{formatter}#format(a:nr, buffers)

FUNCTION  ale#GetLocItemMessage()
Called 6 times
Total time:   0.000976
 Self time:   0.000976

count  total (s)   self (s)
    6              0.000031     let l:msg = a:format_string
    6              0.000053     let l:severity = g:ale_echo_msg_warning_str
    6              0.000049     let l:code = get(a:item, 'code', '')
    6              0.000041     let l:type = get(a:item, 'type', 'E')
    6              0.000044     let l:linter_name = get(a:item, 'linter_name', '')
    6              0.000050     let l:code_repl = !empty(l:code) ? '\=submatch(1) . l:code . submatch(2)' : ''
                            
    6              0.000025     if l:type is# 'E'
    6              0.000030         let l:severity = g:ale_echo_msg_error_str
    6              0.000016     elseif l:type is# 'I'
                                    let l:severity = g:ale_echo_msg_info_str
                                endif
                            
                                " Replace special markers with certain information.
                                " \=l:variable is used to avoid escaping issues.
    6              0.000104     let l:msg = substitute(l:msg, '\V%severity%', '\=l:severity', 'g')
    6              0.000081     let l:msg = substitute(l:msg, '\V%linter%', '\=l:linter_name', 'g')
    6              0.000222     let l:msg = substitute(l:msg, '\v\%([^\%]*)code([^\%]*)\%', l:code_repl, 'g')
                                " Replace %s with the text.
    6              0.000113     let l:msg = substitute(l:msg, '\V%s', '\=a:item.text', 'g')
                            
    6              0.000021     return l:msg

FUNCTION  303()
Called 3 times
Total time:   0.000289
 Self time:   0.000139

count  total (s)   self (s)
    3              0.000019     let bufnum = get(self.buffers, a:i, -1)
    3              0.000006     if bufnum == -1
                                  return ''
                                endif
    3   0.000201   0.000052     let group = airline#extensions#tabline#group_of_bufnr(self.tab_bufs, bufnum)
    3              0.000016     if bufnum == bufnr('%')
    3              0.000020       let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
    3              0.000005     endif
    3              0.000007     return group

FUNCTION  ale_linters#typescript#xo#GetExecutable()
Called 1 time
Total time:   0.001061
 Self time:   0.000023

count  total (s)   self (s)
    1   0.001059   0.000022     return ale#node#FindExecutable(a:buffer, 'typescript_xo', [   'node_modules/.bin/xo',])

FUNCTION  ale#node#FindExecutable()
Called 5 times
Total time:   0.005456
 Self time:   0.000551

count  total (s)   self (s)
    5   0.000270   0.000093     if ale#Var(a:buffer, a:base_var_name . '_use_global')
                                    return ale#Var(a:buffer, a:base_var_name . '_executable')
                                endif
                            
    9              0.000044     for l:path in a:path_list
    7   0.004809   0.000155         let l:executable = ale#path#FindNearestFile(a:buffer, l:path)
                            
    7              0.000048         if !empty(l:executable)
    3              0.000010             return l:executable
                                    endif
    4              0.000007     endfor
                            
    2   0.000123   0.000050     return ale#Var(a:buffer, a:base_var_name . '_executable')

FUNCTION  ale#engine#InitBufferInfo()
Called 1 time
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    1              0.000008     if !has_key(g:ale_buffer_info, a:buffer)
                                    " active_linter_list will hold the list of active linter names
                                    " loclist holds the loclist items after all jobs have completed.
                                    let g:ale_buffer_info[a:buffer] = {   'active_linter_list': [],   'active_other_sources_list': [],   'loclist': [],}
                            
                                    return 1
                                endif
                            
    1              0.000002     return 0

FUNCTION  airline#extensions#tabline#new_builder()
Called 1 time
Total time:   0.000157
 Self time:   0.000067

count  total (s)   self (s)
    1              0.000020   let builder_context = { 'active'        : 1, 'tabline'       : 1, 'right_sep'     : get(g:, 'airline#extensions#tabline#right_sep'    , g:airline_right_sep), 'right_alt_sep' : get(g:, 'airline#extensions#tabline#right_alt_sep', g:airline_right_alt_sep), }
    1              0.000004   if get(g:, 'airline_powerline_fonts', 0)
                                let builder_context.left_sep     = get(g:, 'airline#extensions#tabline#left_sep'     , g:airline_left_sep)
                                let builder_context.left_alt_sep = get(g:, 'airline#extensions#tabline#left_alt_sep' , g:airline_left_alt_sep)
                              else
    1              0.000005     let builder_context.left_sep     = get(g:, 'airline#extensions#tabline#left_sep'     , ' ')
    1              0.000004     let builder_context.left_alt_sep = get(g:, 'airline#extensions#tabline#left_alt_sep' , '|')
    1              0.000001   endif
                            
    1   0.000109   0.000019   return airline#extensions#tabline#builder#new(builder_context)

FUNCTION  airline#extensions#tabline#add_label()
Called 1 time
Total time:   0.000038
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000004   if get(g:, 'airline#extensions#tabline#show_tab_type', 1)
    1   0.000032   0.000013     call a:dict.add_section_spaced('airline_tablabel'. (a:right ? '_right' : ''), get(g:, 'airline#extensions#tabline#'.a:type.'_label', a:type))
    1              0.000001   endif

FUNCTION  ale#FileTooLarge()
Called 4 times
Total time:   0.000103
 Self time:   0.000103

count  total (s)   self (s)
    4              0.000058     let l:max = getbufvar(a:buffer, 'ale_maximum_file_size', get(g:, 'ale_maximum_file_size', 0))
                            
    4              0.000034     return l:max > 0 ? (line2byte(line('$') + 1) > l:max) : 0

FUNCTION  <SNR>95_airline_ale_get_line_number()
Called 548 times
Total time:   0.072084
 Self time:   0.015306

count  total (s)   self (s)
                              " Use the new ALE statusline API function if it is available.
  548              0.004526   if exists("*ale#statusline#FirstProblem")
  548   0.066090   0.009312     return s:new_airline_ale_get_line_number(a:cnt, a:type)
                              endif
                            
                              return s:legacy_airline_ale_get_line_number(a:cnt, a:type)

FUNCTION  ale#engine#IsCheckingBuffer()
Called 557 times
Total time:   0.015669
 Self time:   0.015669

count  total (s)   self (s)
  557              0.006039     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
  557              0.008141     return !empty(get(l:info, 'active_linter_list', []))   || !empty(get(l:info, 'active_other_sources_list', []))

FUNCTION  airline#highlighter#add_separator()
Called 5 times
Total time:   0.005061
 Self time:   0.000138

count  total (s)   self (s)
    5              0.000061   let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
    5   0.004996   0.000073   call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  <SNR>148_StopCurrentJobs()
Called 1 time
Total time:   0.000131
 Self time:   0.000068

count  total (s)   self (s)
    1              0.000012     let l:info = get(g:ale_buffer_info, a:buffer, {})
    1   0.000089   0.000027     call ale#command#StopJobs(a:buffer, 'linter')
                            
                                " Update the active linter list, clearing out anything not running.
    1              0.000004     if a:clear_lint_file_jobs
                                    call ale#command#StopJobs(a:buffer, 'file_linter')
                                    let l:info.active_linter_list = []
                                else
                                    " Keep jobs for linting files when we're only linting buffers.
    1              0.000009         call filter(l:info.active_linter_list, 'get(v:val, ''lint_file'')')
    1              0.000001     endif

FUNCTION  FugitiveGitDir()
Called 828 times
Total time:   0.044865
 Self time:   0.035686

count  total (s)   self (s)
  828              0.004117   if !a:0 || a:1 ==# -1
  276              0.001825     return get(b:, 'git_dir', '')
                              elseif type(a:1) == type(0)
                                return getbufvar(a:1, 'git_dir')
                              elseif type(a:1) == type('')
  552   0.025414   0.016235     return substitute(s:Slash(a:1), '/$', '', '')
                              else
                                return ''
                              endif

FUNCTION  ale#lsp#MarkConnectionAsTsserver()
Called 1 time
Total time:   0.000078
 Self time:   0.000078

count  total (s)   self (s)
    1              0.000014     let l:conn = s:connections[a:conn_id]
    1              0.000005     let l:conn.is_tsserver = 1
    1              0.000004     let l:conn.initialized = 1
                                " Set capabilities which are supported by tsserver.
    1              0.000008     let l:conn.capabilities.hover = 1
    1              0.000005     let l:conn.capabilities.references = 1
    1              0.000004     let l:conn.capabilities.completion = 1
    1              0.000023     let l:conn.capabilities.completion_trigger_characters = ['.']
    1              0.000005     let l:conn.capabilities.definition = 1
    1              0.000004     let l:conn.capabilities.symbol_search = 1

FUNCTION  airline#extensions#ale#get()
Called 552 times
Total time:   0.264653
 Self time:   0.099335

count  total (s)   self (s)
  552              0.004530   if !exists(':ALELint')
                                return ''
                              endif
                            
  552              0.004750   let error_symbol = get(g:, 'airline#extensions#ale#error_symbol', 'E:')
  552              0.004503   let warning_symbol = get(g:, 'airline#extensions#ale#warning_symbol', 'W:')
  552              0.004571   let checking_symbol = get(g:, 'airline#extensions#ale#checking_symbol', '...')
  552              0.004283   let show_line_numbers = get(g:, 'airline#extensions#ale#show_line_numbers', 1)
                            
  552              0.002872   let is_err = a:type ==# 'error'
                            
  552   0.024194   0.008664   if ale#engine#IsCheckingBuffer(bufnr('')) == 1
    4              0.000017     return is_err ? '' : checking_symbol
                              endif
                            
  548              0.002912   let symbol = is_err ? error_symbol : warning_symbol
                            
  548   0.082034   0.008017   let counts = ale#statusline#Count(bufnr(''))
  548              0.005866   if type(counts) == type({}) && has_key(counts, 'error')
                                " Use the current Dictionary format.
  548              0.003011     let errors = counts.error + counts.style_error
  548              0.002990     let num = is_err ? errors : counts.total - errors
  548              0.000964   else
                                " Use the old List format.
                                let num = is_err ? counts[0] : counts[1]
                              endif
                            
  548              0.001615   if show_line_numbers == 1
  548   0.101119   0.025349     return s:airline_ale_count(num, symbol) . <sid>airline_ale_get_line_number(num, a:type)
                              else
                                return s:airline_ale_count(num, symbol)
                              endif

FUNCTION  airline#util#wrap()
Called 2487 times
Total time:   0.049512
 Self time:   0.037476

count  total (s)   self (s)
 2487   0.032126   0.020090   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
                              endif
 2487              0.006048   return a:text

FUNCTION  ale#command#Run()
Called 1 time
Total time:   0.006563
 Self time:   0.000564

count  total (s)   self (s)
    1              0.000011     let l:options = get(a:000, 0, {})
                            
    1              0.000005     if len(a:000) > 1
                                    throw 'Too many arguments!'
                                endif
                            
    1              0.000009     let l:output_stream = get(l:options, 'output_stream', 'stdout')
    1              0.000004     let l:line_list = []
                            
    1   0.001532   0.000050     let [l:temporary_file, l:command, l:file_created] = ale#command#FormatCommand(   a:buffer,   get(l:options, 'executable', ''),   a:command,   get(l:options, 'read_buffer', 0),   get(l:options, 'input', v:null),)
    1   0.000219   0.000029     let l:command = ale#job#PrepareCommand(a:buffer, l:command)
    1              0.000028     let l:job_options = {   'exit_cb': {job_id, exit_code -> s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )},   'mode': 'nl',}
                            
    1              0.000005     if l:output_stream is# 'stdout'
    1              0.000017         let l:job_options.out_cb = function('s:GatherOutput', [l:line_list])
    1              0.000004     elseif l:output_stream is# 'stderr'
                                    let l:job_options.err_cb = function('s:GatherOutput', [l:line_list])
                                elseif l:output_stream is# 'both'
                                    let l:job_options.out_cb = function('s:GatherOutput', [l:line_list])
                                    let l:job_options.err_cb = function('s:GatherOutput', [l:line_list])
                                endif
                            
    1              0.000004     let l:status = 'failed'
                            
    1              0.000006     if get(g:, 'ale_run_synchronously') == 1
                                    if get(g:, 'ale_emulate_job_failure') == 1
                                        let l:job_id = 0
                                    else
                                        " Generate a fake job ID for tests.
                                        let s:fake_job_id = get(s:, 'fake_job_id', 0) + 1
                                        let l:job_id = s:fake_job_id
                                    endif
                                elseif has('win32')
                                    let l:job_id = ale#job#StartWithCmd(l:command, l:job_options)
                                else
    1   0.004291   0.000064         let l:job_id = ale#job#Start(l:command, l:job_options)
    1              0.000004     endif
                            
    1              0.000004     if l:job_id
    1              0.000005         let l:status = 'started'
    1              0.000011         let l:job_type = getbufvar(a:buffer, 'ale_job_type', 'all')
                            
    1   0.000047   0.000025         call ale#command#InitData(a:buffer)
    1              0.000010         let s:buffer_data[a:buffer].jobs[l:job_id] = l:job_type
    1              0.000001     endif
                            
    1              0.000004     if g:ale_history_enabled
    1   0.000136   0.000058         call ale#history#Add(a:buffer, l:status, l:job_id, l:command)
    1              0.000002     endif
                            
    1              0.000003     if !l:job_id
                                    return 0
                                endif
                            
                                " We'll return this Dictionary. A `result_callback` can be assigned to it
                                " later for capturing the result of a:Callback.
                                "
                                " The `_deferred_job_id` is used for both checking the type of object, and
                                " for checking the job ID and status.
                                "
                                " The original command here is used in tests.
    1              0.000017     let l:result = {   '_deferred_job_id': l:job_id,   'executable': get(l:options, 'executable', ''),   'command': a:command,}
                            
    1              0.000008     if get(g:, 'ale_run_synchronously') == 1 && l:job_id
                                    if !exists('g:ale_run_synchronously_callbacks')
                                        let g:ale_run_synchronously_callbacks = []
                                    endif
                            
                                    if get(g:, 'ale_run_synchronously_emulate_commands', 0)
                                        call add(   g:ale_run_synchronously_callbacks,   {exit_code, output -> [       extend(l:line_list, output),       l:job_options.exit_cb(l:job_id, exit_code),   ]})
                                    else
                                        " Run a command synchronously if this test option is set.
                                        call extend(l:line_list, systemlist(   type(l:command) is v:t_list       ? join(l:command[0:1]) . ' ' . ale#Escape(l:command[2])       : l:command))
                            
                                        " Don't capture output when the callbacks aren't set.
                                        if !has_key(l:job_options, 'out_cb')&& !has_key(l:job_options, 'err_cb')
                                            let l:line_list = []
                                        endif
                            
                                        call add(   g:ale_run_synchronously_callbacks,   {-> l:job_options.exit_cb(l:job_id, v:shell_error)})
                                    endif
                                endif
                            
    1              0.000009     return l:result

FUNCTION  airline#extensions#keymap#status()
Called 276 times
Total time:   0.007336
 Self time:   0.007336

count  total (s)   self (s)
  276              0.003578   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
  276              0.003195     return printf('%s', (!empty(&keymap) ? (g:airline_symbols.keymap . ' '. &keymap) : ''))
                              else
                                return ''
                              endif

FUNCTION  <SNR>107_get_seperator()
Called 3 times
Total time:   0.004453
 Self time:   0.000095

count  total (s)   self (s)
    3   0.001320   0.000060   if airline#builder#should_change_group(a:prev_group, a:group)
    3   0.003129   0.000032     return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
                              else
                                return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif

FUNCTION  ale#command#IsDeferred()
Called 7 times
Total time:   0.000089
 Self time:   0.000089

count  total (s)   self (s)
    7              0.000077     return type(a:value) is v:t_dict && has_key(a:value, '_deferred_job_id')

FUNCTION  <SNR>94_ModifierFlags()
Called 276 times
Total time:   0.002834
 Self time:   0.002834

count  total (s)   self (s)
  276              0.002474   return (exists("+autochdir") && &autochdir) ? ':p' : ':.'

FUNCTION  <SNR>91_is_branch_empty()
Called 276 times
Total time:   0.004452
 Self time:   0.004452

count  total (s)   self (s)
  276              0.004108   return exists('*airline#extensions#branch#head') && empty(get(b:, 'airline_head', ''))

FUNCTION  airline#extensions#tabline#get()
Called 4 times
Total time:   0.014514
 Self time:   0.000354

count  total (s)   self (s)
    4              0.000052   let show_buffers = get(g:, 'airline#extensions#tabline#show_buffers', 1)
    4              0.000024   let show_tabs = get(g:, 'airline#extensions#tabline#show_tabs', 1)
                            
    4              0.000019   let curtabcnt = tabpagenr('$')
    4              0.000014   if curtabcnt != s:current_tabcnt
                                let s:current_tabcnt = curtabcnt
                                call airline#extensions#tabline#tabs#invalidate()
                                call airline#extensions#tabline#buffers#invalidate()
                                call airline#extensions#tabline#ctrlspace#invalidate()
                              endif
                            
    4              0.000027   if !exists('#airline#BufAdd#*')
                                autocmd airline BufAdd * call <sid>update_tabline()
                              endif
    4              0.000007   if s:ctrlspace
                                return airline#extensions#tabline#ctrlspace#get()
                              elseif show_buffers && curtabcnt == 1 || !show_tabs
    4   0.014227   0.000067     return airline#extensions#tabline#buffers#get()
                              else
                                return airline#extensions#tabline#tabs#get()
                              endif

FUNCTION  <SNR>116_tabline_evaluated_length()
Called 5 times
Total time:   0.000916
 Self time:   0.000096

count  total (s)   self (s)
    5   0.000912   0.000093   return airline#util#strchars(s:evaluate_tabline(a:tabline))

FUNCTION  <SNR>119_OnInsertChar()
Called 107 times
Total time:   0.021013
 Self time:   0.004357

count  total (s)   self (s)
  107   0.016718   0.001469   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
  107              0.000891   call timer_stop( s:pollers.completion.id )
  107   0.002758   0.001351   call s:CloseCompletionMenu()

FUNCTION  <SNR>119_Complete()
Called 336 times
Total time:   0.020950
 Self time:   0.015859

count  total (s)   self (s)
                              " Do not call user's completion function if the start column is after the
                              " current column or if there are no candidates. Close the completion menu
                              " instead. This avoids keeping the user in completion mode.
  336              0.004074   if s:completion.completion_start_column > s:completion.column || empty( s:completion.completions )
  336   0.009966   0.004876     call s:CloseCompletionMenu()
  336              0.000568   else
                                " <c-x><c-u> invokes the user's completion function (which we have set to
                                " youcompleteme#CompleteFunc), and <c-p> tells Vim to select the previous
                                " completion candidate. This is necessary because by default, Vim selects
                                " the first candidate when completion is invoked, and selecting a candidate
                                " automatically replaces the current text with it. Calling <c-p> forces Vim
                                " to deselect the first candidate and in turn preserve the user's current
                                " text until he explicitly chooses to replace it with a completion.
                                call s:SendKeys( "\<C-X>\<C-U>\<C-P>" )
                              endif

FUNCTION  <SNR>104_get_syn()
Called 960 times
Total time:   0.063671
 Self time:   0.063671

count  total (s)   self (s)
  960              0.005634   if !exists("g:airline_gui_mode")
                                let g:airline_gui_mode = airline#init#gui_mode()
                              endif
  960              0.002586   let color = ''
  960              0.009471   if hlexists(a:group)
  930              0.015025     let color = synIDattr(synIDtrans(hlID(a:group)), a:what, g:airline_gui_mode)
  930              0.001450   endif
  960              0.004564   if empty(color) || color == -1
                                " should always exists
   30              0.000838     let color = synIDattr(synIDtrans(hlID('Normal')), a:what, g:airline_gui_mode)
                                " however, just in case
   30              0.000157     if empty(color) || color == -1
                                  let color = 'NONE'
                                endif
   30              0.000025   endif
  960              0.001912   return color

FUNCTION  ale#statusline#Count()
Called 548 times
Total time:   0.074018
 Self time:   0.011830

count  total (s)   self (s)
                                " The Dictionary is copied here before exposing it to other plugins.
  548   0.072713   0.010525     return copy(s:GetCounts(a:buffer))

FUNCTION  <SNR>104_group_not_done()
Called 195 times
Total time:   0.003521
 Self time:   0.003521

count  total (s)   self (s)
  195              0.001417   if index(a:list, a:name) == -1
  165              0.000976     call add(a:list, a:name)
  165              0.000321     return 1
                              else
   30              0.000078     if &vbs
                                  echomsg printf("airline: group: %s already done, skipping", a:name)
                                endif
   30              0.000048     return 0
                              endif

FUNCTION  <SNR>119_PollCompletion()
Called 320 times
Total time:   0.569569
 Self time:   0.022974

count  total (s)   self (s)
  320   0.447475   0.006817   if !s:Pyeval( 'ycm_state.CompletionRequestReady()' )
  254              0.008788     let s:pollers.completion.id = timer_start( s:pollers.completion.wait_milliseconds, function( 's:PollCompletion' ) )
  254              0.001122     return
                              endif
                            
   66   0.103769   0.002004   let s:completion = s:Pyeval( 'ycm_state.GetCompletionResponse()' )
   66   0.005802   0.001630   call s:Complete()

FUNCTION  <SNR>119_AllowedToCompleteInBuffer()
Called 551 times
Total time:   0.068975
 Self time:   0.062340

count  total (s)   self (s)
  551              0.007207   let buftype = getbufvar( a:buffer, '&buftype' )
                            
  551              0.003706   if has_key( s:buftype_blacklist, buftype )
                                return 0
                              endif
                            
  551              0.005097   let filetype = getbufvar( a:buffer, '&filetype' )
                            
  551   0.016173   0.009537   if empty( filetype ) || s:DisableOnLargeFile( a:buffer )
                                return 0
                              endif
                            
  551              0.009478   let whitelist_allows = type( g:ycm_filetype_whitelist ) != type( {} ) || has_key( g:ycm_filetype_whitelist, '*' ) || has_key( g:ycm_filetype_whitelist, filetype )
  551              0.007128   let blacklist_allows = type( g:ycm_filetype_blacklist ) != type( {} ) || !has_key( g:ycm_filetype_blacklist, filetype )
                            
  551              0.002728   let allowed = whitelist_allows && blacklist_allows
  551              0.001432   if allowed
  551              0.004403     let s:previous_allowed_buffer_number = bufnr( a:buffer )
  551              0.000909   endif
  551              0.001331   return allowed

FUNCTION  airline#extensions#hunks#get_raw_hunks()
Called 276 times
Total time:   0.051488
 Self time:   0.017983

count  total (s)   self (s)
  276              0.003483   if !exists('b:source_func') || get(b:, 'source_func', '') is# 's:get_hunks_empty'
                                if get(g:, 'loaded_signify') && sy#buffer_is_active()
                                  let b:source_func = 's:get_hunks_signify'
                                elseif exists('*GitGutterGetHunkSummary')
                                  let b:source_func = 's:get_hunks_gitgutter'
                                elseif exists('*changes#GetStats')
                                  let b:source_func = 's:get_hunks_changes'
                                elseif exists('*quickfixsigns#vcsdiff#GetHunkSummary')
                                  let b:source_func = 'quickfixsigns#vcsdiff#GetHunkSummary'
                                else
                                  let b:source_func = 's:get_hunks_empty'
                                endif
                              endif
  276   0.038196   0.004690   return {b:source_func}()

FUNCTION  airline#extensions#tabline#formatters#default#wrap_name()
Called 5 times
Total time:   0.000181
 Self time:   0.000181

count  total (s)   self (s)
    5              0.000031   let _ = s:buf_nr_show ? printf(s:buf_nr_format, a:bufnr) : ''
    5              0.000073   let _ .= substitute(a:buffer_name, '\\', '/', 'g')
                            
    5              0.000031   if getbufvar(a:bufnr, '&modified') == 1
    4              0.000016     let _ .= s:buf_modified_symbol
    4              0.000004   endif
    5              0.000008   return _

FUNCTION  <SNR>170_GetFirstProblems()
Called 274 times
Total time:   0.020827
 Self time:   0.010133

count  total (s)   self (s)
  274   0.008808   0.003328     if !s:BufferCacheExists(a:buffer)
                                    return {}
                                endif
                            
  274   0.008663   0.003449     call s:UpdateCacheIfNecessary(a:buffer)
                            
  274              0.001574     return g:ale_buffer_info[a:buffer].first_problems

FUNCTION  <SNR>155_StartLSP()
Called 1 time
Total time:   0.003607
 Self time:   0.000347

count  total (s)   self (s)
    1              0.000007     let l:buffer = a:options.buffer
    1              0.000004     let l:linter = a:options.linter
    1              0.000004     let l:root = a:options.root
    1              0.000008     let l:Callback = a:options.callback
                            
    1   0.000088   0.000038     let l:init_options = ale#lsp_linter#GetOptions(l:buffer, l:linter)
                            
    1              0.000005     if l:linter.lsp is# 'socket'
                                    let l:conn_id = ale#lsp#Register(a:address, l:root, l:init_options)
                                    let l:ready = ale#lsp#ConnectToAddress(l:conn_id, a:address)
                                    let l:command = ''
                                else
    1   0.000091   0.000039         let l:conn_id = ale#lsp#Register(a:executable, l:root, l:init_options)
                            
                                    " tsserver behaves differently, so tell the LSP API that it is tsserver.
    1              0.000005         if l:linter.lsp is# 'tsserver'
    1   0.000114   0.000036             call ale#lsp#MarkConnectionAsTsserver(l:conn_id)
    1              0.000002         endif
                            
    1   0.000298   0.000030         let l:command = ale#command#FormatCommand(l:buffer, a:executable, a:command, 0, v:false)[1]
    1   0.000218   0.000023         let l:command = ale#job#PrepareCommand(l:buffer, l:command)
    1   0.000230   0.000035         let l:ready = ale#lsp#StartProgram(l:conn_id, a:executable, l:command)
    1              0.000002     endif
                            
    1              0.000003     if !l:ready
                                    if g:ale_history_enabled && !empty(a:command)
                                        call ale#history#Add(l:buffer, 'failed', l:conn_id, a:command)
                                    endif
                            
                                    return 0
                                endif
                            
    1              0.000013     let l:details = {   'buffer': l:buffer,   'connection_id': l:conn_id,   'command': l:command,   'project_root': l:root,}
                            
    1   0.002463   0.000040     call ale#lsp#OnInit(l:conn_id, {->   ale#lsp_linter#OnInit(l:linter, l:details, l:Callback)})
                            
    1              0.000002     return 1

FUNCTION  ale#Queue()
Called 1 time
Total time:   0.022558
 Self time:   0.000177

count  total (s)   self (s)
    1              0.000005     if a:0 > 2
                                    throw 'too many arguments!'
                                endif
                            
    1              0.000009     let l:buffer = get(a:000, 1, v:null)
                            
    1              0.000005     if l:buffer is v:null
    1              0.000007         let l:buffer = bufnr('')
    1              0.000002     endif
                            
    1              0.000006     if type(l:buffer) isnot v:t_number
                                    throw 'buffer_number must be a Number'
                                endif
                            
    1   0.000443   0.000031     if ale#ShouldDoNothing(l:buffer)
                                    return
                                endif
                            
                                " Default linting_flag to ''
    1              0.000009     let l:should_lint_file = get(a:000, 0) is# 'lint_file'
                            
    1              0.000004     if s:lint_timer != -1
                                    call timer_stop(s:lint_timer)
                                    let s:lint_timer = -1
                                endif
                            
    1              0.000003     if a:delay > 0
                                    let s:lint_timer = timer_start(   a:delay,   function('s:Lint', [l:buffer, l:should_lint_file]))
                                else
    1   0.022016   0.000047         call s:Lint(l:buffer, l:should_lint_file, 0)
    1              0.000002     endif

FUNCTION  <SNR>93_update_hg_branch()
Called 276 times
Total time:   0.034224
 Self time:   0.031722

count  total (s)   self (s)
  276   0.005557   0.003055   if airline#util#has_lawrencium()
                                let cmd='LC_ALL=C hg qtop'
                                let stl=lawrencium#statusline()
                                let file=expand('%:p')
                                if !empty(stl) && get(b:, 'airline_do_mq_check', 1)
                                  if g:airline#init#vim_async
                                    noa call airline#async#get_mq_async(cmd, file)
                                  elseif has("nvim")
                                    noa call airline#async#nvim_get_mq_async(cmd, file)
                                  else
                                    " remove \n at the end of the command
                                    let output=system(cmd)[0:-2]
                                    noa call airline#async#mq_output(output, file)
                                  endif
                                endif
                                " do not do mq check anymore
                                let b:airline_do_mq_check = 0
                                if exists("b:mq") && !empty(b:mq)
                                  if stl is# 'default'
                                    " Shorten default a bit
                                    let stl='def'
                                  endif
                                  let stl.=' ['.b:mq.']'
                                endif
                                let s:vcs_config['mercurial'].branch = stl
                              else
  276              0.001670     let s:vcs_config['mercurial'].branch = ''
  276              0.000434   endif

FUNCTION  <SNR>119_OnCursorMovedNormalMode()
Called 1 time
Total time:   0.003030
 Self time:   0.002861

count  total (s)   self (s)
    1   0.000188   0.000019   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
    1              0.002836   exec s:python_command "ycm_state.OnCursorMoved()"

FUNCTION  <SNR>109_Lint()
Called 1 time
Total time:   0.021969
 Self time:   0.000306

count  total (s)   self (s)
                                " Use the filetype from the buffer
    1              0.000012     let l:filetype = getbufvar(a:buffer, '&filetype')
    1   0.000878   0.000034     let l:linters = ale#linter#Get(l:filetype)
                            
                                " Apply ignore lists for linters only if needed.
    1   0.000052   0.000018     let l:ignore_config = ale#Var(a:buffer, 'linters_ignore')
    1   0.000045   0.000016     let l:disable_lsp = ale#Var(a:buffer, 'disable_lsp')
    1              0.000014     let l:linters = !empty(l:ignore_config) || l:disable_lsp   ? ale#engine#ignore#Exclude(l:filetype, l:linters, l:ignore_config, l:disable_lsp)   : l:linters
                            
                                " Tell other sources that they can start checking the buffer now.
    1              0.000005     let g:ale_want_results_buffer = a:buffer
    1   0.000143   0.000111     silent doautocmd <nomodeline> User ALEWantResults
    1              0.000005     unlet! g:ale_want_results_buffer
                            
                                " Don't set up buffer data and so on if there are no linters to run.
    1              0.000013     if !has_key(g:ale_buffer_info, a:buffer) && empty(l:linters)
                                    return
                                endif
                            
                                " Clear lint_file linters, or only run them if the file exists.
    1              0.000014     let l:lint_file = empty(l:linters)   || (a:should_lint_file && filereadable(expand('#' . a:buffer . ':p')))
                            
    1   0.020769   0.000045     call ale#engine#RunLinters(a:buffer, l:linters, l:lint_file)

FUNCTION  ale#engine#IsExecutable()
Called 5 times
Total time:   0.000892
 Self time:   0.000695

count  total (s)   self (s)
    5              0.000031     if empty(a:executable)
                                    " Don't log the executable check if the executable string is empty.
                                    return 0
                                endif
                            
                                " Check for a cached executable() check.
    5              0.000053     let l:result = get(s:executable_cache_map, a:executable, v:null)
                            
    5              0.000021     if l:result isnot v:null
    2              0.000006         return l:result
                                endif
                            
                                " Check if the file is executable, and convert -1 to 1.
    3              0.000331     let l:result = executable(a:executable) isnot 0
                            
                                " Cache the executable check if we found it, or if the option to cache
                                " failing checks is on.
    3              0.000030     if l:result || get(g:, 'ale_cache_executable_check_failures', 0)
                                    let s:executable_cache_map[a:executable] = l:result
                                endif
                            
    3              0.000010     if g:ale_history_enabled
    3   0.000290   0.000094         call ale#history#Add(a:buffer, l:result, 'executable', a:executable)
    3              0.000006     endif
                            
    3              0.000009     return l:result

FUNCTION  airline#extensions#branch#get_head()
Called 276 times
Total time:   0.800298
 Self time:   0.024332

count  total (s)   self (s)
  276   0.759596   0.003883   let head = airline#extensions#branch#head()
  276   0.007673   0.004915   let winwidth = get(airline#parts#get('branch'), 'minwidth', 120)
  276              0.002876   let minwidth = empty(get(b:, 'airline_hunks', '')) ? 14 : 7
  276   0.021577   0.004081   let head = airline#util#shorten(head, winwidth, minwidth)
  276              0.002743   let symbol = get(g:, 'airline#extensions#branch#symbol', g:airline_symbols.branch)
  276              0.004892   return empty(head) ? get(g:, 'airline#extensions#branch#empty_message', '') : printf('%s%s', empty(symbol) ? '' : symbol.(g:airline_symbols.space), head)

FUNCTION  ale#Escape()
Called 4 times
Total time:   0.000153
 Self time:   0.000153

count  total (s)   self (s)
    4              0.000047     if fnamemodify(&shell, ':t') is? 'cmd.exe'
                                    " If the string contains spaces, it will be surrounded by quotes.
                                    " Otherwise, special characters will be escaped with carets (^).
                                    return substitute(   a:str =~# ' '       ?  '"' .  substitute(a:str, '"', '""', 'g') . '"'       : substitute(a:str, '\v([&|<>^])', '^\1', 'g'),   '%',   '%%',   'g',)
                                endif
                            
    4              0.000034     return shellescape (a:str)

FUNCTION  <SNR>118_Tree()
Called 552 times
Total time:   0.082583
 Self time:   0.008883

count  total (s)   self (s)
  552   0.081975   0.008275   return a:0 ? FugitiveWorkTree(a:1) : FugitiveWorkTree()

FUNCTION  <SNR>154_NeoVimCallback()
Called 1 time
Total time:   0.032367
 Self time:   0.000135

count  total (s)   self (s)
    1              0.000010     let l:info = s:job_map[a:job]
                            
    1              0.000004     if a:event is# 'stdout'
    1   0.032279   0.000047         let l:info.out_cb_line = ale#util#JoinNeovimOutput(   a:job,   l:info.out_cb_line,   a:data,   l:info.mode,   ale#util#GetFunction(l:info.out_cb),)
    1              0.000003     elseif a:event is# 'stderr'
                                    let l:info.err_cb_line = ale#util#JoinNeovimOutput(   a:job,   l:info.err_cb_line,   a:data,   l:info.mode,   ale#util#GetFunction(l:info.err_cb),)
                                else
                                    if has_key(l:info, 'out_cb') && !empty(l:info.out_cb_line)
                                        call ale#util#GetFunction(l:info.out_cb)(a:job, l:info.out_cb_line)
                                    endif
                            
                                    if has_key(l:info, 'err_cb') && !empty(l:info.err_cb_line)
                                        call ale#util#GetFunction(l:info.err_cb)(a:job, l:info.err_cb_line)
                                    endif
                            
                                    try
                                        call ale#util#GetFunction(l:info.exit_cb)(a:job, a:data)
                                    finally
                                        " Automatically forget about the job after it's done.
                                        if has_key(s:job_map, a:job)
                                            call remove(s:job_map, a:job)
                                        endif
                                    endtry
                                endif

FUNCTION  <SNR>155_ShouldIgnore()
Called 2 times
Total time:   0.000214
 Self time:   0.000094

count  total (s)   self (s)
                                " Ignore all diagnostics if LSP integration is disabled.
    2   0.000091   0.000028     if ale#Var(a:buffer, 'disable_lsp')
                                    return 1
                                endif
                            
    2   0.000088   0.000031     let l:config = ale#Var(a:buffer, 'linters_ignore')
                            
                                " Don't load code for ignoring diagnostics if there's nothing to ignore.
    2              0.000009     if empty(l:config)
    2              0.000005         return 0
                                endif
                            
                                let l:filetype = getbufvar(a:buffer, '&filetype')
                                let l:ignore_list = ale#engine#ignore#GetList(l:filetype, l:config)
                            
                                return index(l:ignore_list, a:linter_name) >= 0

FUNCTION  ale#job#SendRaw()
Called 2 times
Total time:   0.000196
 Self time:   0.000196

count  total (s)   self (s)
    2              0.000050     if has('nvim')
    2              0.000081         call jobsend(a:job_id, a:string)
    2              0.000006     else
                                    let l:job = s:job_map[a:job_id].job
                            
                                    if ch_status(l:job) is# 'open'
                                        call ch_sendraw(job_getchannel(l:job), a:string)
                                    endif
                                endif

FUNCTION  FugitiveHead()
Called 276 times
Total time:   0.557219
 Self time:   0.011285

count  total (s)   self (s)
  276   0.007758   0.004206   let dir = FugitiveGitDir(a:0 > 1 ? a:2 : -1)
  276              0.001280   if empty(dir)
                                return ''
                              endif
  276   0.546777   0.004395   return fugitive#Head(a:0 ? a:1 : 0, dir)

FUNCTION  ale#util#Tempname()
Called 1 time
Total time:   0.000052
 Self time:   0.000052

count  total (s)   self (s)
    1              0.000006     let l:clear_tempdir = 0
                            
    1              0.000010     if exists('$TMPDIR') && empty($TMPDIR)
                                    let l:clear_tempdir = 1
                                    let $TMPDIR = '/tmp'
                                endif
                            
    1              0.000002     try
    1              0.000008         let l:name = tempname() " no-custom-checks
    1              0.000002     finally
    1              0.000003         if l:clear_tempdir
                                        let $TMPDIR = ''
                                    endif
    1              0.000002     endtry
                            
    1              0.000003     return l:name

FUNCTION  <SNR>149_TemporaryFilename()
Called 1 time
Total time:   0.000123
 Self time:   0.000070

count  total (s)   self (s)
    1              0.000012     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
    1              0.000005     if empty(l:filename)
                                    " If the buffer's filename is empty, create a dummy filename.
                                    let l:ft = getbufvar(a:buffer, '&filetype')
                                    let l:filename = 'file' . ale#filetypes#GuessExtension(l:ft)
                                endif
                            
                                " Create a temporary filename, <temp_dir>/<original_basename>
                                " The file itself will not be created by this function.
    1   0.000087   0.000034     return ale#util#Tempname() . (has('win32') ? '\' : '/') . l:filename

FUNCTION  <SNR>119_OnDeleteChar()
Called 170 times
Total time:   0.031854
 Self time:   0.007337

count  total (s)   self (s)
  170   0.027419   0.002902   if !s:AllowedToCompleteInCurrentBuffer()
                                return a:key
                              endif
                            
  170              0.001350   call timer_stop( s:pollers.completion.id )
  170              0.000649   if pumvisible()
                                return "\<C-y>" . a:key
                              endif
  170              0.000471   return a:key

FUNCTION  <SNR>95_ale_refresh()
Called 1 time
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000010   if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh!'
                              endif

FUNCTION  fugitive#CommonDir()
Called 552 times
Total time:   0.033003
 Self time:   0.033003

count  total (s)   self (s)
  552              0.003163   if empty(a:dir)
                                return ''
                              endif
  552              0.003591   if !has_key(s:commondirs, a:dir)
                                if getfsize(a:dir . '/HEAD') < 10
                                  let s:commondirs[a:dir] = ''
                                elseif filereadable(a:dir . '/commondir')
                                  let dir = get(readfile(a:dir . '/commondir', 1), 0, '')
                                  if dir =~# '^/\|^\a:/'
                                    let s:commondirs[a:dir] = dir
                                  else
                                    let s:commondirs[a:dir] = simplify(a:dir . '/' . dir)
                                  endif
                                else
                                  let s:commondirs[a:dir] = a:dir
                                endif
                              endif
  552              0.002794   return s:commondirs[a:dir]

FUNCTION  airline#builder#get_next_group()
Called 1 time
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    1              0.000003   let x = a:i + 1
    1              0.000003   let l = len(a:sections)
    2              0.000003   while x < l
    2              0.000006     let group = a:sections[x][0]
    2              0.000005     if group != '' && group != '|'
    1              0.000001       return group
                                endif
    1              0.000002     let x = x + 1
    1              0.000001   endwhile
                              return ''

FUNCTION  <SNR>93_update_branch()
Called 276 times
Total time:   0.643771
 Self time:   0.032461

count  total (s)   self (s)
  828              0.004641   for vcs in keys(s:vcs_config)
  552   0.622288   0.010978     call {s:vcs_config[vcs].update_branch}()
  552              0.005187     if b:buffer_vcs_config[vcs].branch != s:vcs_config[vcs].branch
                                  let b:buffer_vcs_config[vcs].branch = s:vcs_config[vcs].branch
                                  unlet! b:airline_head
                                endif
  552              0.001039   endfor

FUNCTION  airline#parts#ffenc()
Called 276 times
Total time:   0.014754
 Self time:   0.014754

count  total (s)   self (s)
  276              0.002763   let expected = get(g:, 'airline#parts#ffenc#skip_expected_string', '')
  276              0.001436   let bomb     = &l:bomb ? '[BOM]' : ''
  276              0.004125   let ff       = strlen(&ff) ? '['.&ff.']' : ''
  276              0.002696   if expected is# &fenc.bomb.ff
                                return ''
                              else
  276              0.001978     return &fenc.bomb.ff
                              endif

FUNCTION  ale#Var()
Called 26 times
Total time:   0.000878
 Self time:   0.000878

count  total (s)   self (s)
   26              0.000208     let l:full_name = 'ale_' . a:variable_name
   26              0.000334     let l:vars = getbufvar(str2nr(a:buffer), '', {})
                            
   26              0.000257     return get(l:vars, l:full_name, g:[l:full_name])

FUNCTION  tagbar#currenttag()
Called 15 times
Total time:   0.001210
 Self time:   0.001077

count  total (s)   self (s)
                                " Indicate that the statusline functionality is being used. This prevents
                                " the CloseWindow() function from removing the autocommands.
   15              0.000074     let s:statusline_in_use = 1
                            
   15              0.000041     if a:0 > 0
                                    " also test for non-zero value for backwards compatibility
   15              0.000233         let longsig   = a:1 =~# 's' || (type(a:1) == type(0) && a:1 != 0)
   15              0.000120         let fullpath  = a:1 =~# 'f'
   15              0.000110         let prototype = a:1 =~# 'p'
   15              0.000027     else
                                    let longsig   = 0
                                    let fullpath  = 0
                                    let prototype = 0
                                endif
                            
   15   0.000336   0.000203     if !s:Init(1)
   15              0.000042         return a:default
                                endif
                            
                                let tag = s:GetNearbyTag(0, 1)
                            
                                if !empty(tag)
                                    if prototype
                                        return tag.getPrototype(1)
                                    else
                                        return printf(a:fmt, tag.str(longsig, fullpath))
                                    endif
                                else
                                    return a:default
                                endif

FUNCTION  <SNR>119_PollFileParseResponse()
Called 1 time
Total time:   0.001903
 Self time:   0.000744

count  total (s)   self (s)
    1   0.000515   0.000017   if !s:Pyeval( "ycm_state.FileParseRequestReady()" )
                                let s:pollers.file_parse_response.id = timer_start( s:pollers.file_parse_response.wait_milliseconds, function( 's:PollFileParseResponse' ) )
                                return
                              endif
                            
    1              0.000669   exec s:python_command "ycm_state.HandleFileParseRequest()"
    1   0.000684   0.000023   if s:Pyeval( "ycm_state.ShouldResendFileParseRequest()" )
                                call s:OnFileReadyToParse( 1 )
                              endif

FUNCTION  airline#util#winwidth()
Called 2815 times
Total time:   0.063816
 Self time:   0.063816

count  total (s)   self (s)
 2815              0.020050   let nr = get(a:000, 0, 0)
 2815              0.015550   if get(g:, 'airline_statusline_ontop', 0)
                                return &columns
                              else
 2815              0.011859     return winwidth(nr)
                              endif

FUNCTION  <SNR>119_AllowedToCompleteInCurrentBuffer()
Called 551 times
Total time:   0.078463
 Self time:   0.009488

count  total (s)   self (s)
  551   0.077827   0.008852   return s:AllowedToCompleteInBuffer( '%' )

FUNCTION  airline#update_tabline()
Called 8 times
Total time:   0.000176
 Self time:   0.000176

count  total (s)   self (s)
    8              0.000063   if get(g:, 'airline_statusline_ontop', 0)
                                call airline#extensions#tabline#redraw()
                              endif

FUNCTION  ale#handlers#tsserver#GetProjectRoot()
Called 1 time
Total time:   0.000464
 Self time:   0.000035

count  total (s)   self (s)
    1   0.000449   0.000020     let l:tsconfig_file = ale#path#FindNearestFile(a:buffer, 'tsconfig.json')
                            
    1              0.000012     return !empty(l:tsconfig_file) ? fnamemodify(l:tsconfig_file, ':h') : ''

FUNCTION  airline#parts#get()
Called 552 times
Total time:   0.005382
 Self time:   0.005382

count  total (s)   self (s)
  552              0.004779   return get(s:parts, a:key, {})

FUNCTION  airline#parts#paste()
Called 276 times
Total time:   0.002157
 Self time:   0.002157

count  total (s)   self (s)
  276              0.001828   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  <SNR>104_exec_separator()
Called 100 times
Total time:   0.120074
 Self time:   0.009570

count  total (s)   self (s)
  100              0.000388   if pumvisible()
                                return
                              endif
  100              0.000694   let group = a:from.'_to_'.a:to.a:suffix
  100   0.033722   0.002747   let l:from = airline#themes#get_highlight(a:from.a:suffix)
  100   0.031079   0.001270   let l:to = airline#themes#get_highlight(a:to.a:suffix)
  100              0.000231   if a:inverse
   40              0.000307     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
   40              0.000056   else
   60              0.000446     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
   60              0.000075   endif
  100              0.000778   let a:dict[group] = colors
  100   0.051180   0.001460   call airline#highlighter#exec(group, colors)

FUNCTION  <SNR>119_InsideCommentOrString()
Called 272 times
Total time:   0.155007
 Self time:   0.155007

count  total (s)   self (s)
                              " Has to be col('.') -1 because col('.') doesn't exist at this point. We are
                              " in insert mode when this func is called.
  272              0.146336   let syntax_group = synIDattr( synIDtrans( synID( line( '.' ), col( '.' ) - 1, 1 ) ), 'name')
                            
  272              0.002318   if stridx(syntax_group, 'Comment') > -1
                                return 1
                              endif
                            
  272              0.001497   if stridx(syntax_group, 'String') > -1
                                return 2
                              endif
                            
  272              0.000511   return 0

FUNCTION  <SNR>119_OnFileReadyToParse()
Called 1 time
Total time:   0.001974
 Self time:   0.000777

count  total (s)   self (s)
                              " Accepts an optional parameter that is either 0 or 1. If 1, send a
                              " FileReadyToParse event notification, whether the buffer has changed or not;
                              " effectively forcing a parse of the buffer. Default is 0.
    1              0.000008   let force_parsing = a:0 > 0 && a:1
                            
                              " We only want to send a new FileReadyToParse event notification if the buffer
                              " has changed since the last time we sent one, or if forced.
    1   0.001215   0.000018   if force_parsing || s:Pyeval( "ycm_state.NeedsReparse()" )
    1              0.000684     exec s:python_command "ycm_state.OnFileReadyToParse()"
                            
    1              0.000017     call timer_stop( s:pollers.file_parse_response.id )
    1              0.000035     let s:pollers.file_parse_response.id = timer_start( s:pollers.file_parse_response.wait_milliseconds, function( 's:PollFileParseResponse' ) )
    1              0.000002   endif

FUNCTION  ale#util#BinarySearch()
Called 1 time
Total time:   0.000274
 Self time:   0.000274

count  total (s)   self (s)
    1              0.000007     let l:min = 0
    1              0.000008     let l:max = len(a:loclist) - 1
                            
    3              0.000008     while 1
    3              0.000011         if l:max < l:min
    1              0.000002             return -1
                                    endif
                            
    2              0.000011         let l:mid = (l:min + l:max) / 2
    2              0.000010         let l:item = a:loclist[l:mid]
                            
                                    " Binary search for equal buffers, equal lines, then near columns.
    2              0.000009         if l:item.bufnr < a:buffer
                                        let l:min = l:mid + 1
                                    elseif l:item.bufnr > a:buffer
                                        let l:max = l:mid - 1
                                    elseif l:item.lnum < a:line
    1              0.000004             let l:min = l:mid + 1
    1              0.000003         elseif l:item.lnum > a:line
    1              0.000003             let l:max = l:mid - 1
    1              0.000002         else
                                        " This part is a small sequential search.
                                        let l:index = l:mid
                            
                                        " Search backwards to find the first problem on the line.
                                        while l:index > 0&& a:loclist[l:index - 1].bufnr == a:buffer&& a:loclist[l:index - 1].lnum == a:line
                                            let l:index -= 1
                                        endwhile
                            
                                        " Find the last problem on or before this column.
                                        while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col <= a:column
                                            let l:index += 1
                                        endwhile
                            
                                        " Scan forwards to find the last item on the column for the item
                                        " we found, which will have the most serious problem.
                                        let l:item_column = a:loclist[l:index].col
                            
                                        while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col == l:item_column
                                            let l:index += 1
                                        endwhile
                            
                                        return l:index
                                    endif
    2              0.000003     endwhile

FUNCTION  <SNR>155_StartIfExecutable()
Called 1 time
Total time:   0.003871
 Self time:   0.000103

count  total (s)   self (s)
    1   0.000027   0.000016     if ale#command#IsDeferred(a:executable)
                                    let a:executable.result_callback = {   executable -> s:StartIfExecutable(a:options, executable)}
                            
                                    return 1
                                endif
                            
    1   0.000047   0.000015     if !ale#engine#IsExecutable(a:options.buffer, a:executable)
                                    return 0
                                endif
                            
    1   0.000044   0.000018     let l:command = ale#linter#GetCommand(a:options.buffer, a:options.linter)
                            
    1   0.003731   0.000033     return s:StartWithCommand(a:options, a:executable, l:command)

FUNCTION  airline#parts#readonly()
Called 279 times
Total time:   0.028260
 Self time:   0.012459

count  total (s)   self (s)
                              " only consider regular buffers (e.g. ones that represent actual files,
                              " but not special ones like e.g. NERDTree)
  279   0.021635   0.005834   if !empty(&buftype) || airline#util#ignore_buf(bufname('%'))
    3              0.000005     return ''
                              endif
  276              0.001852   if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
                              else
  276              0.001092     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  fugitive#Head()
Called 276 times
Total time:   0.542382
 Self time:   0.069201

count  total (s)   self (s)
  276              0.002448   let dir = a:0 > 1 ? a:2 : s:Dir()
  276   0.264589   0.023140   if empty(dir) || !filereadable(fugitive#Find('.git/HEAD', dir))
                                return ''
                              endif
  276   0.258776   0.027043   let head = readfile(fugitive#Find('.git/HEAD', dir))[0]
  276              0.004521   if head =~# '^ref: '
  276              0.009645     return substitute(head, '\C^ref: \%(refs/\%(heads/\|remotes/\|tags/\)\=\)\=', '', '')
                              elseif head =~# '^\x\{40\}$'
                                let len = a:0 ? a:1 : 0
                                return len < 0 ? head : len ? head[0:len-1] : ''
                              else
                                return ''
                              endif

FUNCTION  ale#engine#FixLocList()
Called 2 times
Total time:   0.001976
 Self time:   0.001682

count  total (s)   self (s)
    2              0.000012     let l:bufnr_map = {}
    2              0.000009     let l:new_loclist = []
                            
                                " Some errors have line numbers beyond the end of the file,
                                " so we need to adjust them so they set the error at the last line
                                " of the file instead.
    2   0.000272   0.000045     let l:last_line_number = ale#util#GetLineCount(a:buffer)
                            
    6              0.000024     for l:old_item in a:loclist
                                    " Copy the loclist item with some default values and corrections.
                                    "
                                    " line and column numbers will be converted to numbers.
                                    " The buffer will default to the buffer being checked.
                                    " The vcol setting will default to 0, a byte index.
                                    " The error type will default to 'E' for errors.
                                    " The error number will default to -1.
                                    "
                                    " The line number and text are the only required keys.
                                    "
                                    " The linter_name will be set on the errors so it can be used in
                                    " output, filtering, etc..
    4              0.000137         let l:item = {   'bufnr': a:buffer,   'text': l:old_item.text,   'lnum': str2nr(l:old_item.lnum),   'col': str2nr(get(l:old_item, 'col', 0)),   'vcol': 0,   'type': get(l:old_item, 'type', 'E'),   'nr': get(l:old_item, 'nr', -1),   'linter_name': a:linter_name,}
                            
    4              0.000015         if a:from_other_source
                                        let l:item.from_other_source = 1
                                    endif
                            
    4              0.000022         if has_key(l:old_item, 'code')
    4              0.000025             let l:item.code = l:old_item.code
    4              0.000006         endif
                            
    4              0.000034         if has_key(l:old_item, 'filename')&& !ale#path#IsTempName(l:old_item.filename)
                                        " Use the filename given.
                                        " Temporary files are assumed to be for this buffer,
                                        " and the filename is not included then, because it looks bad
                                        " in the loclist window.
                                        let l:filename = l:old_item.filename
                                        let l:item.filename = l:filename
                            
                                        if has_key(l:old_item, 'bufnr')
                                            " If a buffer number is also given, include that too.
                                            " If Vim detects that he buffer number is valid, it will
                                            " be used instead of the filename.
                                            let l:item.bufnr = l:old_item.bufnr
                                        elseif has_key(l:bufnr_map, l:filename)
                                            " Get the buffer number from the map, which can be faster.
                                            let l:item.bufnr = l:bufnr_map[l:filename]
                                        else
                                            " Look up the buffer number.
                                            let l:item.bufnr = bufnr(l:filename)
                                            let l:bufnr_map[l:filename] = l:item.bufnr
                                        endif
                                    elseif has_key(l:old_item, 'bufnr')
                                        let l:item.bufnr = l:old_item.bufnr
                                    endif
                            
    4              0.000021         if has_key(l:old_item, 'detail')
                                        let l:item.detail = l:old_item.detail
                                    endif
                            
                                    " Pass on a end_col key if set, used for highlights.
    4              0.000021         if has_key(l:old_item, 'end_col')
    4              0.000040             let l:item.end_col = str2nr(l:old_item.end_col)
    4              0.000007         endif
                            
    4              0.000021         if has_key(l:old_item, 'end_lnum')
    4              0.000033             let l:item.end_lnum = str2nr(l:old_item.end_lnum)
    4              0.000007         endif
                            
    4              0.000020         if has_key(l:old_item, 'sub_type')
                                        let l:item.sub_type = l:old_item.sub_type
                                    endif
                            
    4              0.000033         if l:item.lnum < 1
                                        " When errors appear before line 1, put them at line 1.
                                        let l:item.lnum = 1
                                    elseif l:item.bufnr == a:buffer && l:item.lnum > l:last_line_number
                                        " When errors go beyond the end of the file, put them at the end.
                                        " This is only done for the current buffer.
                                        let l:item.lnum = l:last_line_number
                                    elseif get(l:old_item, 'vcol', 0)
                                        " Convert virtual column positions to byte positions.
                                        " The positions will be off if the buffer has changed recently.
                                        let l:line = getbufline(a:buffer, l:item.lnum)[0]
                            
                                        let l:item.col = ale#util#Col(l:line, l:item.col)
                            
                                        if has_key(l:item, 'end_col')
                                            let l:end_line = get(l:item, 'end_lnum', l:line) != l:line   ? getbufline(a:buffer, l:item.end_lnum)[0]   : l:line
                            
                                            let l:item.end_col = ale#util#Col(l:end_line, l:item.end_col)
                                        endif
                                    endif
                            
    4              0.000025         call add(l:new_loclist, l:item)
    4              0.000008     endfor
                            
    2   0.000115   0.000048     let l:type_map = get(ale#Var(a:buffer, 'type_map'), a:linter_name, {})
                            
    2              0.000010     if !empty(l:type_map)
                                    call s:RemapItemTypes(l:type_map, l:new_loclist)
                                endif
                            
    2              0.000006     return l:new_loclist

FUNCTION  ale#util#GetItemPriority()
Called 6 times
Total time:   0.000269
 Self time:   0.000269

count  total (s)   self (s)
    6              0.000033     if a:item.type is# 'I'
                                    return g:ale#util#info_priority
                                endif
                            
    6              0.000021     if a:item.type is# 'W'
                                    if get(a:item, 'sub_type', '') is# 'style'
                                        return g:ale#util#style_warning_priority
                                    endif
                            
                                    return g:ale#util#warning_priority
                                endif
                            
    6              0.000038     if get(a:item, 'sub_type', '') is# 'style'
                                    return g:ale#util#style_error_priority
                                endif
                            
    6              0.000018     return g:ale#util#error_priority

FUNCTION  ale#engine#RunLinters()
Called 1 time
Total time:   0.020724
 Self time:   0.000542

count  total (s)   self (s)
                                " Initialise the buffer information if needed.
    1   0.000051   0.000026     let l:new_buffer = ale#engine#InitBufferInfo(a:buffer)
    1   0.000165   0.000034     call s:StopCurrentJobs(a:buffer, a:should_lint_file)
    1   0.000168   0.000038     call s:RemoveProblemsForDisabledLinters(a:buffer, a:linters)
                            
                                " We can only clear the results if we aren't checking the buffer.
    1   0.000053   0.000023     let l:can_clear_results = !ale#engine#IsCheckingBuffer(a:buffer)
                            
    1   0.000133   0.000093     silent doautocmd <nomodeline> User ALELintPre
                            
    6              0.000036     for l:linter in a:linters
                                    " Only run lint_file linters if we should.
    5              0.000025         if !l:linter.lint_file || a:should_lint_file
    5   0.019929   0.000104             if s:RunLinter(a:buffer, l:linter)
                                            " If a single linter ran, we shouldn't clear everything.
    2              0.000013                 let l:can_clear_results = 0
    2              0.000004             endif
    5              0.000007         else
                                        " If we skipped running a lint_file linter still in the list,
                                        " we shouldn't clear everything.
                                        let l:can_clear_results = 0
                                    endif
    5              0.000013     endfor
                            
                                " Clear the results if we can. This needs to be done when linters are
                                " disabled, or ALE itself is disabled.
    1              0.000003     if l:can_clear_results
                                    call ale#engine#SetResults(a:buffer, [])
                                elseif l:new_buffer
                                    call s:AddProblemsFromOtherBuffers(a:buffer, a:linters)
                                endif

FUNCTION  nerdtree#has_opt()
Called 3 times
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    3              0.000021     return has_key(a:options, a:name) && a:options[a:name] == 1

FUNCTION  airline#builder#should_change_group()
Called 4 times
Total time:   0.001782
 Self time:   0.000157

count  total (s)   self (s)
    4              0.000016   if a:group1 == a:group2
                                return 0
                              endif
    4   0.000836   0.000037   let color1 = airline#highlighter#get_highlight(a:group1)
    4   0.000865   0.000038   let color2 = airline#highlighter#get_highlight(a:group2)
    4              0.000010   if g:airline_gui_mode ==# 'gui'
                                return color1[1] != color2[1] || color1[0] != color2[0]
                              else
    4              0.000016     return color1[3] != color2[3] || color1[2] != color2[2]
                              endif

FUNCTION  <SNR>93_update_untracked()
Called 276 times
Total time:   0.094316
 Self time:   0.085620

count  total (s)   self (s)
  276              0.035453   let file = expand("%:p")
  276              0.006933   if empty(file) || isdirectory(file) || !empty(&buftype)
                                return
                              endif
                            
  276              0.001204   let needs_update = 1
  276              0.003024   let vcs_checks   = get(g:, "airline#extensions#branch#vcs_checks", ["untracked", "dirty"])
  828              0.004112   for vcs in keys(s:vcs_config)
  552              0.006920     if file =~ s:vcs_config[vcs].exclude
                                  " Skip check for files that live in the exclude directory
                                  let needs_update = 0
                                endif
  552              0.004444     if has_key(s:vcs_config[vcs].untracked, file)
  276              0.001017       let needs_update = 0
  276   0.013430   0.004734       call airline#extensions#branch#update_untracked_config(file, vcs)
  276              0.000454     endif
  552              0.000831   endfor
                            
  276              0.000764   if !needs_update
  276              0.000498     return
                              endif
                            
                              for vcs in keys(s:vcs_config)
                                " only check, for git, if fugitive is installed
                                " and for 'hg' if lawrencium is installed, else skip
                                if vcs is# 'git' && !airline#util#has_fugitive()
                                  continue
                                elseif vcs is# 'mercurial' && !airline#util#has_lawrencium()
                                  continue
                                endif
                                let config = s:vcs_config[vcs]
                                " Note that asynchronous update updates s:vcs_config only, and only
                                " s:update_untracked updates b:buffer_vcs_config. If s:vcs_config is
                                " invalidated again before s:update_untracked is called, then we lose the
                                " result of the previous call, i.e. the head string is not updated. It
                                " doesn't happen often in practice, so we let it be.
                                if index(vcs_checks, 'untracked') > -1
                                  call airline#async#vcs_untracked(config, file, vcs)
                                endif
                                " Check clean state of repo
                                if index(vcs_checks, 'dirty') > -1
                                  call airline#async#vcs_clean(config.dirty, file, vcs)
                                endif
                              endfor

FUNCTION  airline#highlighter#exec()
Called 272 times
Total time:   0.143180
 Self time:   0.034487

count  total (s)   self (s)
  272              0.001089   if pumvisible()
                                return
                              endif
  272              0.000943   let colors = a:colors
  272              0.000578   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
                              endif
  272   0.081040   0.003610   let old_hi = airline#highlighter#get_highlight(a:group)
  272              0.001177   if len(colors) == 4
  103              0.000484     call add(colors, '')
  103              0.000124   endif
  272              0.000822   if g:airline_gui_mode ==# 'gui'
                                let new_hi = [colors[0], colors[1], '', '', colors[4]]
                              else
  272              0.003716     let new_hi = ['', '', printf("%s", colors[2]), printf("%s", colors[3]), colors[4]]
  272              0.000390   endif
  272   0.019139   0.003124   let colors = s:CheckDefined(colors)
  272   0.011120   0.003368   if old_hi != new_hi || !s:hl_group_exists(a:group)
   34   0.008123   0.000627     let cmd = printf('hi %s%s', a:group, s:GetHiCmd(colors))
   34              0.001493     exe cmd
   34              0.000312     if has_key(s:hl_groups, a:group)
   34              0.000192       let s:hl_groups[a:group] = colors
   34              0.000052     endif
   34              0.000034   endif

FUNCTION  <SNR>118_Slash()
Called 1656 times
Total time:   0.027990
 Self time:   0.027990

count  total (s)   self (s)
 1656              0.011165   if exists('+shellslash')
                                return tr(a:path, '\', '/')
                              else
 1656              0.004557     return a:path
                              endif

FUNCTION  ale#util#FindItemAtCursor()
Called 1 time
Total time:   0.000414
 Self time:   0.000140

count  total (s)   self (s)
    1              0.000028     let l:info = get(g:ale_buffer_info, a:buffer, {})
    1              0.000014     let l:loclist = get(l:info, 'loclist', [])
    1              0.000009     let l:pos = getpos('.')
    1   0.000342   0.000068     let l:index = ale#util#BinarySearch(l:loclist, a:buffer, l:pos[1], l:pos[2])
    1              0.000008     let l:loc = l:index >= 0 ? l:loclist[l:index] : {}
                            
    1              0.000005     return [l:info, l:loc]

FUNCTION  ale#lsp#ReadMessageData()
Called 1 time
Total time:   0.000805
 Self time:   0.000805

count  total (s)   self (s)
    1              0.000005     let l:response_list = []
    1              0.000005     let l:remainder = a:data
                            
    5              0.000011     while 1
                                    " Look for the end of the HTTP headers
    5              0.000077         let l:body_start_index = matchend(l:remainder, "\r\n\r\n")
                            
    5              0.000018         if l:body_start_index < 0
                                        " No header end was found yet.
    1              0.000002             break
                                    endif
                            
                                    " Parse the Content-Length header.
    4              0.000030         let l:header_data = l:remainder[:l:body_start_index - 4]
    4              0.000134         let l:length_match = matchlist(   l:header_data,   '\vContent-Length: *(\d+)')
                            
    4              0.000022         if empty(l:length_match)
                                        throw "Invalid JSON-RPC header:\n" . l:header_data
                                    endif
                            
                                    " Split the body and the remainder of the text.
    4              0.000037         let l:remainder_start_index = l:body_start_index + str2nr(l:length_match[1])
                            
    4              0.000031         if len(l:remainder) < l:remainder_start_index
                                        " We don't have enough data yet.
                                        break
                                    endif
                            
    4              0.000031         let l:body = l:remainder[l:body_start_index : l:remainder_start_index - 1]
    4              0.000028         let l:remainder = l:remainder[l:remainder_start_index :]
                            
                                    " Parse the JSON object and add it to the list.
    4              0.000197         call add(l:response_list, json_decode(l:body))
    4              0.000012     endwhile
                            
    1              0.000005     return [l:remainder, l:response_list]

FUNCTION  airline#extensions#whitespace#check()
Called 276 times
Total time:   0.094874
 Self time:   0.077043

count  total (s)   self (s)
  276              0.002578   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
  276              0.003617   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
                              endif
  276              0.006056   let skip_check_ft = extend(s:skip_check_ft, get(g:, 'airline#extensions#whitespace#skip_indent_check_ft', {}), 'force')
                            
  276              0.002047   if !exists('b:airline_whitespace_check')
                                let b:airline_whitespace_check = ''
                                let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
                                let trailing = 0
                                let check = 'trailing'
                                if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                  try
                                    let regexp = get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$')
                                    let trailing = search(regexp, 'nw')
                                  catch
                                    call airline#util#warning(printf('Whitespace: error occurred evaluating "%s"', regexp))
                                    echomsg v:exception
                                    return ''
                                  endtry
                                endif
                            
                                let mixed = 0
                                let check = 'indent'
                                if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                  let mixed = s:check_mixed_indent()
                                endif
                            
                                let mixed_file = ''
                                let check = 'mixed-indent-file'
                                if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                  let mixed_file = s:check_mixed_indent_file()
                                endif
                            
                                let long = 0
                                if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
                                endif
                            
                                let conflicts = 0
                                if index(checks, 'conflicts') > -1
                                  let conflicts = s:conflict_marker()
                                endif
                            
                                if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file) || conflicts != 0
                                  let b:airline_whitespace_check = s:symbol
                                  if strlen(s:symbol) > 0
                                    let space = (g:airline_symbols.space)
                                  else
                                    let space = ''
                                  endif
                            
                                  if s:show_message
                                    if trailing != 0
                                      let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
                                      let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
                                    endif
                                    if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
                                    endif
                                    if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
                                    endif
                                    if !empty(mixed_file)
                                      let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
                                    endif
                                    if conflicts != 0
                                      let conflicts_fmt = get(g:, 'airline#extensions#whitespace#conflicts_format', '[%s]conflicts')
                                      let b:airline_whitespace_check .= space.printf(conflicts_fmt, conflicts)
                                    endif
                                  endif
                                endif
                              endif
  276   0.021979   0.004147   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  airline#extensions#tabline#formatters#default#format()
Called 5 times
Total time:   0.001279
 Self time:   0.001098

count  total (s)   self (s)
    5              0.000033   let fmod = get(g:, 'airline#extensions#tabline#fnamemod', ':~:.')
    5              0.000013   let _ = ''
                            
    5              0.000024   let name = bufname(a:bufnr)
    5              0.000018   if empty(name)
                                let _ .= '[No Name]'
                              else
    5              0.000011     if s:fnamecollapse
                                  " Does not handle non-ascii characters like Cyrillic: 'D//t.c'
                                  "let _ .= substitute(fnamemodify(name, fmod), '\v\w\zs.{-}\ze(\\|/)', '', 'g')
    5              0.000767       let _ .= pathshorten(fnamemodify(name, fmod))
    5              0.000011     else
                                  let _ .= fnamemodify(name, fmod)
                                endif
    5              0.000032     if a:bufnr != bufnr('%') && s:fnametruncate && strlen(_) > s:fnametruncate
                                  let _ = strpart(_, 0, s:fnametruncate)
                                endif
    5              0.000004   endif
                            
    5   0.000269   0.000088   return airline#extensions#tabline#formatters#default#wrap_name(a:bufnr, _)

FUNCTION  ale#lsp#CreateMessageData()
Called 2 times
Total time:   0.000345
 Self time:   0.000080

count  total (s)   self (s)
    2              0.000016     if a:message[1][:2] is# 'ts@'
    2   0.000325   0.000060         return s:CreateTSServerMessageData(a:message)
                                endif
                            
                                let l:is_notification = a:message[0]
                            
                                let l:obj = {   'method': a:message[1],   'jsonrpc': '2.0',}
                            
                                if !l:is_notification
                                    let l:obj.id = ale#lsp#GetNextMessageID()
                                endif
                            
                                if len(a:message) > 2
                                    let l:obj.params = a:message[2]
                                endif
                            
                                let l:body = json_encode(l:obj)
                                let l:data = 'Content-Length: ' . strlen(l:body) . "\r\n\r\n" . l:body
                            
                                return [l:is_notification ? 0 : l:obj.id, l:data]

FUNCTION  <SNR>167_UpdateLineNumbers()
Called 2 times
Total time:   0.000407
 Self time:   0.000407

count  total (s)   self (s)
    2              0.000010     let l:line_map = {}
    2              0.000009     let l:line_numbers_changed = 0
                            
    6              0.000029     for [l:line, l:sign_id, l:name] in a:current_sign_list
    4              0.000030         let l:line_map[l:sign_id] = l:line
    4              0.000012     endfor
                            
    8              0.000024     for l:item in a:loclist
    6              0.000023         if l:item.bufnr == a:buffer
    6              0.000067             let l:lnum = get(l:line_map, get(l:item, 'sign_id', 0), 0)
                            
    6              0.000025             if l:lnum && l:item.lnum != l:lnum
                                            let l:item.lnum = l:lnum
                                            let l:line_numbers_changed = 1
                                        endif
    6              0.000007         endif
    6              0.000007     endfor
                            
                                " When the line numbers change, sort the list again
    2              0.000010     if l:line_numbers_changed
                                    call sort(a:loclist, 'ale#util#LocItemCompare')
                                endif

FUNCTION  <SNR>148_RunJob()
Called 1 time
Total time:   0.007151
 Self time:   0.000340

count  total (s)   self (s)
    1   0.000026   0.000015     if ale#command#IsDeferred(a:command)
                                    let a:command.result_callback = {   command -> s:RunJob(command, a:options)}
                            
                                    return 1
                                endif
                            
    1              0.000005     let l:command = a:command
                            
    1              0.000005     if empty(l:command)
                                    return 0
                                endif
                            
    1              0.000006     let l:executable = a:options.executable
    1              0.000005     let l:buffer = a:options.buffer
    1              0.000004     let l:linter = a:options.linter
    1              0.000005     let l:output_stream = a:options.output_stream
    1              0.000005     let l:next_chain_index = a:options.next_chain_index
    1              0.000005     let l:read_buffer = a:options.read_buffer
    1              0.000008     let l:info = g:ale_buffer_info[l:buffer]
                            
    1              0.000024     let l:Callback = function('s:HandleExit', [{   'linter': l:linter,   'executable': l:executable,   'next_chain_index': l:next_chain_index,}])
    1   0.006611   0.000048     let l:result = ale#command#Run(l:buffer, l:command, l:Callback, {   'output_stream': l:output_stream,   'executable': l:executable,   'read_buffer': l:read_buffer,   'log_output': l:next_chain_index >= len(get(l:linter, 'command_chain', [])),})
                            
                                " Only proceed if the job is being run.
    1              0.000006     if empty(l:result)
                                    return 0
                                endif
                            
    1   0.000098   0.000048     call ale#engine#MarkLinterActive(l:info, l:linter)
                            
    1   0.000290   0.000104     silent doautocmd <nomodeline> User ALEJobStarted
                            
    1              0.000007     return 1

FUNCTION  ale#util#StartPartialTimer()
Called 2 times
Total time:   0.000084
 Self time:   0.000084

count  total (s)   self (s)
    2              0.000041     let l:timer_id = timer_start(a:delay, function('s:ApplyPartialTimer'))
    2              0.000030     let s:partial_timers[l:timer_id] = [a:callback, a:args]
                            
    2              0.000007     return l:timer_id

FUNCTION  <SNR>155_HandleTSServerDiagnostics()
Called 2 times
Total time:   0.030400
 Self time:   0.000544

count  total (s)   self (s)
    2              0.000013     let l:linter_name = 'tsserver'
    2              0.000118     let l:buffer = bufnr('^' . a:response.body.file . '$')
    2              0.000025     let l:info = get(g:ale_buffer_info, l:buffer, {})
                            
    2              0.000010     if empty(l:info)
                                    return
                                endif
                            
    2   0.000082   0.000046     call ale#engine#MarkLinterInactive(l:info, l:linter_name)
                            
    2   0.000251   0.000038     if s:ShouldIgnore(l:buffer, l:linter_name)
                                    return
                                endif
                            
    2   0.000443   0.000052     let l:thislist = ale#lsp#response#ReadTSServerDiagnostics(a:response)
    2              0.000009     let l:no_changes = 0
                            
                                " tsserver sends syntax and semantic errors in separate messages, so we
                                " have to collect the messages separately for each buffer and join them
                                " back together again.
    2              0.000010     if a:error_type is# 'syntax'
    1              0.000009         if len(l:thislist) is 0 && len(get(l:info, 'syntax_loclist', [])) is 0
                                        let l:no_changes = 1
                                    endif
                            
    1              0.000011         let l:info.syntax_loclist = l:thislist
    1              0.000002     else
    1              0.000008         if len(l:thislist) is 0 && len(get(l:info, 'semantic_loclist', [])) is 0
                                        let l:no_changes = 1
                                    endif
                            
    1              0.000011         let l:info.semantic_loclist = l:thislist
    1              0.000002     endif
                            
    2              0.000005     if l:no_changes
                                    return
                                endif
                            
    2              0.000028     let l:loclist = get(l:info, 'semantic_loclist', [])   + get(l:info, 'syntax_loclist', [])
                            
    2   0.029269   0.000055     call ale#engine#HandleLoclist(l:linter_name, l:buffer, l:loclist, 0)

FUNCTION  ale#command#InitData()
Called 2 times
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
    2              0.000020     if !has_key(s:buffer_data, a:buffer)
    1              0.000016         let s:buffer_data[a:buffer] = {   'jobs': {},   'file_list': [],   'directory_list': [],}
    1              0.000002     endif

FUNCTION  ale#util#LocItemCompare()
Called 6 times
Total time:   0.000302
 Self time:   0.000302

count  total (s)   self (s)
    6              0.000031     if a:left.bufnr < a:right.bufnr
                                    return -1
                                endif
                            
    6              0.000019     if a:left.bufnr > a:right.bufnr
                                    return 1
                                endif
                            
    6              0.000016     if a:left.bufnr == -1
                                    if a:left.filename < a:right.filename
                                        return -1
                                    endif
                            
                                    if a:left.filename > a:right.filename
                                        return 1
                                    endif
                                endif
                            
    6              0.000021     if a:left.lnum < a:right.lnum
    2              0.000004         return -1
                                endif
                            
    4              0.000012     if a:left.lnum > a:right.lnum
    2              0.000004         return 1
                                endif
                            
    2              0.000006     if a:left.col < a:right.col
    2              0.000004         return -1
                                endif
                            
                                if a:left.col > a:right.col
                                    return 1
                                endif
                            
                                " When either of the items lacks a problem type, then the two items should
                                " be considered equal. This is important for loclist jumping.
                                if !has_key(a:left, 'type') || !has_key(a:right, 'type')
                                    return 0
                                endif
                            
                                let l:left_priority = ale#util#GetItemPriority(a:left)
                                let l:right_priority = ale#util#GetItemPriority(a:right)
                            
                                if l:left_priority < l:right_priority
                                    return -1
                                endif
                            
                                if l:left_priority > l:right_priority
                                    return 1
                                endif
                            
                                return 0

FUNCTION  <SNR>167_BuildSignMap()
Called 2 times
Total time:   0.001769
 Self time:   0.001090

count  total (s)   self (s)
    2   0.000099   0.000036     let l:max_signs = ale#Var(a:buffer, 'max_signs')
                            
    2              0.000007     if l:max_signs is 0
                                    let l:selected_grouped_items = []
                                elseif type(l:max_signs) is v:t_number && l:max_signs > 0
                                    let l:selected_grouped_items = a:grouped_items[:l:max_signs - 1]
                                else
    2              0.000010         let l:selected_grouped_items = a:grouped_items
    2              0.000003     endif
                            
    2              0.000007     let l:sign_map = {}
    2              0.000010     let l:sign_offset = g:ale_sign_offset
                            
    6              0.000176     for [l:line, l:sign_id, l:name] in a:current_sign_list
    4              0.000069         let l:sign_info = get(l:sign_map, l:line, {   'current_id_list': [],   'current_name_list': [],   'new_id': 0,   'new_name': '',   'items': [],})
                            
                                    " Increment the sign offset for new signs, by the maximum sign ID.
    4              0.000015         if l:sign_id > l:sign_offset
    4              0.000014             let l:sign_offset = l:sign_id
    4              0.000006         endif
                            
                                    " Remember the sign names and IDs in separate Lists, so they are easy
                                    " to work with.
    4              0.000029         call add(l:sign_info.current_id_list, l:sign_id)
    4              0.000025         call add(l:sign_info.current_name_list, l:name)
                            
    4              0.000027         let l:sign_map[l:line] = l:sign_info
    4              0.000012     endfor
                            
    6              0.000021     for l:group in l:selected_grouped_items
    4              0.000020         let l:line = l:group[0].lnum
    4              0.000073         let l:sign_info = get(l:sign_map, l:line, {   'current_id_list': [],   'current_name_list': [],   'new_id': 0,   'new_name': '',   'items': [],})
                            
    4   0.000707   0.000091         let l:sign_info.new_name = ale#sign#GetSignName(l:group)
    4              0.000019         let l:sign_info.items = l:group
                            
    4              0.000035         let l:index = index(   l:sign_info.current_name_list,   l:sign_info.new_name)
                            
    4              0.000013         if l:index >= 0
                                        " We have a sign with this name already, so use the same ID.
    3              0.000018             let l:sign_info.new_id = l:sign_info.current_id_list[l:index]
    3              0.000005         else
                                        " This sign name replaces the previous name, so use a new ID.
    1              0.000004             let l:sign_info.new_id = l:sign_offset + 1
    1              0.000004             let l:sign_offset += 1
    1              0.000001         endif
                            
    4              0.000027         let l:sign_map[l:line] = l:sign_info
    4              0.000008     endfor
                            
    2              0.000005     return l:sign_map

FUNCTION  <SNR>168_ShouldOpen()
Called 2 times
Total time:   0.000128
 Self time:   0.000066

count  total (s)   self (s)
    2   0.000095   0.000033     let l:val = ale#Var(a:buffer, 'open_list')
    2              0.000016     let l:saved = getbufvar(a:buffer, 'ale_save_event_fired', 0)
                            
    2              0.000011     return l:val is 1 || (l:val is# 'on_save' && l:saved)

FUNCTION  <SNR>91_get_hunks_gitgutter()
Called 276 times
Total time:   0.033506
 Self time:   0.009122

count  total (s)   self (s)
  276   0.009147   0.004695   if !get(g:, 'gitgutter_enabled', 0) || s:is_branch_empty()
                                return ''
                              endif
  276   0.022880   0.002949   return GitGutterGetHunkSummary()

FUNCTION  ale#highlight#CreatePositions()
Called 6 times
Total time:   0.000088
 Self time:   0.000088

count  total (s)   self (s)
    6              0.000026     if a:line >= a:end_line
                                    " For single lines, just return the one position.
    6              0.000046         return [[[a:line, a:col, a:end_col - a:col + 1]]]
                                endif
                            
                                " Get positions from the first line at the first column, up to a large
                                " integer for highlighting up to the end of the line, followed by
                                " the lines in-between, for highlighting entire lines, and
                                " a highlight for the last line, up to the end column.
                                let l:all_positions =   [[a:line, a:col, s:MAX_COL_SIZE]]   + range(a:line + 1, a:end_line - 1)   + [[a:end_line, 1, a:end_col]]
                            
                                return map(   range(0, len(l:all_positions) - 1, s:MAX_POS_VALUES),   'l:all_positions[v:val : v:val + s:MAX_POS_VALUES - 1]',)

FUNCTION  jsx_pretty#comment#update_commentstring()
Called 1 time
Total time:   0.002400
 Self time:   0.000181

count  total (s)   self (s)
    1   0.001124   0.000041   let syn_current = s:syn_name(line('.'), col('.'))
    1   0.001162   0.000027   let syn_start = s:syn_name(line('.'), 1)
    1              0.000013   let save_cursor = getcurpos()
                            
    1              0.000015   if syn_start =~? '^jsx'
                                let line = getline(".")
                                let start = len(matchstr(line, '^\s*'))
                                let syn_name = s:syn_name(line('.'), start + 1)
                            
                                if line =~ '^\s*//'
                                  let &l:commentstring = '// %s'
                                elseif s:syn_contains(line('.'), col('.'), 'jsxTaggedRegion')
                                  let &l:commentstring = '<!-- %s -->'
                                elseif syn_name =~? '^jsxAttrib'
                                  let &l:commentstring = '// %s'
                                else
                                  let &l:commentstring = '{/* %s */}'
                                endif
                              else
    1              0.000016     let &l:commentstring = a:original
    1              0.000003   endif
                            
                              " Restore the cursor position
    1              0.000009   call setpos('.', save_cursor)

FUNCTION  <SNR>119_IdentifierFinishedOperations()
Called 272 times
Total time:   0.445233
 Self time:   0.019751

count  total (s)   self (s)
  272   0.429376   0.003895   if !s:Pyeval( 'base.CurrentIdentifierFinished()' )
  270              0.001382     return
                              endif
    2              0.013778   exec s:python_command "ycm_state.OnCurrentIdentifierFinished()"
    2              0.000026   let s:force_semantic = 0
    2              0.000016   let s:completion = s:default_completion

FUNCTION  ale#command#ManageDirectory()
Called 1 time
Total time:   0.000071
 Self time:   0.000040

count  total (s)   self (s)
    1   0.000057   0.000026     call ale#command#InitData(a:buffer)
    1              0.000012     call add(s:buffer_data[a:buffer].directory_list, a:directory)

FUNCTION  ale#sign#FindCurrentSigns()
Called 2 times
Total time:   0.002990
 Self time:   0.000085

count  total (s)   self (s)
    2   0.000296   0.000039     let l:line_list = ale#sign#ReadSigns(a:buffer)
                            
    2   0.002689   0.000041     return ale#sign#ParseSigns(l:line_list)

FUNCTION  ale#statusline#Update()
Called 2 times
Total time:   0.000934
 Self time:   0.000898

count  total (s)   self (s)
    2              0.000026     if !exists('g:ale_buffer_info') || !has_key(g:ale_buffer_info, a:buffer)
                                    return
                                endif
                            
    2              0.000037     let l:loclist = filter(copy(a:loclist), 'v:val.bufnr == a:buffer')
    2   0.000083   0.000047     let l:count = s:CreateCountDict()
    2              0.000014     let l:count.total = len(l:loclist)
                            
                                " Allows easy access to the first instance of each problem type.
    2              0.000009     let l:first_problems = {}
                            
    8              0.000025     for l:entry in l:loclist
    6              0.000024         if l:entry.type is# 'W'
                                        if get(l:entry, 'sub_type', '') is# 'style'
                                            let l:count.style_warning += 1
                            
                                            if l:count.style_warning == 1
                                                let l:first_problems.style_warning = l:entry
                                            endif
                                        else
                                            let l:count.warning += 1
                            
                                            if l:count.warning == 1
                                                let l:first_problems.warning = l:entry
                                            endif
                                        endif
                                    elseif l:entry.type is# 'I'
                                        let l:count.info += 1
                            
                                        if l:count.info == 1
                                            let l:first_problems.info = l:entry
                                        endif
                                    elseif get(l:entry, 'sub_type', '') is# 'style'
                                        let l:count.style_error += 1
                            
                                        if l:count.style_error == 1
                                            let l:first_problems.style_error = l:entry
                                        endif
                                    else
    6              0.000023             let l:count.error += 1
                            
    6              0.000021             if l:count.error == 1
    2              0.000010                 let l:first_problems.error = l:entry
    2              0.000003             endif
    6              0.000008         endif
    6              0.000009     endfor
                            
                                " Set keys for backwards compatibility.
    2              0.000017     let l:count[0] = l:count.error + l:count.style_error
    2              0.000015     let l:count[1] = l:count.total - l:count[0]
                            
    2              0.000033     let g:ale_buffer_info[a:buffer].count = l:count
    2              0.000022     let g:ale_buffer_info[a:buffer].first_problems = l:first_problems

FUNCTION  airline#parts#spell()
Called 276 times
Total time:   0.017224
 Self time:   0.017224

count  total (s)   self (s)
  276              0.007780   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
  276              0.001482   if g:airline_detect_spell && &spell
                                let winwidth = airline#util#winwidth()
                                if winwidth >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth >= 70
                                  return g:airline_symbols.spell
                                else
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
                              endif
  276              0.000484   return ''

FUNCTION  <SNR>140_ApplyPartialTimer()
Called 2 times
Total time:   0.002869
 Self time:   0.000124

count  total (s)   self (s)
    2              0.000021     if has_key(s:partial_timers, a:timer_id)
    2              0.000034         let [l:Callback, l:args] = remove(s:partial_timers, a:timer_id)
    2   0.002806   0.000060         call call(l:Callback, [a:timer_id] + l:args)
    2              0.000004     endif

FUNCTION  <SNR>95_airline_ale_count()
Called 548 times
Total time:   0.003686
 Self time:   0.003686

count  total (s)   self (s)
  548              0.003125   return a:cnt ? a:symbol. a:cnt : ''

FUNCTION  ale#linter#GetAll()
Called 1 time
Total time:   0.000134
 Self time:   0.000107

count  total (s)   self (s)
                                " Don't return linters in the sandbox.
                                " Otherwise a sandboxed script could modify them.
    1   0.000039   0.000013     if ale#util#InSandbox()
                                    return []
                                endif
                            
    1              0.000006     let l:combined_linters = []
                            
    2              0.000008     for l:filetype in a:filetypes
                                    " Load linters from runtimepath if we haven't done that yet.
    1              0.000007         if !has_key(s:runtime_loaded_map, l:filetype)
                                        execute 'silent! runtime! ale_linters/' . l:filetype . '/*.vim'
                            
                                        let s:runtime_loaded_map[l:filetype] = 1
                                    endif
                            
    1              0.000015         call extend(l:combined_linters, get(s:linters, l:filetype, []))
    1              0.000002     endfor
                            
    1              0.000003     return l:combined_linters

FUNCTION  ale#linter#ResolveFiletype()
Called 1 time
Total time:   0.000162
 Self time:   0.000049

count  total (s)   self (s)
    1   0.000148   0.000035     let l:filetype = s:GetAliasedFiletype(a:original_filetype)
                            
    1              0.000006     if type(l:filetype) isnot v:t_list
    1              0.000005         return [l:filetype]
                                endif
                            
                                return l:filetype

FUNCTION  <SNR>119_InsideCommentOrStringAndShouldStop()
Called 272 times
Total time:   0.166785
 Self time:   0.011777

count  total (s)   self (s)
  272   0.159794   0.004787   let retval = s:InsideCommentOrString()
  272              0.001419   let inside_comment = retval == 1
  272              0.001061   let inside_string = retval == 2
                            
  272              0.001597   if inside_comment && g:ycm_complete_in_comments || inside_string && g:ycm_complete_in_strings
                                return 0
                              endif
                            
  272              0.000589   return retval

FUNCTION  airline#extensions#tagbar#currenttag()
Called 276 times
Total time:   0.016246
 Self time:   0.015035

count  total (s)   self (s)
  276              0.001928   if get(w:, 'airline_active', 0)
  276              0.000783     if !s:init
                                  try
                                    " try to load the plugin, if filetypes are disabled,
                                    " this will cause an error, so try only once
                                    let a=tagbar#currenttag('%', '', '')
                                  catch
                                  endtry
                                  unlet! a
                                  let s:init=1
                                endif
                                " function tagbar#currenttag does not exist, if filetype is not enabled
  276              0.002285     if s:airline_tagbar_last_lookup_time != localtime() && exists("*tagbar#currenttag")
   15   0.001483   0.000273       let s:airline_tagbar_last_lookup_val = tagbar#currenttag('%s', '', s:flags)
   15              0.000099       let s:airline_tagbar_last_lookup_time = localtime()
   15              0.000023     endif
  276              0.000948     return s:airline_tagbar_last_lookup_val
                              endif
                              return ''

FUNCTION  <SNR>104_hl_group_exists()
Called 238 times
Total time:   0.007753
 Self time:   0.007753

count  total (s)   self (s)
  238              0.002518   if !hlexists(a:group)
                                return 0
                              elseif empty(synIDattr(hlID(a:group), 'fg'))
                                return 0
                              endif
  238              0.000326   return 1

FUNCTION  ale#util#Mode()
Called 4 times
Total time:   0.000049
 Self time:   0.000049

count  total (s)   self (s)
    4              0.000042     return call('mode', a:000)

FUNCTION  <SNR>157_SendMessageData()
Called 2 times
Total time:   0.000316
 Self time:   0.000121

count  total (s)   self (s)
    2              0.000014     if has_key(a:conn, 'job_id')
    2   0.000242   0.000046         call ale#job#SendRaw(a:conn.job_id, a:data)
    2              0.000023     elseif has_key(a:conn, 'channel_id') && ale#socket#IsOpen(a:conn.channel_id)
                                    " Send the message to the server
                                    call ale#socket#Send(a:conn.channel_id, a:data)
                                else
                                    return 0
                                endif
                            
    2              0.000004     return 1

FUNCTION  <SNR>136_Init()
Called 15 times
Total time:   0.000133
 Self time:   0.000133

count  total (s)   self (s)
   15              0.000073     if s:checked_ctags == 2 && a:silent
   15              0.000033         return 0
                                elseif s:checked_ctags != 1
                                    if !s:CheckForExCtags(a:silent)
                                        return 0
                                    endif
                                endif
                            
                                if !s:type_init_done
                                    call s:InitTypes()
                                endif
                            
                                if !s:autocommands_done
                                    call s:CreateAutocommands()
                                    call s:AutoUpdate(fnamemodify(expand('%'), ':p'), 0)
                                endif
                            
                                let s:init_done = 1
                                return 1

FUNCTION  <SNR>168_SetListsImpl()
Called 2 times
Total time:   0.002746
 Self time:   0.000991

count  total (s)   self (s)
    2              0.000280     let l:title = expand('#' . a:buffer . ':p')
                            
    2              0.000009     if g:ale_set_quickfix
                                    let l:quickfix_list = ale#list#GetCombinedList()
                            
                                    if has('nvim')
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list), ' ', l:title)
                                    else
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list))
                                        call setqflist([], 'r', {'title': l:title})
                                    endif
                                elseif g:ale_set_loclist
                                    " If windows support is off, win_findbuf() may not exist.
                                    " We'll set result in the current window, which might not be correct,
                                    " but it's better than nothing.
    2   0.000084   0.000047         let l:ids = s:WinFindBuf(a:buffer)
                            
    4              0.000017         for l:id in l:ids
    2              0.000016             if has('nvim')
    2   0.001656   0.000124                 call setloclist(l:id, s:FixList(a:buffer, a:loclist), ' ', l:title)
    2              0.000005             else
                                            call setloclist(l:id, s:FixList(a:buffer, a:loclist))
                                            call setloclist(l:id, [], 'r', {'title': l:title})
                                        endif
    2              0.000003         endfor
    2              0.000003     endif
                            
                                " Open a window to show the problems if we need to.
                                "
                                " We'll check if the current buffer's List is not empty here, so the
                                " window will only be opened if the current buffer has problems.
    2   0.000172   0.000044     if s:ShouldOpen(a:buffer) && !empty(a:loclist)
                                    let l:winnr = winnr()
                                    let l:mode = mode()
                                    let l:reset_visual_selection = l:mode is? 'v' || l:mode is# "\<c-v>"
                                    let l:reset_character_selection = l:mode is? 's' || l:mode is# "\<c-s>"
                            
                                    " open windows vertically instead of default horizontally
                                    let l:open_type = ''
                            
                                    if ale#Var(a:buffer, 'list_vertical') == 1
                                        let l:open_type = 'vert rightbelow '
                                    endif
                            
                                    if g:ale_set_quickfix
                                        if !ale#list#IsQuickfixOpen()
                                            silent! execute l:open_type . 'copen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                        endif
                                    elseif g:ale_set_loclist
                                        silent! execute l:open_type . 'lopen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                    endif
                            
                                    " If focus changed, restore it (jump to the last window).
                                    if l:winnr isnot# winnr()
                                        wincmd p
                                    endif
                            
                                    if l:reset_visual_selection || l:reset_character_selection
                                        " If we were in a selection mode before, select the last selection.
                                        normal! gv
                            
                                        if l:reset_character_selection
                                            " Switch back to Select mode, if we were in that.
                                            normal! "\<c-g>"
                                        endif
                                    endif
                                endif
                            
                                " If ALE isn't currently checking for more problems, close the window if
                                " needed now. This check happens inside of this timer function, so
                                " the window can be closed reliably.
    2   0.000087   0.000031     if !ale#engine#IsCheckingBuffer(a:buffer)
                                    call s:CloseWindowIfNeeded(a:buffer)
                                endif

FUNCTION  ale#util#InSandbox()
Called 5 times
Total time:   0.000169
 Self time:   0.000161

count  total (s)   self (s)
    5              0.000015     try
    5   0.000085   0.000076         let &l:equalprg=&l:equalprg
    5              0.000017     catch /E48/
                                    " E48 is the sandbox error.
                                    return 1
                                endtry
                            
    5              0.000010     return 0

FUNCTION  airline#parts#crypt()
Called 276 times
Total time:   0.004570
 Self time:   0.004570

count  total (s)   self (s)
  276              0.004274   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  <SNR>104_CheckDefined()
Called 272 times
Total time:   0.016015
 Self time:   0.016015

count  total (s)   self (s)
                              " Checks, whether the definition of the colors is valid and is not empty or NONE
                              " e.g. if the colors would expand to this:
                              " hi airline_c ctermfg=NONE ctermbg=NONE
                              " that means to clear that highlighting group, therefore, fallback to Normal
                              " highlighting group for the cterm values
                            
                              " This only works, if the Normal highlighting group is actually defined, so
                              " return early, if it has been cleared
  272              0.001804   if !exists("g:airline#highlighter#normal_fg_hi")
                                let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
                              endif
  272              0.001705   if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
                                return a:colors
                              endif
                            
  512              0.002145   for val in a:colors
  512              0.002622     if !empty(val) && val !=# 'NONE'
  272              0.000650       return a:colors
                                endif
  240              0.000328   endfor
                              " this adds the bold attribute to the term argument of the :hi command,
                              " but at least this makes sure, the group will be defined
                              let fg = g:airline#highlighter#normal_fg_hi
                              let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                              if bg < 0
                                " in case there is no background color defined for Normal
                                let bg = a:colors[3]
                              endif
                              return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  <SNR>107_section_is_empty()
Called 11 times
Total time:   0.000183
 Self time:   0.000183

count  total (s)   self (s)
   11              0.000035   let start=1
                            
                              " do not check for inactive windows or the tabline
   11              0.000033   if a:self._context.active == 0
                                return 0
                              elseif get(a:self._context, 'tabline', 0)
   11              0.000016     return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
                              if get(g:, 'airline_skip_empty_sections', 0) == 0
                                return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
                              if get(w:, 'airline_skip_empty_sections', -1) == 0
                                return 0
                              endif
                              " assume accents sections to be never empty
                              " (avoides, that on startup the mode message becomes empty)
                              if match(a:content, '%#__accent_[^#]*#.*__restore__#') > -1
                                return 0
                              endif
                              if empty(a:content)
                                return 1
                              endif
                              let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              if empty(list)
                                return 0 " no function in statusline text
                              endif
                              while len(list) > 0
                                let expr = list[0]
                                try
                                  " catch all exceptions, just in case
                                  if !empty(eval(expr))
                                    return 0
                                  endif
                                catch
                                  return 0
                                endtry
                                let start += 1
                                let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              endw
                              return 1

FUNCTION  airline#extensions#branch#head()
Called 276 times
Total time:   0.755713
 Self time:   0.017626

count  total (s)   self (s)
  276              0.002088   if !exists('b:buffer_vcs_config')
                                call s:init_buffer()
                              endif
                            
  276   0.647516   0.003744   call s:update_branch()
  276   0.098891   0.004575   call s:update_untracked()
                            
  276              0.002806   if exists('b:airline_head') && !empty(b:airline_head)
  276              0.001061     return b:airline_head
                              endif
                            
                              let b:airline_head = ''
                              let vcs_priority = get(g:, "airline#extensions#branch#vcs_priority", ["git", "mercurial"])
                            
                              let heads = []
                              for vcs in vcs_priority
                                if !empty(b:buffer_vcs_config[vcs].branch)
                                  let heads += [vcs]
                                endif
                              endfor
                            
                              for vcs in heads
                                if !empty(b:airline_head)
                                  let b:airline_head .= ' | '
                                endif
                                if len(heads) > 1
                                  let b:airline_head .= s:vcs_config[vcs].exe .':'
                                endif
                                let b:airline_head .= s:format_name({s:vcs_config[vcs].display_branch}())
                                let additional = b:buffer_vcs_config[vcs].untracked
                                if empty(additional) && has_key(b:buffer_vcs_config[vcs], 'dirty') && b:buffer_vcs_config[vcs].dirty
                                  let additional = g:airline_symbols['dirty']
                                endif
                                let b:airline_head .= additional
                              endfor
                            
                              if empty(heads)
                                if airline#util#has_vcscommand()
                                  noa call VCSCommandEnableBufferSetup()
                                  if exists('b:VCSCommandBufferInfo')
                                    let b:airline_head = s:format_name(get(b:VCSCommandBufferInfo, 0, ''))
                                  endif
                                endif
                              endif
                            
                              if empty(heads)
                                if airline#util#has_custom_scm()
                                  try
                                    let Fn = function(g:airline#extensions#branch#custom_head)
                                    let b:airline_head = Fn()
                                  endtry
                                endif
                              endif
                            
                              if exists("g:airline#extensions#branch#displayed_head_limit")
                                let w:displayed_head_limit = g:airline#extensions#branch#displayed_head_limit
                                if len(b:airline_head) > w:displayed_head_limit - 1
                                  let b:airline_head = b:airline_head[0:(w:displayed_head_limit - 1)].(&encoding ==? 'utf-8' ?  '' : '.')
                                endif
                              endif
                            
                              return b:airline_head

FUNCTION  ale#handlers#eslint#GetExecutable()
Called 2 times
Total time:   0.002908
 Self time:   0.000063

count  total (s)   self (s)
    2   0.002906   0.000061     return ale#node#FindExecutable(a:buffer, 'javascript_eslint', [   'node_modules/.bin/eslint_d',   'node_modules/eslint/bin/eslint.js',   'node_modules/.bin/eslint',])

FUNCTION  ale#lsp_linter#FindProjectRoot()
Called 1 time
Total time:   0.000609
 Self time:   0.000144

count  total (s)   self (s)
    1              0.000012     let l:buffer_ale_root = getbufvar(a:buffer, 'ale_lsp_root', {})
                            
    1              0.000006     if type(l:buffer_ale_root) is v:t_string
                                    return l:buffer_ale_root
                                endif
                            
                                " Try to get a buffer-local setting for the root
    1              0.000007     if has_key(l:buffer_ale_root, a:linter.name)
                                    let l:Root = l:buffer_ale_root[a:linter.name]
                            
                                    if type(l:Root) is v:t_func
                                        return l:Root(a:buffer)
                                    else
                                        return l:Root
                                    endif
                                endif
                            
                                " Try to get a global setting for the root
    1              0.000011     if has_key(g:ale_lsp_root, a:linter.name)
                                    let l:Root = g:ale_lsp_root[a:linter.name]
                            
                                    if type(l:Root) is v:t_func
                                        return l:Root(a:buffer)
                                    else
                                        return l:Root
                                    endif
                                endif
                            
                                " Fall back to the linter-specific configuration
    1              0.000006     if has_key(a:linter, 'project_root')
    1              0.000008         let l:Root = a:linter.project_root
                            
    1   0.000503   0.000039         return type(l:Root) is v:t_func ? l:Root(a:buffer) : l:Root
                                endif
                            
                                return ale#util#GetFunction(a:linter.project_root_callback)(a:buffer)

FUNCTION  ale#lsp#NotifyForChanges()
Called 1 time
Total time:   0.001028
 Self time:   0.000212

count  total (s)   self (s)
    1              0.000011     let l:conn = get(s:connections, a:conn_id, {})
    1              0.000005     let l:notified = 0
                            
    1              0.000011     if !empty(l:conn) && has_key(l:conn.open_documents, a:buffer)
    1              0.000009         let l:new_tick = getbufvar(a:buffer, 'changedtick')
                            
    1              0.000007         if l:conn.open_documents[a:buffer] < l:new_tick
    1              0.000003             if l:conn.is_tsserver
    1   0.000423   0.000093                 let l:message = ale#lsp#tsserver_message#Change(a:buffer)
    1              0.000003             else
                                            let l:message = ale#lsp#message#DidChange(a:buffer)
                                        endif
                            
    1   0.000512   0.000025             call ale#lsp#Send(a:conn_id, l:message)
    1              0.000014             let l:conn.open_documents[a:buffer] = l:new_tick
    1              0.000005             let l:notified = 1
    1              0.000002         endif
    1              0.000001     endif
                            
    1              0.000003     return l:notified

FUNCTION  304()
Called 1 time
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000009       let bufnum = get(self.buffers, a:i, -1)
    1              0.000007       return '%'.bufnum.'@airline#extensions#tabline#buffers#clickbuf@'

FUNCTION  <SNR>17_Slash()
Called 552 times
Total time:   0.009179
 Self time:   0.009179

count  total (s)   self (s)
  552              0.003542   if exists('+shellslash')
                                return tr(a:path, '\', '/')
                              else
  552              0.001597     return a:path
                              endif

FUNCTION  GitGutterGetHunkSummary()
Called 276 times
Total time:   0.019931
 Self time:   0.004437

count  total (s)   self (s)
  276   0.019509   0.004015   return gitgutter#hunk#summary(winbufnr(0))

FUNCTION  airline#parts#mode()
Called 276 times
Total time:   0.024864
 Self time:   0.005796

count  total (s)   self (s)
  276   0.024510   0.005442   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  ale#highlight#SetHighlights()
Called 2 times
Total time:   0.001617
 Self time:   0.000171

count  total (s)   self (s)
    2              0.000057     let l:new_list = getbufvar(a:buffer, 'ale_enabled', 1) && g:ale_enabled   ? filter(copy(a:loclist), 'v:val.bufnr == a:buffer && v:val.col > 0')   : []
                            
                                " Set the list in the buffer variable.
    2              0.000053     call setbufvar(str2nr(a:buffer), 'ale_highlight_items', l:new_list)
                            
                                " Update highlights for the current buffer, which may or may not
                                " be the buffer we just set highlights for.
    2   0.001494   0.000049     call ale#highlight#UpdateHighlights()

FUNCTION  ale#engine#SetResults()
Called 2 times
Total time:   0.025957
 Self time:   0.000423

count  total (s)   self (s)
    2   0.000087   0.000034     let l:linting_is_done = !ale#engine#IsCheckingBuffer(a:buffer)
                            
                                " Set signs first. This could potentially fix some line numbers.
                                " The List could be sorted again here by SetSigns.
    2              0.000007     if g:ale_set_signs
    2   0.022774   0.000081         call ale#sign#SetSigns(a:buffer, a:loclist)
    2              0.000004     endif
                            
    2              0.000010     if g:ale_set_quickfix || g:ale_set_loclist
    2   0.000289   0.000050         call ale#list#SetLists(a:buffer, a:loclist)
    2              0.000002     endif
                            
    2              0.000014     if exists('*ale#statusline#Update')
                                    " Don't load/run if not already loaded.
    2   0.000977   0.000043         call ale#statusline#Update(a:buffer, a:loclist)
    2              0.000004     endif
                            
    2              0.000006     if g:ale_set_highlights
    2   0.001659   0.000043         call ale#highlight#SetHighlights(a:buffer, a:loclist)
    2              0.000003     endif
                            
    2              0.000006     if l:linting_is_done
                                    if g:ale_echo_cursor
                                        " Try and echo the warning now.
                                        " This will only do something meaningful if we're in normal mode.
                                        call ale#cursor#EchoCursorWarning()
                                    endif
                            
                                    if g:ale_virtualtext_cursor
                                        " Try and show the warning now.
                                        " This will only do something meaningful if we're in normal mode.
                                        call ale#virtualtext#ShowCursorWarning()
                                    endif
                            
                                    " Reset the save event marker, used for opening windows, etc.
                                    call setbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Set a marker showing how many times a buffer has been checked.
                                    call setbufvar(   a:buffer,   'ale_linted',   getbufvar(a:buffer, 'ale_linted', 0) + 1)
                            
                                    " Automatically remove all managed temporary files and directories
                                    " now that all jobs have completed.
                                    call ale#command#RemoveManagedFiles(a:buffer)
                            
                                    " Call user autocommands. This allows users to hook into ALE's lint cycle.
                                    silent doautocmd <nomodeline> User ALELintPost
                                endif

FUNCTION  ale#lsp_linter#OnInit()
Called 1 time
Total time:   0.002334
 Self time:   0.000280

count  total (s)   self (s)
    1              0.000007     let l:buffer = a:details.buffer
    1              0.000005     let l:conn_id = a:details.connection_id
    1              0.000004     let l:command = a:details.command
                            
    1   0.000090   0.000040     let l:config = ale#lsp_linter#GetConfig(l:buffer, a:linter)
    1   0.000093   0.000065     let l:language_id = ale#util#GetFunction(a:linter.language_callback)(l:buffer)
                            
    1   0.000056   0.000029     call ale#lsp#UpdateConfig(l:conn_id, l:buffer, l:config)
                            
    1   0.000103   0.000032     if ale#lsp#OpenDocument(l:conn_id, l:buffer, l:language_id)
                                    if g:ale_history_enabled && !empty(l:command)
                                        call ale#history#Add(l:buffer, 'started', l:conn_id, l:command)
                                    endif
                                endif
                            
                                " The change message needs to be sent for tsserver before doing anything.
    1              0.000005     if a:linter.lsp is# 'tsserver'
    1   0.001063   0.000034         call ale#lsp#NotifyForChanges(l:conn_id, l:buffer)
    1              0.000002     endif
                            
    1   0.000881   0.000031     call a:Callback(a:linter, a:details)

FUNCTION  ale#sign#ParseSigns()
Called 2 times
Total time:   0.002649
 Self time:   0.002649

count  total (s)   self (s)
                                " Matches output like :
                                " line=4  id=1  name=ALEErrorSign
                                " =1  id=1000001  =ALEErrorSign
                                " =1  =1000001  =ALEWarningSign
                                " lnea=12 id=1000001 nombre=ALEWarningSign
                                " riga=1 id=1000001, nome=ALEWarningSign
    2              0.000011     let l:pattern = '\v^.*\=(\d+).*\=(\d+).*\=(ALE[a-zA-Z]+Sign)'
    2              0.000007     let l:result = []
    2              0.000008     let l:is_dummy_sign_set = 0
                            
   32              0.000103     for l:line in a:line_list
   30              0.001541         let l:match = matchlist(l:line, l:pattern)
                            
   30              0.000182         if len(l:match) > 0
    6              0.000031             if l:match[3] is# 'ALEDummySign'
    2              0.000007                 let l:is_dummy_sign_set = 1
    2              0.000004             else
    4              0.000058                 call add(l:result, [   str2nr(l:match[1]),   str2nr(l:match[2]),   l:match[3],])
    4              0.000008             endif
    6              0.000007         endif
   30              0.000050     endfor
                            
    2              0.000011     return [l:is_dummy_sign_set, l:result]

FUNCTION  fugitive#Find()
Called 552 times
Total time:   0.473181
 Self time:   0.319462

count  total (s)   self (s)
  552              0.004502   if type(a:object) == type(0)
                                let name = bufname(a:object)
                                return s:PlatformSlash(name =~# '^$\|^/\|^\a\+:' ? name : getcwd() . '/' . name)
                              elseif a:object =~# '^[~$]'
                                let prefix = matchstr(a:object, '^[~$]\i*')
                                let owner = expand(prefix)
                                return s:PlatformSlash((len(owner) ? owner : prefix) . strpart(a:object, len(prefix)))
                              elseif s:Slash(a:object) =~# '^$\|^/\|^\%(\a\a\+:\).*\%(//\|::\)' . (has('win32') ? '\|^\a:/' : '')
                                return s:PlatformSlash(a:object)
                              elseif s:Slash(a:object) =~# '^\.\.\=\%(/\|$\)'
                                return s:PlatformSlash(simplify(getcwd() . '/' . a:object))
                              endif
  552              0.004406   let dir = a:0 ? a:1 : s:Dir()
  552              0.002690   if empty(dir)
                                let file = matchstr(a:object, '^\%(:\d:\|[^:]*:\)\zs.*', '', '')
                                let dir = FugitiveExtractGitDir(file)
                                if empty(dir)
                                  return fnamemodify(len(file) ? file : a:object, ':p')
                                endif
                              endif
  552   0.016726   0.007837   let rev = s:Slash(a:object)
  552   0.090359   0.007776   let tree = s:Tree(dir)
  552              0.004569   let base = len(tree) ? tree : 'fugitive://' . dir . '//0'
  552              0.002043   if rev ==# '.git'
                                let f = len(tree) ? tree . '/.git' : dir
                              elseif rev =~# '^\.git/'
  552              0.009752     let f = substitute(rev, '^\.git', '', '')
  552   0.041734   0.008731     let cdir = fugitive#CommonDir(dir)
  552              0.007511     if f =~# '^/\.\./\.\.\%(/\|$\)'
                                  let f = simplify(len(tree) ? tree . f[3:-1] : dir . f)
                                elseif f =~# '^/\.\.\%(/\|$\)'
                                  let f = base . f[3:-1]
                                elseif cdir !=# dir && ( f =~# '^/\%(config\|hooks\|info\|logs/refs\|objects\|refs\|worktrees\)\%(/\|$\)' || f !~# '^/\%(index$\|index\.lock$\|\w*MSG$\|\w*HEAD$\|logs/\w*HEAD$\|logs$\|rebase-\w\+\)\%(/\|$\)' && getftime(dir . f) < 0 && getftime(cdir . f) >= 0)
                                  let f = simplify(cdir . f)
                                else
  552              0.004691       let f = simplify(dir . f)
  552              0.000896     endif
  552              0.001214   elseif rev ==# ':/'
                                let f = base
                              elseif rev =~# '^\.\%(/\|$\)'
                                let f = base . rev[1:-1]
                              elseif rev =~# '^::\%(/\|\a\+\:\)'
                                let f = rev[2:-1]
                              elseif rev =~# '^::\.\.\=\%(/\|$\)'
                                let f = simplify(getcwd() . '/' . rev[2:-1])
                              elseif rev =~# '^::'
                                let f = base . '/' . rev[2:-1]
                              elseif rev =~# '^:\%([0-3]:\)\=\.\.\=\%(/\|$\)\|^:[0-3]:\%(/\|\a\+:\)'
                                let f = rev =~# '^:\%([0-3]:\)\=\.' ? simplify(getcwd() . '/' . matchstr(rev, '\..*')) : rev[3:-1]
                                if s:cpath(base . '/', (f . '/')[0 : len(base)])
                                  let f = 'fugitive://' . dir . '//' . +matchstr(rev, '^:\zs\d\ze:') . '/' . strpart(f, len(base) + 1)
                                else
                                  let altdir = FugitiveExtractGitDir(f)
                                  if len(altdir) && !s:cpath(dir, altdir)
                                    return fugitive#Find(a:object, altdir)
                                  endif
                                endif
                              elseif rev =~# '^:[0-3]:'
                                let f = 'fugitive://' . dir . '//' . rev[1] . '/' . rev[3:-1]
                              elseif rev ==# ':'
                                if $GIT_INDEX_FILE =~# '/[^/]*index[^/]*\.lock$' && s:cpath(fnamemodify($GIT_INDEX_FILE,':p')[0:strlen(dir)]) ==# s:cpath(dir . '/') && filereadable($GIT_INDEX_FILE)
                                  let f = fnamemodify($GIT_INDEX_FILE, ':p')
                                else
                                  let f = fugitive#Find('.git/index', dir)
                                endif
                              elseif rev =~# '^:(\%(top\|top,literal\|literal,top\|literal\))'
                                let f = base . '/' . matchstr(rev, ')\zs.*')
                              elseif rev =~# '^:/\@!'
                                let f = 'fugitive://' . dir . '//0/' . rev[1:-1]
                              else
                                if rev =~# 'HEAD$\|^refs/' && rev !~# ':'
                                  let cdir = rev =~# '^refs/' ? fugitive#CommonDir(dir) : dir
                                  if filereadable(cdir . '/' . rev)
                                    let f = simplify(cdir . '/' . rev)
                                  endif
                                endif
                                if !exists('f')
                                  let commit = substitute(matchstr(rev, '^[^:]\+\|^:.*'), '^@\%($\|[~^]\|@{\)\@=', 'HEAD', '')
                                  let file = substitute(matchstr(rev, '^[^:]\+\zs:.*'), '^:', '/', '')
                                  if file =~# '^/\.\.\=\%(/\|$\)\|^//\|^/\a\+:'
                                    let file = file =~# '^/\.' ? simplify(getcwd() . file) : file[1:-1]
                                    if s:cpath(base . '/', (file . '/')[0 : len(base)])
                                      let file = '/' . strpart(file, len(base) + 1)
                                    else
                                      let altdir = FugitiveExtractGitDir(file)
                                      if len(altdir) && !s:cpath(dir, altdir)
                                        return fugitive#Find(a:object, altdir)
                                      endif
                                      return file
                                    endif
                                  endif
                                  if commit !~# '^[0-9a-f]\{40\}$'
                                    let commit = system(s:Prepare(dir, 'rev-parse', '--verify', commit, '--'))[0:-2]
                                    let commit = v:shell_error ? '' : commit
                                  endif
                                  if len(commit)
                                    let f = 'fugitive://' . dir . '//' . commit . file
                                  else
                                    let f = base . '/' . substitute(rev, '^:/:\=\|^[^:]\+:', '', '')
                                  endif
                                endif
                              endif
  552   0.017870   0.007728   return s:PlatformSlash(f)

FUNCTION  airline#util#strchars()
Called 5 times
Total time:   0.000048
 Self time:   0.000048

count  total (s)   self (s)
    5              0.000025   if exists('*strchars')
    5              0.000018     return strchars(a:str)
                              else
                                return strlen(substitute(a:str, '.', 'a', 'g'))
                              endif

FUNCTION  ale#lsp_linter#HandleLSPResponse()
Called 4 times
Total time:   0.030828
 Self time:   0.000428

count  total (s)   self (s)
    4              0.000037     let l:method = get(a:response, 'method', '')
                            
    4              0.000037     if get(a:response, 'jsonrpc', '') is# '2.0' && has_key(a:response, 'error')
                                    let l:linter_name = get(s:lsp_linter_map, a:conn_id, '')
                            
                                    call s:HandleLSPErrorMessage(l:linter_name, a:response)
                                elseif l:method is# 'textDocument/publishDiagnostics'
                                    call s:HandleLSPDiagnostics(a:conn_id, a:response)
                                elseif get(a:response, 'type', '') is# 'event'&& get(a:response, 'event', '') is# 'semanticDiag'
    1   0.022899   0.000024         call s:HandleTSServerDiagnostics(a:response, 'semantic')
    1              0.000008     elseif get(a:response, 'type', '') is# 'event'&& get(a:response, 'event', '') is# 'syntaxDiag'
    1   0.007565   0.000041         call s:HandleTSServerDiagnostics(a:response, 'syntax')
    1              0.000002     endif

FUNCTION  <SNR>168_WinFindBuf()
Called 2 times
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
    2              0.000034     return exists('*win_findbuf') ? win_findbuf(str2nr(a:buffer)) : [0]

FUNCTION  <SNR>119_CloseCompletionMenu()
Called 443 times
Total time:   0.006498
 Self time:   0.006498

count  total (s)   self (s)
  443              0.002253   if pumvisible()
                                call s:SendKeys( "\<C-e>" )
                              endif

FUNCTION  <SNR>161_syn_name()
Called 2 times
Total time:   0.002219
 Self time:   0.002219

count  total (s)   self (s)
    2              0.002191   let syn_id = get(synstack(a:lnum, a:cnum), -1)
    2              0.000023   return synIDattr(syn_id, "name")

FUNCTION  ale#command#CreateTempFile()
Called 2 times
Total time:   0.000822
 Self time:   0.000345

count  total (s)   self (s)
    2              0.000014     if empty(a:temporary_file)
                                    " There is no file, so we didn't create anything.
    1              0.000002         return 0
                                endif
                            
                                " Use an existing list of lines of input if we have it, or get the lines
                                " from the file.
    1              0.000072     let l:lines = a:input isnot v:null ? a:input : getbufline(a:buffer, 1, '$')
                            
    1              0.000011     let l:temporary_directory = fnamemodify(a:temporary_file, ':h')
                                " Create the temporary directory for the file, unreadable by 'other'
                                " users.
    1              0.000165     call mkdir(l:temporary_directory, '', 0750)
                                " Automatically delete the directory later.
    1   0.000100   0.000030     call ale#command#ManageDirectory(a:buffer, l:temporary_directory)
                                " Write the buffer out to a file.
    1   0.000434   0.000028     call ale#util#Writefile(a:buffer, l:lines, a:temporary_file)
                            
    1              0.000004     return 1

FUNCTION  ale#lsp_linter#GetConfig()
Called 1 time
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
    1              0.000010     if has_key(a:linter, 'lsp_config_callback')
                                    return ale#util#GetFunction(a:linter.lsp_config_callback)(a:buffer)
                                endif
                            
    1              0.000005     if has_key(a:linter, 'lsp_config')
                                    let l:Config = a:linter.lsp_config
                            
                                    if type(l:Config) is v:t_func
                                        let l:Config = l:Config(a:buffer)
                                    endif
                            
                                    return l:Config
                                endif
                            
    1              0.000002     return {}

FUNCTION  ale#cursor#EchoCursorWarning()
Called 2 times
Total time:   0.000995
 Self time:   0.000270

count  total (s)   self (s)
    2              0.000022     let l:buffer = bufnr('')
                            
    2              0.000010     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
                                endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
    2              0.000013     if mode(1) isnot# 'n'
    1              0.000002         return
                                endif
                            
    1   0.000331   0.000020     if ale#ShouldDoNothing(l:buffer)
                                    return
                                endif
                            
    1   0.000522   0.000108     let [l:info, l:loc] = ale#util#FindItemAtCursor(l:buffer)
                            
    1              0.000003     if g:ale_echo_cursor
    1              0.000005         if !empty(l:loc)
                                        let l:format = ale#Var(l:buffer, 'echo_msg_format')
                                        let l:msg = ale#GetLocItemMessage(l:loc, l:format)
                                        call ale#cursor#TruncatedEcho(l:msg)
                                        let l:info.echoed = 1
                                    elseif get(l:info, 'echoed')
                                        " We'll only clear the echoed message when moving off errors once,
                                        " so we don't continually clear the echo line.
                                        execute 'echo'
                                        let l:info.echoed = 0
                                    endif
    1              0.000001     endif
                            
    1              0.000003     if g:ale_cursor_detail
                                    if !empty(l:loc)
                                        call s:ShowCursorDetailForItem(l:loc, {'stay_here': 1})
                                    else
                                        call ale#preview#CloseIfTypeMatches('ale-preview')
                                    endif
                                endif

FUNCTION  <lambda>1()
Called 1 time
Total time:   0.000604
 Self time:   0.000023

count  total (s)   self (s)
    1   0.000602   0.000021 return ale#node#FindExecutable(b, 'typescript_tsserver', [       'node_modules/.bin/tsserver',   ])

FUNCTION  airline#extensions#tabline#builder#new()
Called 1 time
Total time:   0.000090
 Self time:   0.000034

count  total (s)   self (s)
    1   0.000071   0.000015   let builder = airline#builder#new(a:context)
    1              0.000003   let builder._build = builder.build
    1              0.000013   call extend(builder, s:prototype, 'force')
    1              0.000002   return builder

FUNCTION  ale#lsp#tsserver_message#Geterr()
Called 1 time
Total time:   0.000141
 Self time:   0.000141

count  total (s)   self (s)
    1              0.000139     return [1, 'ts@geterr', {'files': [expand('#' . a:buffer . ':p')]}]

FUNCTION  <SNR>155_CheckWithLSP()
Called 1 time
Total time:   0.000850
 Self time:   0.000226

count  total (s)   self (s)
    1              0.000006     let l:buffer = a:details.buffer
    1              0.000015     let l:info = get(g:ale_buffer_info, l:buffer)
                            
    1              0.000005     if empty(l:info)
                                    return
                                endif
                            
    1              0.000005     let l:id = a:details.connection_id
                            
                                " Register a callback now for handling errors now.
    1              0.000010     let l:Callback = function('ale#lsp_linter#HandleLSPResponse')
    1   0.000074   0.000032     call ale#lsp#RegisterCallback(l:id, l:Callback)
                            
                                " Remember the linter this connection is for.
    1              0.000009     let s:lsp_linter_map[l:id] = a:linter.name
                            
    1              0.000005     if a:linter.lsp is# 'tsserver'
    1   0.000172   0.000031         let l:message = ale#lsp#tsserver_message#Geterr(l:buffer)
    1   0.000386   0.000022         let l:notified = ale#lsp#Send(l:id, l:message) != 0
                            
    1              0.000003         if l:notified
    1   0.000107   0.000030             call ale#engine#MarkLinterActive(l:info, a:linter)
    1              0.000001         endif
    1              0.000001     else
                                    let l:notified = ale#lsp#NotifyForChanges(l:id, l:buffer)
                                endif
                            
                                " If this was a file save event, also notify the server of that.
    1              0.000008     if a:linter.lsp isnot# 'tsserver'&& getbufvar(l:buffer, 'ale_save_event_fired', 0)
                                    let l:save_message = ale#lsp#message#DidSave(l:buffer)
                                    let l:notified = ale#lsp#Send(l:id, l:save_message) != 0
                                endif

FUNCTION  airline#statusline()
Called 279 times
Total time:   0.008848
 Self time:   0.008848

count  total (s)   self (s)
  279              0.003497   if has_key(s:contexts, a:winnr)
  279              0.004701     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  ale#path#FindNearestFile()
Called 8 times
Total time:   0.005083
 Self time:   0.005083

count  total (s)   self (s)
    8              0.001096     let l:buffer_filename = fnamemodify(bufname(a:buffer), ':p')
    8              0.000107     let l:buffer_filename = fnameescape(l:buffer_filename)
                            
    8              0.003305     let l:relative_path = findfile(a:filename, l:buffer_filename . ';')
                            
    8              0.000062     if !empty(l:relative_path)
    4              0.000425         return fnamemodify(l:relative_path, ':p')
                                endif
                            
    4              0.000009     return ''

FUNCTION  ale#statusline#FirstProblem()
Called 274 times
Total time:   0.031213
 Self time:   0.010385

count  total (s)   self (s)
  274   0.024891   0.004064     let l:first_problems = s:GetFirstProblems(a:buffer)
                            
  274              0.002406     if !empty(l:first_problems) && has_key(l:first_problems, a:type)
  274              0.003074         return copy(l:first_problems[a:type])
                                endif
                            
                                return {}

FUNCTION  ale#lsp#StartProgram()
Called 1 time
Total time:   0.000195
 Self time:   0.000125

count  total (s)   self (s)
    1              0.000009     let l:conn = s:connections[a:conn_id]
    1              0.000004     let l:started = 0
                            
    1   0.000111   0.000041     if !has_key(l:conn, 'job_id') || !ale#job#HasOpenChannel(l:conn.job_id)
                                    let l:options = {   'mode': 'raw',   'out_cb': {_, message -> ale#lsp#HandleMessage(a:conn_id, message)},}
                            
                                    if has('win32')
                                        let l:job_id = ale#job#StartWithCmd(a:command, l:options)
                                    else
                                        let l:job_id = ale#job#Start(a:command, l:options)
                                    endif
                            
                                    let l:started = 1
                                else
    1              0.000005         let l:job_id = l:conn.job_id
    1              0.000002     endif
                            
    1              0.000003     if l:job_id > 0
    1              0.000005         let l:conn.job_id = l:job_id
    1              0.000001     endif
                            
    1              0.000003     if l:started && !l:conn.is_tsserver
                                    call s:SendInitMessage(l:conn)
                                endif
                            
    1              0.000003     return l:job_id > 0

FUNCTION  ale#lsp#tsserver_message#Change()
Called 1 time
Total time:   0.000330
 Self time:   0.000330

count  total (s)   self (s)
    1              0.000072     let l:lines = getbufline(a:buffer, 1, '$')
                            
                                " We will always use a very high endLine number, so we can delete
                                " lines from files. tsserver will gladly accept line numbers beyond the
                                " end.
    1              0.000252     return [1, 'ts@change', {   'file': expand('#' . a:buffer . ':p'),   'line': 1,   'offset': 1,   'endLine': 1073741824,   'endOffset': 1,   'insertString': join(l:lines, "\n") . "\n",}]

FUNCTION  <SNR>170_CreateCountDict()
Called 2 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
                                " Keys 0 and 1 are for backwards compatibility.
                                " The count object used to be a List of [error_count, warning_count].
    2              0.000027     return {   '0': 0,   '1': 0,   'error': 0,   'warning': 0,   'info': 0,   'style_error': 0,   'style_warning': 0,   'total': 0,}

FUNCTION  ale#lsp#OpenDocument()
Called 1 time
Total time:   0.000071
 Self time:   0.000071

count  total (s)   self (s)
    1              0.000013     let l:conn = get(s:connections, a:conn_id, {})
    1              0.000004     let l:opened = 0
                            
    1              0.000011     if !empty(l:conn) && !has_key(l:conn.open_documents, a:buffer)
                                    if l:conn.is_tsserver
                                        let l:message = ale#lsp#tsserver_message#Open(a:buffer)
                                    else
                                        let l:message = ale#lsp#message#DidOpen(a:buffer, a:language_id)
                                    endif
                            
                                    call ale#lsp#Send(a:conn_id, l:message)
                                    let l:conn.open_documents[a:buffer] = getbufvar(a:buffer, 'changedtick')
                                    let l:opened = 1
                                endif
                            
    1              0.000003     return l:opened

FUNCTION  airline#util#has_lawrencium()
Called 276 times
Total time:   0.002502
 Self time:   0.002502

count  total (s)   self (s)
  276              0.002200   return exists('*lawrencium#statusline')

FUNCTION  airline#highlighter#get_highlight()
Called 480 times
Total time:   0.136311
 Self time:   0.063900

count  total (s)   self (s)
  480              0.017741   let reverse = get(g:, 'airline_gui_mode', '') ==# 'gui' ? synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'gui') : synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')|| synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'term')
  480              0.003712   if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                let res = s:hl_groups[a:group]
                                return reverse ? [ res[1], res[0], res[3], res[2], res[4] ] : res
                              else
  480   0.038417   0.006298     let fg = s:get_syn(a:group, 'fg')
  480   0.037511   0.005958     let bg = s:get_syn(a:group, 'bg')
  480              0.006929     let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
  480              0.001085     if reverse
                                  let res = s:get_array(bg, fg, bold ? ['bold'] : a:000)
                                else
  480   0.015234   0.006495       let res = s:get_array(fg, bg, bold ? ['bold'] : a:000)
  480              0.000712     endif
  480              0.000518   endif
  480              0.003783   let s:hl_groups[a:group] = res
  480              0.001002   return res

FUNCTION  ale#history#Add()
Called 4 times
Total time:   0.000274
 Self time:   0.000274

count  total (s)   self (s)
    4              0.000024     if g:ale_max_buffer_history_size <= 0
                                    " Don't save anything if the history isn't a positive number.
                                    call setbufvar(a:buffer, 'ale_history', [])
                            
                                    return
                                endif
                            
    4              0.000043     let l:history = getbufvar(a:buffer, 'ale_history', [])
                            
                                " Remove the first item if we hit the max history size.
    4              0.000025     if len(l:history) >= g:ale_max_buffer_history_size
                                    let l:history = l:history[1:]
                                endif
                            
    4              0.000057     call add(l:history, {   'status': a:status,   'job_id': a:job_id,   'command': a:command,})
                            
    4              0.000033     call setbufvar(a:buffer, 'ale_history', l:history)

FUNCTION  ale#util#JoinNeovimOutput()
Called 1 time
Total time:   0.032215
 Self time:   0.000055

count  total (s)   self (s)
    1              0.000006     if a:mode is# 'raw'
    1   0.032203   0.000043         call a:callback(a:job, join(a:data, "\n"))
                            
    1              0.000003         return ''
                                endif
                            
                                let l:lines = a:data[:-2]
                            
                                if len(a:data) > 1
                                    let l:lines[0] = a:last_line . l:lines[0]
                                    let l:new_last_line = a:data[-1]
                                else
                                    let l:new_last_line = a:last_line . get(a:data, 0, '')
                                endif
                            
                                for l:line in l:lines
                                    call a:callback(a:job, l:line)
                                endfor
                            
                                return l:new_last_line

FUNCTION  airline#util#shorten()
Called 828 times
Total time:   0.054395
 Self time:   0.034516

count  total (s)   self (s)
  828   0.033711   0.013833   if airline#util#winwidth() < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
                                if get(a:000, 0, 0)
                                  " shorten from tail
                                  return ''.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                else
                                  " shorten from beginning of string
                                  return matchstr(a:text, '^.\{'.a:minwidth.'}').''
                                endif
                              else
  828              0.002286     return a:text
                              endif

FUNCTION  <SNR>119_Pyeval()
Called 933 times
Total time:   1.209851
 Self time:   1.209851

count  total (s)   self (s)
  933              0.003997   if s:using_python3
  933              1.203884     return py3eval( a:eval_string )
                              endif
                              return pyeval( a:eval_string )

FUNCTION  ale#linter#GetExecutable()
Called 5 times
Total time:   0.004418
 Self time:   0.000271

count  total (s)   self (s)
    5              0.000085     let l:Executable = has_key(a:linter, 'executable_callback')   ? function(a:linter.executable_callback)   : a:linter.executable
                            
    5   0.004319   0.000172     return type(l:Executable) is v:t_func   ? l:Executable(a:buffer)   : l:Executable

FUNCTION  <SNR>104_get_array()
Called 480 times
Total time:   0.008739
 Self time:   0.008739

count  total (s)   self (s)
  480              0.003973   let opts=empty(a:opts) ? '' : join(a:opts, ',')
  480              0.004191   return g:airline_gui_mode ==# 'gui' ? [ a:fg, a:bg, '', '', opts ] : [ '', '', a:fg, a:bg, opts ]

FUNCTION  <SNR>95_new_airline_ale_get_line_number()
Called 548 times
Total time:   0.056778
 Self time:   0.025565

count  total (s)   self (s)
                              " The FirstProblem call in ALE is a far more efficient way
                              " of obtaining line number data. If the installed ALE supports
                              " it, we should use this method of getting line data.
  548              0.001877   if a:cnt == 0
  274              0.000573     return ''
                              endif
  274              0.001606   let l:buffer = bufnr('')
                            
                              " Try to get the first error from ALE.
  274   0.035456   0.004243   let l:result = ale#statusline#FirstProblem(l:buffer, a:type)
  274              0.001252   if empty(l:result)
                                " If there are no errors then try and check for style errors.
                                let l:result =  ale#statusline#FirstProblem(l:buffer, 'style_' . a:type)
                              endif
                            
  274              0.001004   if empty(l:result)
                                  return ''
                              endif
                            
  274              0.002377   let l:open_lnum_symbol  = get(g:, 'airline#extensions#ale#open_lnum_symbol', '(L')
  274              0.002409   let l:close_lnum_symbol = get(g:, 'airline#extensions#ale#close_lnum_symbol', ')')
                            
  274              0.002237   return open_lnum_symbol . l:result.lnum . close_lnum_symbol

FUNCTION  airline#highlighter#highlight_modified_inactive()
Called 7 times
Total time:   0.005166
 Self time:   0.000479

count  total (s)   self (s)
    7              0.000056   if getbufvar(a:bufnr, '&modified')
    3              0.000061     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
    3              0.000005   else
    4              0.000070     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
    4              0.000006   endif
                            
    7              0.000027   if !empty(colors)
    7   0.004849   0.000162     call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
    7              0.000009   endif

FUNCTION  ale#job#PrepareCommand()
Called 2 times
Total time:   0.000386
 Self time:   0.000318

count  total (s)   self (s)
    2   0.000106   0.000039     let l:wrapper = ale#Var(a:buffer, 'command_wrapper')
                            
                                " The command will be executed in a subshell. This fixes a number of
                                " issues, including reading the PATH variables correctly, %PATHEXT%
                                " expansion on Windows, etc.
                                "
                                " NeoVim handles this issue automatically if the command is a String,
                                " but we'll do this explicitly, so we use the same exact command for both
                                " versions.
    2              0.000028     let l:command = !empty(l:wrapper) ? s:PrepareWrappedCommand(l:wrapper, a:command) : a:command
                            
                                " If a custom shell is specified, use that.
    2              0.000012     if exists('g:ale_shell')
                                    let l:shell_arguments = get(g:, 'ale_shell_arguments', &shellcmdflag)
                            
                                    return split(g:ale_shell) + split(l:shell_arguments) + [l:command]
                                endif
                            
    2              0.000016     if has('win32')
                                    return 'cmd /s/c "' . l:command . '"'
                                endif
                            
    2              0.000049     if &shell =~? 'fish$\|pwsh$'
                                    return ['/bin/sh', '-c', l:command]
                                endif
                            
    2              0.000094     return split(&shell) + split(&shellcmdflag) + [l:command]

FUNCTION  <SNR>141_LanguageGetter()
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000006     return l:self.language

FUNCTION  ale#util#GetFunction()
Called 6 times
Total time:   0.000117
 Self time:   0.000117

count  total (s)   self (s)
    6              0.000046     if type(a:string_or_ref) is v:t_string
                                    return function(a:string_or_ref)
                                endif
                            
    6              0.000018     return a:string_or_ref

FUNCTION  280()
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000005   call add(self._sections, ['|', a:0 ? a:1 : '%='])

FUNCTION  281()
Called 1 time
Total time:   0.000019
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000005   let spc = empty(a:contents) ? '' : g:airline_symbols.space
    1   0.000013   0.000008   call self.add_section(a:group, spc.a:contents.spc)

FUNCTION  282()
Called 3 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    3              0.000014   call add(self._sections, [a:group, a:contents])

FUNCTION  284()
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000009   call insert(self._sections, [a:group, a:contents], a:position)

FUNCTION  285()
Called 2 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    2              0.000016   call insert(self._sections, ['', a:text], a:position)

FUNCTION  286()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003   return len(self._sections)

FUNCTION  287()
Called 2 times
Total time:   0.009406
 Self time:   0.001780

count  total (s)   self (s)
    2              0.000005   let side = 1
    2              0.000004   let line = ''
    2              0.000004   let i = 0
    2              0.000008   let length = len(self._sections)
    2              0.000004   let split = 0
    2              0.000004   let is_empty = 0
    2              0.000004   let prev_group = ''
                            
   13              0.000032   while i < length
   11              0.000042     let section = self._sections[i]
   11              0.000037     let group = section[0]
   11              0.000033     let contents = section[1]
   11              0.000028     let pgroup = prev_group
   11   0.000430   0.000143     let prev_group = airline#builder#get_prev_group(self._sections, i)
   11              0.000045     if group ==# 'airline_c' && &buftype ==# 'terminal' && self._context.active
                                  let group = 'airline_term'
                                elseif group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let group = 'airline_c'. self._context.bufnr
                                elseif prev_group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let prev_group = 'airline_c'. self._context.bufnr
                                endif
   11              0.000017     if is_empty
                                  let prev_group = pgroup
                                endif
   11   0.000313   0.000130     let is_empty = s:section_is_empty(self, contents)
                            
   11              0.000018     if is_empty
                                  " need to fix highlighting groups, since we
                                  " have skipped a section, we actually need
                                  " the previous previous group and so the
                                  " seperator goes from the previous previous group
                                  " to the current group
                                  let pgroup = group
                                endif
                            
   11              0.000027     if group == ''
    2              0.000008       let line .= contents
    2              0.000003     elseif group == '|'
    2              0.000005       let side = 0
    2              0.000009       let line .= contents
    2              0.000005       let split = 1
    2              0.000003     else
    7              0.000015       if prev_group == ''
    2              0.000013         let line .= '%#'.group.'#'
    2              0.000004       elseif split
    2              0.000003         if !is_empty
    2   0.002244   0.000034           let line .= s:get_transitioned_seperator(self, prev_group, group, side)
    2              0.000002         endif
    2              0.000003         let split = 0
    2              0.000002       else
    3              0.000004         if !is_empty
    3   0.004493   0.000040           let line .= s:get_seperator(self, prev_group, group, side)
    3              0.000003         endif
    3              0.000002       endif
    7   0.000610   0.000116       let line .= is_empty ? '' : s:get_accented_line(self, group, contents)
    7              0.000009     endif
                            
   11              0.000032     let i = i + 1
   11              0.000019   endwhile
                            
    2              0.000006   if !self._context.active
                                "let line = substitute(line, '%#airline_c#', '%#airline_c'.self._context.bufnr.'#', '')
                                let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
                              endif
    2              0.000004   return line

FUNCTION  288()
Called 1 time
Total time:   0.000025
 Self time:   0.000022

count  total (s)   self (s)
    1              0.000003   let self._first_title = a:first " lowest index
    1              0.000002   let self._last_title = a:last " highest index
    1              0.000002   let self._left_title = a:current " next index to add on the left
    1              0.000002   let self._right_title = a:current + 1 " next index to add on the right
    1   0.000012   0.000008   let self._left_position = self.get_position() " left end of titles
    1              0.000002   let self._right_position = self._left_position " right end of the titles

FUNCTION  289()
Called 1 time
Total time:   0.000896
 Self time:   0.000143

count  total (s)   self (s)
    1   0.000273   0.000012   let title = self.get_title(a:index)
    1   0.000458   0.000014   let title_size = s:tabline_evaluated_length(title) + a:sep_size
    1              0.000004   if a:force || self._remaining_space >= title_size
    1              0.000004     let pos = a:pos
    1              0.000006     if has_key(self, "get_pretitle")
    1   0.000058   0.000031       call self.insert_raw(self.get_pretitle(a:index), pos)
    1              0.000003       let self._right_position += 1
    1              0.000003       let pos += 1
    1              0.000001     endif
                            
    1   0.000021   0.000011     call self.insert_section(a:group, title, pos)
    1              0.000004     let self._right_position += 1
    1              0.000003     let pos += 1
                            
    1              0.000005     if has_key(self, "get_posttitle")
    1   0.000033   0.000021       call self.insert_raw(self.get_posttitle(a:index), pos)
    1              0.000003       let self._right_position += 1
    1              0.000003       let pos += 1
    1              0.000002     endif
                            
    1              0.000004     let self._remaining_space -= title_size
    1              0.000002     return 1
                              endif
                              return 0

FUNCTION  <SNR>116_get_separator_change_with_end()
Called 2 times
Total time:   0.000618
 Self time:   0.000097

count  total (s)   self (s)
    2              0.000009   let sep_change = 0
    2              0.000009   if !empty(a:new_end_group) " Separator between title and the end
    1   0.000534   0.000012     let sep_change += airline#builder#should_change_group(a:new_group, a:new_end_group) ? a:sep_size : a:alt_sep_size
    1              0.000002   endif
    2              0.000008   if !empty(a:old_group) " Separator between the title and the one adjacent
                                let sep_change += airline#builder#should_change_group(a:new_group, a:old_group) ? a:sep_size : a:alt_sep_size
                                if !empty(a:old_end_group) " Remove mis-predicted separator
                                  let sep_change -= airline#builder#should_change_group(a:old_group, a:old_end_group) ? a:sep_size : a:alt_sep_size
                                endif
                              endif
    2              0.000005   return sep_change

FUNCTION  <SNR>148_RunLinter()
Called 5 times
Total time:   0.019825
 Self time:   0.000389

count  total (s)   self (s)
    5              0.000036     if !empty(a:linter.lsp)
    1   0.005375   0.000038         return ale#lsp_linter#CheckWithLSP(a:buffer, a:linter)
                                else
    4   0.003873   0.000108         let l:executable = ale#linter#GetExecutable(a:buffer, a:linter)
                            
    4   0.010491   0.000156         return s:RunIfExecutable(a:buffer, a:linter, l:executable)
                                endif
                            
                                return 0

FUNCTION  airline#extensions#hunks#get_hunks()
Called 276 times
Total time:   0.147166
 Self time:   0.067529

count  total (s)   self (s)
  276              0.002142   if !get(w:, 'airline_active', 0)
                                return ''
                              endif
                              " Cache values, so that it isn't called too often
  276   0.008611   0.007419   if exists("b:airline_hunks") && get(b:,  'airline_changenr', 0) == b:changedtick && airline#util#winwidth() == get(s:, 'airline_winwidth', 0) && get(b:, 'source_func', '') isnot# 's:get_hunks_signify' && get(b:, 'source_func', '') isnot# 's:get_hunks_gitgutter' && get(b:, 'source_func', '') isnot# 's:get_hunks_empty' && get(b:, 'source_func', '') isnot# 's:get_hunks_changes'
                                return b:airline_hunks
                              endif
  276   0.055333   0.003845   let hunks = airline#extensions#hunks#get_raw_hunks()
  276              0.001070   let string = ''
  276   0.007307   0.004683   let winwidth = get(airline#parts#get('hunks'), 'minwidth', 100)
  276              0.001294   if !empty(hunks)
 1104              0.003849     for i in [0, 1, 2]
  828   0.030138   0.011993       if (s:non_zero_only == 0 && airline#util#winwidth() > winwidth) || hunks[i] > 0
  828              0.011972         let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
  828              0.001563       endif
  828              0.001365     endfor
  276              0.000374   endif
  276              0.001342   let b:airline_hunks = string
  276              0.001203   let b:airline_changenr = b:changedtick
  276   0.009649   0.003461   let s:airline_winwidth = airline#util#winwidth()
  276              0.000801   return string

FUNCTION  290()
Called 1 time
Total time:   0.011974
 Self time:   0.000382

count  total (s)   self (s)
    1              0.000008   if has_key(self, '_left_position') && self._first_title <= self._last_title
    1   0.004047   0.000041     let self._remaining_space = &columns - s:tabline_evaluated_length(self._build())
                            
    1              0.000005     let center_active = get(g:, 'airline#extensions#tabline#center_active', 0)
                            
    1   0.000113   0.000010     let sep_size = s:tabline_evaluated_length(self._context.left_sep)
    1   0.000133   0.000013     let alt_sep_size = s:tabline_evaluated_length(self._context.left_alt_sep)
                            
    1   0.000024   0.000008     let outer_left_group = airline#builder#get_prev_group(self._sections, self._left_position)
    1   0.000046   0.000017     let outer_right_group = airline#builder#get_next_group(self._sections, self._right_position)
                            
    1              0.000006     let overflow_marker = get(g:, 'airline#extensions#tabline#overflow_marker', g:airline_symbols.ellipsis)
    1   0.000078   0.000007     let overflow_marker_size = s:tabline_evaluated_length(overflow_marker)
                                " Allow space for the markers before we begin filling in titles.
    1              0.000002     if self._left_title > self._first_title
                                  let self._remaining_space -= overflow_marker_size + s:get_separator_change(self.overflow_group, "", outer_left_group, sep_size, alt_sep_size)
                                endif
    1              0.000002     if self._left_title < self._last_title
                                  let self._remaining_space -= overflow_marker_size + s:get_separator_change(self.overflow_group, "", outer_right_group, sep_size, alt_sep_size)
                                endif
                            
                                " Add the current title
    1   0.000123   0.000014     let group = self.get_group(self._left_title)
    1              0.000003     if self._left_title == self._first_title
    1   0.000109   0.000030       let sep_change = s:get_separator_change(group, "", outer_left_group, sep_size, alt_sep_size)
    1              0.000002     else
                                  let sep_change = s:get_separator_change(group, "", self.overflow_group, sep_size, alt_sep_size)
                                endif
    1              0.000003     if self._left_title == self._last_title
    1   0.000602   0.000015       let sep_change += s:get_separator_change(group, "", outer_right_group, sep_size, alt_sep_size)
    1              0.000001     else
                                  let sep_change += s:get_separator_change(group, "", self.overflow_group, sep_size, alt_sep_size)
                                endif
    1              0.000003     let left_group = group
    1              0.000003     let right_group = group
    1   0.000917   0.000021     let self._left_title -= self.try_insert_title(self._left_title, group, self._left_position, sep_change, 1)
                            
    1              0.000005     if get(g:, 'airline#extensions#tabline#current_first', 0)
                                  " always have current title first
                                  let self._left_position += 1
                                endif
                            
    1              0.000004     if !center_active && self._right_title <= self._last_title
                                  " Add the title to the right
                                  let group = self.get_group(self._right_title)
                                  if self._right_title == self._last_title
                                    let sep_change = s:get_separator_change_with_end(group, right_group, outer_right_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
                                  else
                                    let sep_change = s:get_separator_change(group, right_group, self.overflow_group, sep_size, alt_sep_size)
                                  endif
                                  let right_group = group
                                  let self._right_title += self.try_insert_title(self._right_title, group, self._right_position, sep_change, 1)
                                endif
                            
    1              0.000002     while self._remaining_space > 0
    1              0.000002       let done = 0
    1              0.000002       if self._left_title >= self._first_title
                                    " Insert next title to the left
                                    let group = self.get_group(self._left_title)
                                    if self._left_title == self._first_title
                                      let sep_change = s:get_separator_change_with_end(group, left_group, outer_left_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
                                    else
                                      let sep_change = s:get_separator_change(group, left_group, self.overflow_group, sep_size, alt_sep_size)
                                    endif
                                    let left_group = group
                                    let done = self.try_insert_title(self._left_title, group, self._left_position, sep_change, 0)
                                    let self._left_title -= done
                                  endif
                                  " If center_active is set, this |if| operates as an independent |if|,
                                  " otherwise as an |elif|.
    1              0.000002       if self._right_title <= self._last_title && (center_active || !done)
                                    " Insert next title to the right
                                    let group = self.get_group(self._right_title)
                                    if self._right_title == self._last_title
                                      let sep_change = s:get_separator_change_with_end(group, right_group, outer_right_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
                                    else
                                      let sep_change = s:get_separator_change(group, right_group, self.overflow_group, sep_size, alt_sep_size)
                                    endif
                                    let right_group = group
                                    let done = self.try_insert_title(self._right_title, group, self._right_position, sep_change, 0)
                                    let self._right_title += done
                                  endif
    1              0.000001       if !done
    1              0.000001         break
                                  endif
                                endwhile
                            
    1              0.000002     if self._left_title >= self._first_title
                                  if get(g:, 'airline#extensions#tabline#current_first', 0)
                                    let self._left_position -= 1
                                  endif
                                  call self.insert_section(self.overflow_group, overflow_marker, self._left_position)
                                  let self._right_position += 1
                                endif
                            
    1              0.000001     if self._right_title <= self._last_title
                                  call self.insert_section(self.overflow_group, overflow_marker, self._right_position)
                                endif
    1              0.000001   endif
                            
    1   0.005586   0.000008   return self._build()

FUNCTION  ale#command#FormatCommand()
Called 2 times
Total time:   0.001750
 Self time:   0.000691

count  total (s)   self (s)
    2              0.000011     let l:temporary_file = ''
    2              0.000009     let l:command = a:command
                            
                                " First replace all uses of %%, used for literal percent characters,
                                " with an ugly string.
    2              0.000039     let l:command = substitute(l:command, '%%', '<<PERCENTS>>', 'g')
                            
                                " Replace %e with the escaped executable, if available.
    2              0.000027     if !empty(a:executable) && l:command =~# '%e'
    1   0.000077   0.000037         let l:command = substitute(l:command, '%e', '\=ale#Escape(a:executable)', 'g')
    1              0.000002     endif
                            
                                " Replace all %s occurrences in the string with the name of the current
                                " file.
    2              0.000017     if l:command =~# '%s'
    1              0.000153         let l:filename = fnamemodify(bufname(a:buffer), ':p')
    1   0.000075   0.000037         let l:command = substitute(l:command, '%s', '\=ale#Escape(l:filename)', 'g')
    1              0.000002     endif
                            
    2              0.000017     if a:input isnot v:false && l:command =~# '%t'
                                    " Create a temporary filename, <temp_dir>/<original_basename>
                                    " The file itself will not be created by this function.
                                    let l:temporary_file = s:TemporaryFilename(a:buffer)
                                    let l:command = substitute(l:command, '%t', '\=ale#Escape(l:temporary_file)', 'g')
                                endif
                            
                                " Finish formatting so %% becomes %.
    2              0.000033     let l:command = substitute(l:command, '<<PERCENTS>>', '%', 'g')
                            
    2              0.000013     if a:pipe_file_if_needed && empty(l:temporary_file)
                                    " If we are to send the Vim buffer to a command, we'll do it
                                    " in the shell. We'll write out the file to a temporary file,
                                    " and then read it back in, in the shell.
    1   0.000154   0.000032         let l:temporary_file = s:TemporaryFilename(a:buffer)
    1   0.000056   0.000020         let l:command = l:command . ' < ' . ale#Escape(l:temporary_file)
    1              0.000002     endif
                            
    2   0.000931   0.000109     let l:file_created = ale#command#CreateTempFile(   a:buffer,   l:temporary_file,   a:input,)
                            
    2              0.000016     return [l:temporary_file, l:command, l:file_created]

FUNCTION  <SNR>169_highlight_range()
Called 6 times
Total time:   0.000293
 Self time:   0.000205

count  total (s)   self (s)
                                " Set all of the positions, which are chunked into Lists which
                                " are as large as will be accepted by matchaddpos.
    6   0.000272   0.000185     call map(   ale#highlight#CreatePositions(       a:range.lnum,       a:range.col,       a:range.end_lnum,       a:range.end_col   ),   'matchaddpos(a:group, v:val)')

FUNCTION  gitgutter#utility#getbufvar()
Called 276 times
Total time:   0.010143
 Self time:   0.010143

count  total (s)   self (s)
  276              0.002501   let bvars = getbufvar(a:buffer, '')
  276              0.001803   if !empty(bvars)
  276              0.002214     let dict = get(bvars, 'gitgutter', {})
  276              0.001661     if has_key(dict, a:varname)
  276              0.001215       return dict[a:varname]
                                endif
                              endif
                              if a:0
                                return a:1
                              endif

FUNCTION  <SNR>93_update_git_branch()
Called 276 times
Total time:   0.577086
 Self time:   0.016806

count  total (s)   self (s)
  276   0.006122   0.003061   if !airline#util#has_fugitive()
                                let s:vcs_config['git'].branch = ''
                                return
                              endif
                            
  276   0.564071   0.006851   let s:vcs_config['git'].branch = exists("*FugitiveHead") ? FugitiveHead(s:sha1size) : fugitive#head(s:sha1size)
  276              0.002607   if s:vcs_config['git'].branch is# 'master' && airline#util#winwidth() < 81
                                " Shorten default a bit
                                let s:vcs_config['git'].branch='mas'
                              endif

FUNCTION  <SNR>155_StartWithCommand()
Called 1 time
Total time:   0.003698
 Self time:   0.000081

count  total (s)   self (s)
    1   0.000026   0.000015     if ale#command#IsDeferred(a:command)
                                    let a:command.result_callback = {   command -> s:StartWithCommand(a:options, a:executable, command)}
                            
                                    return 1
                                endif
                            
    1              0.000005     if empty(a:command)
                                    return 0
                                endif
                            
    1   0.003647   0.000040     return s:StartLSP(a:options, '', a:executable, a:command)

FUNCTION  ale#sign#GetSignCommands()
Called 2 times
Total time:   0.000650
 Self time:   0.000650

count  total (s)   self (s)
    2              0.000011     let l:command_list = []
    2              0.000010     let l:is_dummy_sign_set = a:was_sign_set
                            
                                " Set the dummy sign if we need to.
                                " The dummy sign is needed to keep the sign column open while we add
                                " and remove signs.
    2              0.000013     if !l:is_dummy_sign_set && (!empty(a:sign_map) || g:ale_sign_column_always)
                                    call add(l:command_list, 'sign place '   .  g:ale_sign_offset   . ' line=1 name=ALEDummySign buffer='   . a:buffer)
                                    let l:is_dummy_sign_set = 1
                                endif
                            
                                " Place new items first.
    7              0.000047     for [l:line_str, l:info] in items(a:sign_map)
    5              0.000016         if l:info.new_id
                                        " Save the sign IDs we are setting back on our loclist objects.
                                        " These IDs will be used to preserve items which are set many times.
   10              0.000030             for l:item in l:info.items
    6              0.000029                 let l:item.sign_id = l:info.new_id
    6              0.000011             endfor
                            
    4              0.000025             if index(l:info.current_id_list, l:info.new_id) < 0
    1              0.000021                 call add(l:command_list, 'sign place '   . (l:info.new_id)   . ' line=' . l:line_str   . ' name=' . (l:info.new_name)   . ' buffer=' . a:buffer)
    1              0.000003             endif
    4              0.000004         endif
    5              0.000006     endfor
                            
                                " Remove signs without new IDs.
    7              0.000030     for l:info in values(a:sign_map)
    9              0.000027         for l:current_id in l:info.current_id_list
    4              0.000014             if l:current_id isnot l:info.new_id
    1              0.000014                 call add(l:command_list, 'sign unplace '   . l:current_id   . ' buffer=' . a:buffer)
    1              0.000002             endif
    4              0.000006         endfor
    5              0.000006     endfor
                            
                                " Remove the dummy sign to close the sign column if we need to.
    2              0.000009     if l:is_dummy_sign_set && !g:ale_sign_column_always
                                    call add(l:command_list, 'sign unplace '   . g:ale_sign_offset   . ' buffer=' . a:buffer)
                                endif
                            
    2              0.000005     return l:command_list

FUNCTION  airline#util#prepend()
Called 1104 times
Total time:   0.018869
 Self time:   0.018869

count  total (s)   self (s)
 1104              0.006902   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
                              endif
 1104              0.006942   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  ale#command#StopJobs()
Called 1 time
Total time:   0.000063
 Self time:   0.000063

count  total (s)   self (s)
    1              0.000012     let l:info = get(s:buffer_data, a:buffer, {})
                            
    1              0.000005     if !empty(l:info)
                                    let l:new_map = {}
                            
                                    for [l:job_id, l:job_type] in items(l:info.jobs)
                                        let l:job_id = str2nr(l:job_id)
                            
                                        if a:job_type is# 'all' || a:job_type is# l:job_type
                                            call ale#job#Stop(l:job_id)
                                        else
                                            let l:new_map[l:job_id] = l:job_type
                                        endif
                                    endfor
                            
                                    let l:info.jobs = l:new_map
                                endif

FUNCTION  ale#sign#SetSigns()
Called 2 times
Total time:   0.022693
 Self time:   0.016548

count  total (s)   self (s)
    2              0.000016     if !bufexists(str2nr(a:buffer))
                                    " Stop immediately when attempting to set signs for a buffer which
                                    " does not exist.
                                    return
                                endif
                            
                                " Find the current markers
    2   0.003062   0.000072     let [l:is_dummy_sign_set, l:current_sign_list] =   ale#sign#FindCurrentSigns(a:buffer)
                            
                                " Update the line numbers for items from before which may have moved.
    2   0.000465   0.000058     call s:UpdateLineNumbers(a:buffer, l:current_sign_list, a:loclist)
                            
                                " Group items after updating the line numbers.
    2   0.000387   0.000058     let l:grouped_items = s:GroupLoclistItems(a:buffer, a:loclist)
                            
                                " Build a map of current and new signs, with the lines as the keys.
    2   0.001830   0.000061     let l:sign_map = s:BuildSignMap(   a:buffer,   l:current_sign_list,   l:grouped_items,)
                            
    2   0.000709   0.000060     let l:command_list = ale#sign#GetSignCommands(   a:buffer,   l:is_dummy_sign_set,   l:sign_map,)
                            
                                " Change the sign column color if the option is on.
    2              0.000012     if g:ale_change_sign_column_color && !empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithErrors
                                endif
                            
    4              0.000022     for l:command in l:command_list
    2              0.016078         silent! execute l:command
    2              0.000017     endfor
                            
                                " Reset the sign column color when there are no more errors.
    2              0.000014     if g:ale_change_sign_column_color && empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithoutErrors
                                endif

FUNCTION  ale#cursor#EchoCursorWarningWithDelay()
Called 1 time
Total time:   0.000192
 Self time:   0.000139

count  total (s)   self (s)
    1              0.000011     let l:buffer = bufnr('')
                            
    1              0.000005     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
                                endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
    1              0.000006     if mode(1) isnot# 'n'
                                    return
                                endif
                            
    1   0.000054   0.000035     call s:StopCursorTimer()
                            
    1              0.000014     let l:pos = getpos('.')[0:2]
                            
                                " Check the current buffer, line, and column number against the last
                                " recorded position. If the position has actually changed, *then*
                                " we should echo something. Otherwise we can end up doing processing
                                " the echo message far too frequently.
    1              0.000005     if l:pos != s:last_pos
    1   0.000052   0.000018         let l:delay = ale#Var(l:buffer, 'echo_delay')
                            
    1              0.000006         let s:last_pos = l:pos
    1              0.000015         let s:cursor_timer = timer_start(   l:delay,   function('ale#cursor#EchoCursorWarning'))
    1              0.000002     endif

FUNCTION  nerdtree#runningWindows()
Called 6 times
Total time:   0.000111
 Self time:   0.000111

count  total (s)   self (s)
    6              0.000104     return has("win16") || has("win32") || has("win64")

FUNCTION  <lambda>3()
Called 1 time
Total time:   0.032160
 Self time:   0.000090

count  total (s)   self (s)
    1   0.032158   0.000089 return ale#lsp#HandleMessage(a:conn_id, message)

FUNCTION  ale#sign#ReadSigns()
Called 2 times
Total time:   0.000257
 Self time:   0.000257

count  total (s)   self (s)
    2              0.000013     redir => l:output
    2              0.000179         silent execute 'sign place buffer=' . a:buffer
    2              0.000016     redir end
                            
    2              0.000044     return split(l:output, "\n")

FUNCTION  <SNR>17_Tree()
Called 552 times
Total time:   0.018463
 Self time:   0.018463

count  total (s)   self (s)
  552              0.003118   let dir = a:path
  552              0.009228   if dir =~# '/\.git$'
  552              0.005045     return len(dir) ==# 5 ? '/' : dir[0:-6]
                              elseif dir ==# ''
                                return ''
                              endif
                              if !has_key(s:worktree_for_dir, dir)
                                let s:worktree_for_dir[dir] = ''
                                let config_file = dir . '/config'
                                if filereadable(config_file)
                                  let config = readfile(config_file,'',10)
                                  call filter(config,'v:val =~# "^\\s*worktree *="')
                                  if len(config) == 1
                                    let worktree = matchstr(config[0], '= *\zs.*')
                                  endif
                                elseif filereadable(dir . '/gitdir')
                                  let worktree = fnamemodify(readfile(dir . '/gitdir')[0], ':h')
                                  if worktree ==# '.'
                                    unlet! worktree
                                  endif
                                endif
                                if exists('worktree')
                                  let s:worktree_for_dir[dir] = worktree
                                  let s:dir_for_worktree[s:worktree_for_dir[dir]] = dir
                                endif
                              endif
                              if s:worktree_for_dir[dir] =~# '^\.'
                                return simplify(dir . '/' . s:worktree_for_dir[dir])
                              else
                                return s:worktree_for_dir[dir]
                              endif

FUNCTION  ale#job#Start()
Called 1 time
Total time:   0.004228
 Self time:   0.004212

count  total (s)   self (s)
    1   0.000053   0.000037     call ale#job#ValidateArguments(a:command, a:options)
                            
    1              0.000009     let l:job_info = copy(a:options)
    1              0.000004     let l:job_options = {}
                            
    1              0.000006     if has('nvim')
    1              0.000005         if has_key(a:options, 'out_cb')
    1              0.000013             let l:job_options.on_stdout = function('s:NeoVimCallback')
    1              0.000005             let l:job_info.out_cb_line = ''
    1              0.000002         endif
                            
    1              0.000006         if has_key(a:options, 'err_cb')
                                        let l:job_options.on_stderr = function('s:NeoVimCallback')
                                        let l:job_info.err_cb_line = ''
                                    endif
                            
    1              0.000005         if has_key(a:options, 'exit_cb')
    1              0.000013             let l:job_options.on_exit = function('s:NeoVimCallback')
    1              0.000002         endif
                            
    1              0.003907         let l:job_info.job = jobstart(a:command, l:job_options)
    1              0.000016         let l:job_id = l:job_info.job
    1              0.000003     else
                                    let l:job_options = {   'in_mode': l:job_info.mode,   'out_mode': l:job_info.mode,   'err_mode': l:job_info.mode,}
                            
                                    if has_key(a:options, 'out_cb')
                                        let l:job_options.out_cb = function('s:VimOutputCallback')
                                    endif
                            
                                    if has_key(a:options, 'err_cb')
                                        let l:job_options.err_cb = function('s:VimErrorCallback')
                                    endif
                            
                                    if has_key(a:options, 'exit_cb')
                                        " Set a close callback to which simply calls job_status()
                                        " when the channel is closed, which can trigger the exit callback
                                        " earlier on.
                                        let l:job_options.close_cb = function('s:VimCloseCallback')
                                        let l:job_options.exit_cb = function('s:VimExitCallback')
                                    endif
                            
                                    " Use non-blocking writes for Vim versions that support the option.
                                    if has('patch-8.1.350')
                                        let l:job_options.noblock = 1
                                    endif
                            
                                    " Vim 8 will read the stdin from the file's buffer.
                                    let l:job_info.job = job_start(a:command, l:job_options)
                                    let l:job_id = ale#job#ParseVim8ProcessID(string(l:job_info.job))
                                endif
                            
    1              0.000004     if l:job_id > 0
                                    " Store the job in the map for later only if we can get the ID.
    1              0.000016         let s:job_map[l:job_id] = l:job_info
    1              0.000002     endif
                            
    1              0.000004     return l:job_id

FUNCTION  <SNR>119_OnTextChangedInsertMode()
Called 272 times
Total time:   6.483634
 Self time:   0.647704

count  total (s)   self (s)
  272   0.042129   0.003797   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
  272              0.000784   if s:completion_stopped
                                let s:completion_stopped = 0
                                let s:completion = s:default_completion
                                return
                              endif
                            
  272   0.449267   0.004034   call s:IdentifierFinishedOperations()
                            
                              " We have to make sure we correctly leave semantic mode even when the user
                              " inserts something like a "operator[]" candidate string which fails
                              " CurrentIdentifierFinished check.
  272              0.003292   if s:force_semantic && !s:Pyeval( 'base.LastEnteredCharIsIdentifierChar()' )
                                let s:force_semantic = 0
                              endif
                            
  272   0.422551   0.011796   if &completefunc == "youcompleteme#CompleteFunc" && ( g:ycm_auto_trigger || s:force_semantic ) && !s:InsideCommentOrStringAndShouldStop() && !s:OnBlankLine()
                                " Immediately call previous completion to avoid flickers.
  270   0.022799   0.006021     call s:Complete()
  270   4.928375   0.003544     call s:InvokeCompletion()
  270              0.000641   endif
                            
  272              0.597339   exec s:python_command "ycm_state.OnCursorMoved()"
                            
  272              0.002743   if g:ycm_autoclose_preview_window_after_completion
                                call s:ClosePreviewWindowIfNeeded()
                              endif

FUNCTION  airline#extensions#ale#get_warning()
Called 276 times
Total time:   0.127459
 Self time:   0.005498

count  total (s)   self (s)
  276   0.127138   0.005177   return airline#extensions#ale#get('warning')

FUNCTION  airline#extensions#tabline#add_tab_label()
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000006   if get(g:, 'airline#extensions#tabline#show_tab_count', 1) && tabpagenr('$') > 1
                                call a:dict.add_section_spaced('airline_tabmod', printf('%s %d/%d', "tab", tabpagenr(), tabpagenr('$')))
                              endif

FUNCTION  airline#builder#new()
Called 1 time
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
    1              0.000019   let builder = copy(s:prototype)
    1              0.000005   let builder._context = a:context
    1              0.000004   let builder._sections = []
                            
    1              0.000023   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
    1              0.000003   return builder

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
  272   6.483634   0.647704  <SNR>119_OnTextChangedInsertMode()
 1481   6.240716             provider#python3#Call()
  270   4.924831   4.465333  <SNR>119_InvokeCompletion()
  933   1.209851             <SNR>119_Pyeval()
  276   0.800298   0.024332  airline#extensions#branch#get_head()
  276   0.755713   0.017626  airline#extensions#branch#head()
  276   0.643771   0.032461  <SNR>93_update_branch()
  276   0.577086   0.016806  <SNR>93_update_git_branch()
  320   0.569569   0.022974  <SNR>119_PollCompletion()
  276   0.557219   0.011285  FugitiveHead()
  276   0.542382   0.069201  fugitive#Head()
  552   0.473181   0.319462  fugitive#Find()
  272   0.445233   0.019751  <SNR>119_IdentifierFinishedOperations()
  279   0.326307   0.078667  airline#check_mode()
  552   0.264653   0.099335  airline#extensions#ale#get()
  272   0.243970   0.004381  <SNR>119_OnBlankLine()
    7   0.240809   0.033365  airline#highlighter#highlight()
  272   0.166785   0.011777  <SNR>119_InsideCommentOrStringAndShouldStop()
  272   0.155007             <SNR>119_InsideCommentOrString()
  276   0.147903   0.005212  airline#extensions#ale#get_error()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
 1481              6.240716  provider#python3#Call()
  270   4.924831   4.465333  <SNR>119_InvokeCompletion()
  933              1.209851  <SNR>119_Pyeval()
  272   6.483634   0.647704  <SNR>119_OnTextChangedInsertMode()
  552   0.473181   0.319462  fugitive#Find()
  272              0.155007  <SNR>119_InsideCommentOrString()
  546              0.120428  <SNR>74_Highlight_Matching_Pair()
  552   0.264653   0.099335  airline#extensions#ale#get()
  276   0.094316   0.085620  <SNR>93_update_untracked()
  279   0.326307   0.078667  airline#check_mode()
  276   0.094874   0.077043  airline#extensions#whitespace#check()
  276   0.542382   0.069201  fugitive#Head()
  276   0.147166   0.067529  airline#extensions#hunks#get_hunks()
  276   0.068642   0.065808  airline#extensions#fugitiveline#bufname()
  480   0.136311   0.063900  airline#highlighter#get_highlight()
 2815              0.063816  airline#util#winwidth()
  960              0.063671  <SNR>104_get_syn()
  551   0.068975   0.062340  <SNR>119_AllowedToCompleteInBuffer()
 1932              0.049511  airline#util#append()
  548   0.062188   0.040683  <SNR>170_GetCounts()

