FUNCTION  <SNR>171_syn_attr_jsx()
Called 2 times
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    2              0.000022   return a:synattr =~? "^jsx"

FUNCTION  <SNR>146_GetLinterNames()
Called 9 times
Total time:   0.000681
 Self time:   0.000681

count  total (s)   self (s)
    9              0.000084     let l:buffer_ale_linters = get(b:, 'ale_linters', {})
                            
                                " b:ale_linters can be set to 'all'
    9              0.000033     if l:buffer_ale_linters is# 'all'
                                    return 'all'
                                endif
                            
                                " b:ale_linters can be set to a List.
    9              0.000045     if type(l:buffer_ale_linters) is v:t_list
                                    return l:buffer_ale_linters
                                endif
                            
                                " Try to get a buffer-local setting for the filetype
    9              0.000050     if has_key(l:buffer_ale_linters, a:original_filetype)
                                    return l:buffer_ale_linters[a:original_filetype]
                                endif
                            
                                " Try to get a global setting for the filetype
    9              0.000049     if has_key(g:ale_linters, a:original_filetype)
                                    return g:ale_linters[a:original_filetype]
                                endif
                            
                                " If the user has configured ALE to only enable linters explicitly, then
                                " don't enable any linters by default.
    9              0.000024     if g:ale_linters_explicit
                                    return []
                                endif
                            
                                " Try to get a default setting for the filetype
    9              0.000053     if has_key(s:default_ale_linters, a:original_filetype)
                                    return s:default_ale_linters[a:original_filetype]
                                endif
                            
    9              0.000017     return 'all'

FUNCTION  <SNR>123_DisableOnLargeFile()
Called 252 times
Total time:   0.002981
 Self time:   0.002981

count  total (s)   self (s)
  252              0.001753   if exists( 'b:ycm_largefile' )
  252              0.000786     return b:ycm_largefile
                              endif
                            
                              let threshold = g:ycm_disable_for_files_larger_than_kb * 1024
                              let b:ycm_largefile = threshold > 0 && getfsize( expand( a:buffer ) ) > threshold
                              if b:ycm_largefile
                                exec s:python_command "vimsupport.PostVimMessage(" . "'YouCompleteMe is disabled in this buffer; " . "the file exceeded the max size (see YCM options).' )"
                              endif
                              return b:ycm_largefile

FUNCTION  <SNR>99_airline_ale_get_line_number()
Called 56 times
Total time:   0.005915
 Self time:   0.001247

count  total (s)   self (s)
                              " Use the new ALE statusline API function if it is available.
   56              0.000383   if exists("*ale#statusline#FirstProblem")
   56   0.005409   0.000741     return s:new_airline_ale_get_line_number(a:cnt, a:type)
                              endif
                            
                              return s:legacy_airline_ale_get_line_number(a:cnt, a:type)

FUNCTION  ale#sign#SetSigns()
Called 20 times
Total time:   0.059854
 Self time:   0.005789

count  total (s)   self (s)
   20              0.000169     if !bufexists(str2nr(a:buffer))
                                    " Stop immediately when attempting to set signs for a buffer which
                                    " does not exist.
                                    return
                                endif
                            
                                " Find the current markers
   20   0.025363   0.000492     let [l:is_dummy_sign_set, l:current_sign_list] =   ale#sign#FindCurrentSigns(a:buffer)
                            
                                " Update the line numbers for items from before which may have moved.
   20   0.004541   0.000454     call s:UpdateLineNumbers(a:buffer, l:current_sign_list, a:loclist)
                            
                                " Group items after updating the line numbers.
   20   0.003710   0.000328     let l:grouped_items = s:GroupLoclistItems(a:buffer, a:loclist)
                            
                                " Build a map of current and new signs, with the lines as the keys.
   20   0.016679   0.000407     let l:sign_map = s:BuildSignMap(   a:buffer,   l:current_sign_list,   l:grouped_items,)
                            
   20   0.005844   0.000391     let l:command_list = ale#sign#GetSignCommands(   a:buffer,   l:is_dummy_sign_set,   l:sign_map,)
                            
                                " Change the sign column color if the option is on.
   20              0.000104     if g:ale_change_sign_column_color && !empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithErrors
                                endif
                            
   22              0.000080     for l:command in l:command_list
    2              0.001957         silent! execute l:command
    2              0.000006     endfor
                            
                                " Reset the sign column color when there are no more errors.
   20              0.000097     if g:ale_change_sign_column_color && empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithoutErrors
                                endif

FUNCTION  ale#job#IsRunning()
Called 9 times
Total time:   0.000299
 Self time:   0.000299

count  total (s)   self (s)
    9              0.000090     if has('nvim')
    9              0.000025         try
                                        " In NeoVim, if the job isn't running, jobpid() will throw.
    9              0.000058             call jobpid(a:job_id)
                            
    9              0.000022             return 1
                                    catch
                                    endtry
                                elseif has_key(s:job_map, a:job_id)
                                    let l:job = s:job_map[a:job_id].job
                            
                                    return job_status(l:job) is# 'run'
                                endif
                            
                                return 0

FUNCTION  ale#lsp#RegisterCallback()
Called 9 times
Total time:   0.000344
 Self time:   0.000344

count  total (s)   self (s)
    9              0.000089     let l:conn = get(s:connections, a:conn_id, {})
                            
    9              0.000039     if !empty(l:conn)
                                    " Add the callback to the List if it's not there already.
    9              0.000162         call uniq(sort(add(l:conn.callback_list, a:callback)))
    9              0.000015     endif

FUNCTION  delimitMate#GetCurrentSyntaxRegion()
Called 3 times
Total time:   0.000367
 Self time:   0.000097

count  total (s)   self (s)
    3              0.000019 	let col = col('.')
    3              0.000015 	if  col == col('$')
    1              0.000003 		let col = col - 1
    1              0.000001 	endif
    3   0.000317   0.000047 	return delimitMate#GetSyntaxRegion(line('.'), col)

FUNCTION  <SNR>97_update_hg_branch()
Called 102 times
Total time:   0.011844
 Self time:   0.011038

count  total (s)   self (s)
  102   0.001764   0.000958   if airline#util#has_lawrencium()
                                let cmd='LC_ALL=C hg qtop'
                                let stl=lawrencium#statusline()
                                let file=expand('%:p')
                                if !empty(stl) && get(b:, 'airline_do_mq_check', 1)
                                  if g:airline#init#vim_async
                                    noa call airline#async#get_mq_async(cmd, file)
                                  elseif has("nvim")
                                    noa call airline#async#nvim_get_mq_async(cmd, file)
                                  else
                                    " remove \n at the end of the command
                                    let output=system(cmd)[0:-2]
                                    noa call airline#async#mq_output(output, file)
                                  endif
                                endif
                                " do not do mq check anymore
                                let b:airline_do_mq_check = 0
                                if exists("b:mq") && !empty(b:mq)
                                  if stl is# 'default'
                                    " Shorten default a bit
                                    let stl='def'
                                  endif
                                  let stl.=' ['.b:mq.']'
                                endif
                                let s:vcs_config['mercurial'].branch = stl
                              else
  102              0.000564     let s:vcs_config['mercurial'].branch = ''
  102              0.000136   endif

FUNCTION  <SNR>123_InsideCommentOrStringAndShouldStop()
Called 85 times
Total time:   0.040957
 Self time:   0.003254

count  total (s)   self (s)
   85   0.038941   0.001237   let retval = s:InsideCommentOrString()
   85              0.000389   let inside_comment = retval == 1
   85              0.000383   let inside_string = retval == 2
                            
   85              0.000446   if inside_comment && g:ycm_complete_in_comments || inside_string && g:ycm_complete_in_strings
                                return 0
                              endif
                            
   85              0.000162   return retval

FUNCTION  <SNR>135_IsStyledDefinition()
Called 1 time
Total time:   0.000199
 Self time:   0.000063

count  total (s)   self (s)
                              " iterate through all syntax items in the given line
    3   0.000165   0.000029   for item in s:SynSOL(a:lnum)
                                " if syntax-item is a jsTemplateString return 1 - true
                                " `==#` is a match case comparison of the item
    2              0.000008     if item ==# 'styledDefinition'
                                  return 1
                                endif
    2              0.000002   endfor
                            
                              " fallback to 0 - false
    1              0.000002   return 0

FUNCTION  ale#linter#Get()
Called 9 times
Total time:   0.006355
 Self time:   0.003377

count  total (s)   self (s)
    9              0.000046     let l:possibly_duplicated_linters = []
                            
                                " Handle dot-separated filetypes.
   18              0.000197     for l:original_filetype in split(a:original_filetypes, '\.')
    9   0.001442   0.000159         let l:filetype = ale#linter#ResolveFiletype(l:original_filetype)
    9   0.000840   0.000159         let l:linter_names = s:GetLinterNames(l:original_filetype)
    9   0.001216   0.000201         let l:all_linters = ale#linter#GetAll(l:filetype)
    9              0.000036         let l:filetype_linters = []
                            
    9              0.000073         if type(l:linter_names) is v:t_string && l:linter_names is# 'all'
    9              0.000042             let l:filetype_linters = l:all_linters
    9              0.000040         elseif type(l:linter_names) is v:t_list
                                        " Select only the linters we or the user has specified.
                                        for l:linter in l:all_linters
                                            let l:name_list = [l:linter.name] + l:linter.aliases
                            
                                            for l:name in l:name_list
                                                if index(l:linter_names, l:name) >= 0
                                                    call add(l:filetype_linters, l:linter)
                                                    break
                                                endif
                                            endfor
                                        endfor
                                    endif
                            
    9              0.000068         call extend(l:possibly_duplicated_linters, l:filetype_linters)
    9              0.000015     endfor
                            
    9              0.000038     let l:name_list = []
    9              0.000032     let l:combined_linters = []
                            
                                " Make sure we override linters so we don't get two with the same name,
                                " like 'eslint' for both 'javascript' and 'typescript'
                                "
                                " Note that the reverse calls here modify the List variables.
   54              0.000171     for l:linter in reverse(l:possibly_duplicated_linters)
   45              0.000281         if index(l:name_list, l:linter.name) < 0
   45              0.000262             call add(l:name_list, l:linter.name)
   45              0.000227             call add(l:combined_linters, l:linter)
   45              0.000064         endif
   45              0.000052     endfor
                            
    9              0.000044     return reverse(l:combined_linters)

FUNCTION  <SNR>134_sw()
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000005 	return shiftwidth()

FUNCTION  <SNR>134_save_pos()
Called 1 time
Total time:   0.000288
 Self time:   0.000049

count  total (s)   self (s)
    1              0.000013   let l:pos = getpos('.')[1:2]
    1   0.000263   0.000024   let ret = call(a:f,a:000)
    1              0.000007   call call('cursor',l:pos)
    1              0.000003   return ret

FUNCTION  <SNR>135_SynSOL()
Called 1 time
Total time:   0.000136
 Self time:   0.000021

count  total (s)   self (s)
    1   0.000135   0.000021   return s:GetSyntaxNames(a:lnum, 1)

FUNCTION  <SNR>122_PlatformSlash()
Called 204 times
Total time:   0.003277
 Self time:   0.003277

count  total (s)   self (s)
  204              0.001297   if exists('+shellslash') && !&shellslash
                                return tr(a:path, '/', '\')
                              else
  204              0.000623     return a:path
                              endif

FUNCTION  ale#highlight#CreatePositions()
Called 87 times
Total time:   0.001451
 Self time:   0.001451

count  total (s)   self (s)
   87              0.000628     if a:line >= a:end_line
                                    " For single lines, just return the one position.
   87              0.000628         return [[[a:line, a:col, a:end_col - a:col + 1]]]
                                endif
                            
                                " Get positions from the first line at the first column, up to a large
                                " integer for highlighting up to the end of the line, followed by
                                " the lines in-between, for highlighting entire lines, and
                                " a highlight for the last line, up to the end column.
                                let l:all_positions =   [[a:line, a:col, s:MAX_COL_SIZE]]   + range(a:line + 1, a:end_line - 1)   + [[a:end_line, 1, a:end_col]]
                            
                                return map(   range(0, len(l:all_positions) - 1, s:MAX_POS_VALUES),   'l:all_positions[v:val : v:val + s:MAX_POS_VALUES - 1]',)

FUNCTION  GetJsxIndent()
Called 1 time
Total time:   0.003154
 Self time:   0.000034

count  total (s)   self (s)
    1   0.003153   0.000033   return jsx_pretty#indent#get(function('GetTypescriptIndent'))

FUNCTION  airline#check_mode()
Called 110 times
Total time:   0.461161
 Self time:   0.029790

count  total (s)   self (s)
  110              0.000856   if !has_key(s:contexts, a:winnr)
                                return ''
                              endif
  110              0.001093   let context = s:contexts[a:winnr]
                            
  110              0.000769   if get(w:, 'airline_active', 1)
  102              0.000645     let l:m = mode(1)
  102              0.000430     if l:m ==# "i"
   81              0.000333       let l:mode = ['insert']
   81              0.000220     elseif l:m[0] ==# "i"
                                  let l:mode = ['insert']
                                elseif l:m ==# "Rv"
                                  let l:mode =['replace']
                                elseif l:m[0] ==# "R"
                                  let l:mode = ['replace']
                                elseif l:m[0] =~# '\v(v|V||s|S|)'
                                  let l:mode = ['visual']
                                elseif l:m ==# "t"
                                  let l:mode = ['terminal']
                                elseif l:m[0] ==# "c"
    2              0.000009       let l:mode = ['commandline']
    2              0.000004     elseif l:m ==# "no"   " does not work, most likely, Vim does not refresh the statusline in OP mode
                                  let l:mode = ['normal']
                                elseif l:m[0:1] ==# 'ni'
                                  let l:mode = ['normal']
                                  let l:m = 'ni'
                                else
   19              0.000089       let l:mode = ['normal']
   19              0.000029     endif
  102              0.001068     if exists("*VMInfos") && !empty(VMInfos())
                                  " Vim plugin Multiple Cursors https://github.com/mg979/vim-visual-multi
                                  let l:m = 'multi'
                                endif
  102              0.001288     if index(['Rv', 'no', 'ni', 'ix', 'ic', 'multi'], l:m) == -1
  102              0.000544       let l:m = l:m[0]
  102              0.000144     endif
  102              0.001017     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
  102              0.000158   else
    8              0.000037     let l:mode = ['inactive']
    8              0.000070     let w:airline_current_mode = get(g:airline_mode_map, '__')
    8              0.000012   endif
                            
  110              0.000680   if g:airline_detect_modified && &modified
  102              0.000655     call add(l:mode, 'modified')
  102              0.000141   endif
                            
  110              0.000448   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
                              endif
                            
  110              0.001324   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
                              endif
                            
  110              0.000449   if g:airline_detect_spell && &spell
                                call add(l:mode, 'spell')
                              endif
                            
  110              0.000299   if &readonly || ! &modifiable
    8              0.000052     call add(l:mode, 'readonly')
    8              0.000011   endif
                            
  110              0.001026   let mode_string = join(l:mode)
  110              0.001183   if get(w:, 'airline_lastmode', '') != mode_string
    8   0.007753   0.000175     call airline#highlighter#highlight_modified_inactive(context.bufnr)
    8   0.422363   0.000372     call airline#highlighter#highlight(l:mode, context.bufnr)
    8   0.001943   0.000141     call airline#util#doautocmd('AirlineModeChanged')
    8              0.000057     let w:airline_lastmode = mode_string
    8              0.000013   endif
                            
  110              0.000222   return ''

FUNCTION  airline#util#append()
Called 714 times
Total time:   0.016918
 Self time:   0.016918

count  total (s)   self (s)
  714              0.003808   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
                              endif
  714              0.004953   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
  714              0.004580   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  <SNR>171_syn_eol()
Called 2 times
Total time:   0.000183
 Self time:   0.000183

count  total (s)   self (s)
    2              0.000013   let lnum = prevnonblank(a:lnum)
    2              0.000013   let col = strlen(getline(lnum))
    2              0.000152   return map(synstack(lnum, col), 'synIDattr(v:val, "name")')

FUNCTION  <SNR>160_StartLSP()
Called 9 times
Total time:   0.025442
 Self time:   0.002323

count  total (s)   self (s)
    9              0.000046     let l:buffer = a:options.buffer
    9              0.000036     let l:linter = a:options.linter
    9              0.000034     let l:root = a:options.root
    9              0.000065     let l:Callback = a:options.callback
                            
    9   0.000528   0.000163     let l:init_options = ale#lsp_linter#GetOptions(l:buffer, l:linter)
                            
    9              0.000036     if l:linter.lsp is# 'socket'
                                    let l:conn_id = ale#lsp#Register(a:address, l:root, l:init_options)
                                    let l:ready = ale#lsp#ConnectToAddress(l:conn_id, a:address)
                                    let l:command = ''
                                else
    9   0.000549   0.000170         let l:conn_id = ale#lsp#Register(a:executable, l:root, l:init_options)
                            
                                    " tsserver behaves differently, so tell the LSP API that it is tsserver.
    9              0.000038         if l:linter.lsp is# 'tsserver'
    9   0.000613   0.000151             call ale#lsp#MarkConnectionAsTsserver(l:conn_id)
    9              0.000013         endif
                            
    9   0.002746   0.000392         let l:command = ale#command#FormatCommand(l:buffer, a:executable, a:command, 0, v:false)[1]
    9   0.001630   0.000130         let l:command = ale#job#PrepareCommand(l:buffer, l:command)
    9   0.001570   0.000195         let l:ready = ale#lsp#StartProgram(l:conn_id, a:executable, l:command)
    9              0.000013     endif
                            
    9              0.000019     if !l:ready
                                    if g:ale_history_enabled && !empty(a:command)
                                        call ale#history#Add(l:buffer, 'failed', l:conn_id, a:command)
                                    endif
                            
                                    return 0
                                endif
                            
    9              0.000106     let l:details = {   'buffer': l:buffer,   'connection_id': l:conn_id,   'command': l:command,   'project_root': l:root,}
                            
    9   0.017014   0.000330     call ale#lsp#OnInit(l:conn_id, {->   ale#lsp_linter#OnInit(l:linter, l:details, l:Callback)})
                            
    9              0.000019     return 1

FUNCTION  <SNR>173_BuildSignMap()
Called 20 times
Total time:   0.016272
 Self time:   0.008502

count  total (s)   self (s)
   20   0.000863   0.000322     let l:max_signs = ale#Var(a:buffer, 'max_signs')
                            
   20              0.000064     if l:max_signs is 0
                                    let l:selected_grouped_items = []
                                elseif type(l:max_signs) is v:t_number && l:max_signs > 0
                                    let l:selected_grouped_items = a:grouped_items[:l:max_signs - 1]
                                else
   20              0.000083         let l:selected_grouped_items = a:grouped_items
   20              0.000026     endif
                            
   20              0.000064     let l:sign_map = {}
   20              0.000087     let l:sign_offset = g:ale_sign_offset
                            
   57              0.000244     for [l:line, l:sign_id, l:name] in a:current_sign_list
   37              0.000562         let l:sign_info = get(l:sign_map, l:line, {   'current_id_list': [],   'current_name_list': [],   'new_id': 0,   'new_name': '',   'items': [],})
                            
                                    " Increment the sign offset for new signs, by the maximum sign ID.
   37              0.000134         if l:sign_id > l:sign_offset
   37              0.000124             let l:sign_offset = l:sign_id
   37              0.000052         endif
                            
                                    " Remember the sign names and IDs in separate Lists, so they are easy
                                    " to work with.
   37              0.000231         call add(l:sign_info.current_id_list, l:sign_id)
   37              0.000196         call add(l:sign_info.current_name_list, l:name)
                            
   37              0.001026         let l:sign_map[l:line] = l:sign_info
   37              0.000089     endfor
                            
   57              0.000169     for l:group in l:selected_grouped_items
   37              0.000156         let l:line = l:group[0].lnum
   37              0.000673         let l:sign_info = get(l:sign_map, l:line, {   'current_id_list': [],   'current_name_list': [],   'new_id': 0,   'new_name': '',   'items': [],})
                            
   37   0.007754   0.000524         let l:sign_info.new_name = ale#sign#GetSignName(l:group)
   37              0.000156         let l:sign_info.items = l:group
                            
   37              0.000289         let l:index = index(   l:sign_info.current_name_list,   l:sign_info.new_name)
                            
   37              0.000105         if l:index >= 0
                                        " We have a sign with this name already, so use the same ID.
   36              0.000184             let l:sign_info.new_id = l:sign_info.current_id_list[l:index]
   36              0.000056         else
                                        " This sign name replaces the previous name, so use a new ID.
    1              0.000002             let l:sign_info.new_id = l:sign_offset + 1
    1              0.000002             let l:sign_offset += 1
    1              0.000001         endif
                            
   37              0.000214         let l:sign_map[l:line] = l:sign_info
   37              0.000064     endfor
                            
   20              0.000052     return l:sign_map

FUNCTION  ale#lsp#UpdateConfig()
Called 9 times
Total time:   0.000176
 Self time:   0.000176

count  total (s)   self (s)
    9              0.000079     let l:conn = get(s:connections, a:conn_id, {})
                            
    9              0.000055     if empty(l:conn) || a:config ==# l:conn.config " no-custom-checks
    9              0.000019         return 0
                                endif
                            
                                let l:conn.config = a:config
                                let l:message = ale#lsp#message#DidChangeConfiguration(a:buffer, a:config)
                            
                                call ale#lsp#Send(a:conn_id, l:message)
                            
                                return 1

FUNCTION  airline#extensions#branch#update_untracked_config()
Called 102 times
Total time:   0.003020
 Self time:   0.003020

count  total (s)   self (s)
  102              0.000869   if !has_key(s:vcs_config[a:vcs].untracked, a:file)
                                return
                              elseif s:vcs_config[a:vcs].untracked[a:file] != b:buffer_vcs_config[a:vcs].untracked
                                let b:buffer_vcs_config[a:vcs].untracked = s:vcs_config[a:vcs].untracked[a:file]
                                unlet! b:airline_head
                              endif

FUNCTION  ale#util#JoinNeovimOutput()
Called 20 times
Total time:   0.171963
 Self time:   0.001319

count  total (s)   self (s)
   20              0.000088     if a:mode is# 'raw'
    9   0.170969   0.000350         call a:callback(a:job, join(a:data, "\n"))
                            
    9              0.000023         return ''
                                endif
                            
   11              0.000064     let l:lines = a:data[:-2]
                            
   11              0.000051     if len(a:data) > 1
    2              0.000021         let l:lines[0] = a:last_line . l:lines[0]
    2              0.000012         let l:new_last_line = a:data[-1]
    2              0.000004     else
    9              0.000078         let l:new_last_line = a:last_line . get(a:data, 0, '')
    9              0.000013     endif
                            
   13              0.000058     for l:line in l:lines
    2   0.000077   0.000053         call a:callback(a:job, l:line)
    2              0.000005     endfor
                            
   11              0.000035     return l:new_last_line

FUNCTION  <SNR>123_OnTextChangedNormalMode()
Called 5 times
Total time:   0.010839
 Self time:   0.000145

count  total (s)   self (s)
    5   0.000817   0.000056   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
    5   0.009996   0.000063   call s:OnFileReadyToParse()

FUNCTION  ale#lsp_linter#OnInit()
Called 9 times
Total time:   0.016005
 Self time:   0.001348

count  total (s)   self (s)
    9              0.000045     let l:buffer = a:details.buffer
    9              0.000044     let l:conn_id = a:details.connection_id
    9              0.000033     let l:command = a:details.command
                            
    9   0.000490   0.000133     let l:config = ale#lsp_linter#GetConfig(l:buffer, a:linter)
    9   0.000456   0.000268     let l:language_id = ale#util#GetFunction(a:linter.language_callback)(l:buffer)
                            
    9   0.000289   0.000113     call ale#lsp#UpdateConfig(l:conn_id, l:buffer, l:config)
                            
    9   0.000688   0.000120     if ale#lsp#OpenDocument(l:conn_id, l:buffer, l:language_id)
                                    if g:ale_history_enabled && !empty(l:command)
                                        call ale#history#Add(l:buffer, 'started', l:conn_id, l:command)
                                    endif
                                endif
                            
                                " The change message needs to be sent for tsserver before doing anything.
    9              0.000036     if a:linter.lsp is# 'tsserver'
    9   0.007744   0.000179         call ale#lsp#NotifyForChanges(l:conn_id, l:buffer)
    9              0.000015     endif
                            
    9   0.005984   0.000180     call a:Callback(a:linter, a:details)

FUNCTION  ale#highlight#RemoveHighlights()
Called 20 times
Total time:   0.004139
 Self time:   0.004139

count  total (s)   self (s)
  107              0.000872     for l:match in getmatches()
   87              0.002134         if l:match.group =~? '\v^ALE(Style)?(Error|Warning|Info)(Line)?$'
   87              0.000589             call matchdelete(l:match.id)
   87              0.000134         endif
   87              0.000110     endfor

FUNCTION  FugitiveWorkTree()
Called 204 times
Total time:   0.024280
 Self time:   0.004738

count  total (s)   self (s)
  204   0.024069   0.004527   return s:Tree(FugitiveGitDir(a:0 ? a:1 : -1))

FUNCTION  <SNR>123_InvokeCompletion()
Called 84 times
Total time:   1.534175
 Self time:   1.350511

count  total (s)   self (s)
   84              1.347643   exec s:python_command "ycm_state.SendCompletionRequest(" . "vimsupport.GetBoolValue( 's:force_semantic' ) )"
                            
   84   0.185917   0.002253   call s:PollCompletion()

FUNCTION  <SNR>154_TemporaryFilename()
Called 9 times
Total time:   0.000959
 Self time:   0.000537

count  total (s)   self (s)
    9              0.000092     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
    9              0.000040     if empty(l:filename)
                                    " If the buffer's filename is empty, create a dummy filename.
                                    let l:ft = getbufvar(a:buffer, '&filetype')
                                    let l:filename = 'file' . ale#filetypes#GuessExtension(l:ft)
                                endif
                            
                                " Create a temporary filename, <temp_dir>/<original_basename>
                                " The file itself will not be created by this function.
    9   0.000675   0.000254     return ale#util#Tempname() . (has('win32') ? '\' : '/') . l:filename

FUNCTION  <SNR>155_HandleESLintOutput()
Called 2 times
Total time:   0.003036
 Self time:   0.000394

count  total (s)   self (s)
    2   0.001885   0.000053     if s:CheckForBadConfig(a:buffer, a:lines)
                                    return [{   'lnum': 1,   'text': 'eslint configuration error (type :ALEDetail for more information)',   'detail': join(a:lines, "\n"),}]
                                endif
                            
    2              0.000012     if a:lines == ['Could not connect']
                                    return [{   'lnum': 1,   'text': 'Could not connect to eslint_d. Try updating eslint_d or killing it.',}]
                                endif
                            
    2              0.000008     if a:type is# 'json'
    2   0.000577   0.000070         let l:output = s:parseJSON(a:buffer, a:lines)
    2              0.000003     else
                                    let l:output = s:parseLines(a:buffer, a:lines)
                                endif
                            
    2   0.000266   0.000081     call filter(l:output, {idx, obj -> s:FilterResult(a:buffer, obj)})
                            
    2              0.000048     if expand('#' . a:buffer . ':t') =~? '\.tsx\?$'
    2   0.000169   0.000051         call s:AddHintsForTypeScriptParsingErrors(l:output)
    2              0.000003     endif
                            
    2              0.000006     return l:output

FUNCTION  ale#command#CreateTempFile()
Called 18 times
Total time:   0.007056
 Self time:   0.002801

count  total (s)   self (s)
   18              0.000115     if empty(a:temporary_file)
                                    " There is no file, so we didn't create anything.
    9              0.000022         return 0
                                endif
                            
                                " Use an existing list of lines of input if we have it, or get the lines
                                " from the file.
    9              0.000542     let l:lines = a:input isnot v:null ? a:input : getbufline(a:buffer, 1, '$')
                            
    9              0.000088     let l:temporary_directory = fnamemodify(a:temporary_file, ':h')
                                " Create the temporary directory for the file, unreadable by 'other'
                                " users.
    9              0.001501     call mkdir(l:temporary_directory, '', 0750)
                                " Automatically delete the directory later.
    9   0.000570   0.000165     call ale#command#ManageDirectory(a:buffer, l:temporary_directory)
                                " Write the buffer out to a file.
    9   0.004011   0.000161     call ale#util#Writefile(a:buffer, l:lines, a:temporary_file)
                            
    9              0.000035     return 1

FUNCTION  ale#sign#FindCurrentSigns()
Called 20 times
Total time:   0.024871
 Self time:   0.000680

count  total (s)   self (s)
   20   0.002571   0.000294     let l:line_list = ale#sign#ReadSigns(a:buffer)
                            
   20   0.022254   0.000340     return ale#sign#ParseSigns(l:line_list)

FUNCTION  airline#extensions#fugitiveline#bufname()
Called 102 times
Total time:   0.023395
 Self time:   0.022468

count  total (s)   self (s)
  102              0.000786   if !exists('b:fugitive_name')
                                let b:fugitive_name = ''
                                try
                                  if bufname('%') =~? '^fugitive:' && exists('*FugitiveReal')
                                    let b:fugitive_name = FugitiveReal(bufname('%'))
                                  elseif exists('b:git_dir') && exists('*fugitive#repo')
                                    if get(b:, 'fugitive_type', '') is# 'blob'
                                      let b:fugitive_name = fugitive#repo().translate(FugitivePath(@%, ''))
                                    endif
                                  elseif exists('b:git_dir') && !exists('*fugitive#repo')
                                    let buffer = fugitive#buffer()
                                    if buffer.type('blob')
                                      let b:fugitive_name = buffer.repo().translate(buffer.path('/'))
                                    endif
                                  endif
                                catch
                                endtry
                              endif
                            
  102   0.002241   0.001314   let fmod = s:ModifierFlags()
  102              0.000536   if empty(b:fugitive_name)
  102              0.013898     return fnamemodify(bufname('%'), fmod)
                              else
                                return fnamemodify(b:fugitive_name, fmod). " [git]"
                              endif

FUNCTION  GetStyledIndent()
Called 1 time
Total time:   0.003668
 Self time:   0.000202

count  total (s)   self (s)
    1   0.000229   0.000030   if s:IsStyledDefinition(v:lnum)
                                let l:baseIndent = 0
                            
                                " find last non-styled line
                                let l:cnum = v:lnum
                                while s:IsStyledDefinition(l:cnum)
                                  let l:cnum -= 1
                                endwhile
                            
                                " get indentation of the last non-styled line as base indentation
                                let l:baseIndent = indent(l:cnum)
                            
                                " incrementally build indentation based on current indentation
                                " - one shiftwidth for the styled definition region
                                " - one shiftwidth per open nested definition region
                                let l:styledIndent = &sw
                                let l:styledIndent += min([ s:CountOccurencesInSOL(v:lnum, 'styledNestedRegion'), s:CountOccurencesInEOL(v:lnum, 'styledNestedRegion', 0) ]) * &sw
                            
                                " decrease indentation by one shiftwidth, if the styled definition
                                " region ends on the current line
                                " - either directly via styled definition region, or
                                " - if the very last
                                if s:CountOccurencesInEOL(v:lnum, 'styledDefinition', 1) == 0
                                  let l:styledIndent -= &sw
                                endif
                            
                                " return the base indentation
                                " (for nested styles inside classes/objects/etc.) plus the actual
                                " indentation inside the styled definition region
                                return l:baseIndent + l:styledIndent
                              elseif len(b:js_ts_indent)
    1              0.000003     let l:result = 0
    1              0.000002     let l:offset = 0
                            
                                " increase indentation by one shiftwidth, if the last line ended on a
                                " styledXmlRegion and this line does not continue with it
                                " this is a fix for an incorrectly indented xml prop after a
                                " glamor-styled styledXmlRegion
    1   0.000144   0.000030     if s:CountOccurencesInEOL(v:lnum-1, 'styledXmlRegion', 0) == 1 && s:CountOccurencesInSOL(v:lnum, 'styledXmlRegion') == 0
                                  let l:offset = &sw
                                endif
                            
                                " make sure `GetStyledIndent` and `GetJsxIndent` don't infinitely
                                " recurse by incrementing a counter variable, before evaluating the
                                " stored indent expression
    1              0.000003     if s:is_recursion == 0
    1              0.000003       let s:is_recursion = 1
    1   0.003172   0.000018       let l:result = eval(b:js_ts_indent)
    1              0.000001     endif
                            
                                " `is_recursion` being 0 at this point indicates, that
                                " `eval(b:js_ts_indent)` did itself evaluate it's stored indentexpr
                                " and thus it can be assumed, that the current line should be
                                " indented as JS
    1              0.000003     if s:is_recursion == 0
                                  " use one of `GetJavascriptIndent` or `GetJsIndent` if existing
                                  " fallback to cindent, if not
                                  if exists('*GetJavascriptIndent')
                                    let l:result = GetJavascriptIndent()
                                  elseif exists('*GetJsIndent')
                                    let l:result = GetJsIndent()
                                  else
                                    let l:result = cindent(v:lnum)
                                  endif
                                endif
                            
                                " reset `is_recursion` counter and return the indentation value
    1              0.000003     let s:is_recursion = 0
    1              0.000003     return l:result + l:offset
                              endif
                            
                              " if all else fails indent according to C-syntax
                              return cindent(v:lnum)

FUNCTION  <SNR>135_SynEOL()
Called 1 time
Total time:   0.000057
 Self time:   0.000030

count  total (s)   self (s)
    1              0.000009   let l:lnum = prevnonblank(a:lnum)
    1              0.000007   let l:col = strlen(getline(l:lnum))
                            
    1   0.000039   0.000012   return s:GetSyntaxNames(l:lnum, l:col + a:offset)

FUNCTION  <SNR>155_AddHintsForTypeScriptParsingErrors()
Called 2 times
Total time:   0.000118
 Self time:   0.000118

count  total (s)   self (s)
    4              0.000017     for l:item in a:output
    2              0.000073         let l:item.text = substitute(   l:item.text,   '^\(Parsing error\)',   '\1 (You may need configure typescript-eslint-parser)',   '',)
    2              0.000005     endfor

FUNCTION  ale#statusline#Count()
Called 56 times
Total time:   0.004438
 Self time:   0.000894

count  total (s)   self (s)
                                " The Dictionary is copied here before exposing it to other plugins.
   56   0.004334   0.000789     return copy(s:GetCounts(a:buffer))

FUNCTION  <SNR>162_CreateTSServerMessageData()
Called 18 times
Total time:   0.002190
 Self time:   0.002190

count  total (s)   self (s)
   18              0.000107     let l:is_notification = a:message[0]
                            
   18              0.000177     let l:obj = {   'seq': v:null,   'type': 'request',   'command': a:message[1][3:],}
                            
   18              0.000050     if !l:is_notification
                                    let l:obj.seq = ale#lsp#GetNextMessageID()
                                endif
                            
   18              0.000103     if len(a:message) > 2
   18              0.000123         let l:obj.arguments = a:message[2]
   18              0.000029     endif
                            
   18              0.001228     let l:data = json_encode(l:obj) . "\n"
                            
   18              0.000134     return [l:is_notification ? 0 : l:obj.seq, l:data]

FUNCTION  ale#sign#GetSignName()
Called 37 times
Total time:   0.007229
 Self time:   0.003550

count  total (s)   self (s)
   37              0.000191     let l:priority = g:ale#util#style_warning_priority
                            
                                " Determine the highest priority item for the line.
  124              0.000345     for l:item in a:sublist
   87   0.004749   0.001070         let l:item_priority = ale#util#GetItemPriority(l:item)
                            
   87              0.000286         if l:item_priority > l:priority
   37              0.000128             let l:priority = l:item_priority
   37              0.000049         endif
   87              0.000119     endfor
                            
   37              0.000119     if l:priority is# g:ale#util#error_priority
   37              0.000087         return 'ALEErrorSign'
                                endif
                            
                                if l:priority is# g:ale#util#warning_priority
                                    return 'ALEWarningSign'
                                endif
                            
                                if l:priority is# g:ale#util#style_error_priority
                                    return 'ALEStyleErrorSign'
                                endif
                            
                                if l:priority is# g:ale#util#style_warning_priority
                                    return 'ALEStyleWarningSign'
                                endif
                            
                                if l:priority is# g:ale#util#info_priority
                                    return 'ALEInfoSign'
                                endif
                            
                                " Use the error sign for invalid severities.
                                return 'ALEErrorSign'

FUNCTION  <SNR>145_ApplyPartialTimer()
Called 20 times
Total time:   0.033385
 Self time:   0.001222

count  total (s)   self (s)
   20              0.000389     if has_key(s:partial_timers, a:timer_id)
   20              0.000313         let [l:Callback, l:args] = remove(s:partial_timers, a:timer_id)
   20   0.032609   0.000447         call call(l:Callback, [a:timer_id] + l:args)
   20              0.000028     endif

FUNCTION  airline#extensions#tabline#buffers#get()
Called 15 times
Total time:   0.006551
 Self time:   0.000861

count  total (s)   self (s)
   15              0.000043   try
   15   0.005956   0.000266     call <sid>map_keys()
   15              0.000029   catch
                                " no-op
                              endtry
   15              0.000111   let cur = bufnr('%')
   15              0.000107   if cur == s:current_bufnr && &columns == s:column_width
   15              0.000145     if !g:airline_detect_modified || getbufvar(cur, '&modified') == s:current_modified
   15              0.000062       return s:current_tabline
                                endif
                              endif
                            
                              let b = airline#extensions#tabline#new_builder()
                              let tab_bufs = tabpagebuflist(tabpagenr())
                              let show_buf_label_first = 0
                            
                              if get(g:, 'airline#extensions#tabline#buf_label_first', 0)
                                let show_buf_label_first = 1
                              endif
                              if show_buf_label_first
                                call airline#extensions#tabline#add_label(b, 'buffers', 0)
                              endif
                            
                              let b.tab_bufs = tabpagebuflist(tabpagenr())
                            
                              let b.overflow_group = 'airline_tabhid'
                              let b.buffers = airline#extensions#tabline#buflist#list()
                              if get(g:, 'airline#extensions#tabline#current_first', 0)
                                if index(b.buffers, cur) > -1
                                  call remove(b.buffers, index(b.buffers, cur))
                                endif
                                let b.buffers = [cur] + b.buffers
                              endif
                            
                              function! b.get_group(i) dict
                                let bufnum = get(self.buffers, a:i, -1)
                                if bufnum == -1
                                  return ''
                                endif
                                let group = airline#extensions#tabline#group_of_bufnr(self.tab_bufs, bufnum)
                                if bufnum == bufnr('%')
                                  let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
                                endif
                                return group
                              endfunction
                            
                              if has("tablineat")
                                function! b.get_pretitle(i) dict
                                  let bufnum = get(self.buffers, a:i, -1)
                                  return '%'.bufnum.'@airline#extensions#tabline#buffers#clickbuf@'
                                endfunction
                            
                                function! b.get_posttitle(i) dict
                                  return '%X'
                                endfunction
                              endif
                            
                              function! b.get_title(i) dict
                                let bufnum = get(self.buffers, a:i, -1)
                                let group = self.get_group(a:i)
                                let pgroup = self.get_group(a:i - 1)
                                " always add a space when powerline_fonts are used
                                " or for the very first item
                                if get(g:, 'airline_powerline_fonts', 0) || a:i == 0
                                  let space = s:spc
                                else
                                  let space= (pgroup == group ? s:spc : '')
                                endif
                            
                                if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
                                  if len(s:number_map) > 0
                                    return space. s:get_number(a:i) . '%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)' . s:spc
                                  else
                                    return '['.(a:i+1).s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.']'
                                  endif
                                else
                                  return space.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.s:spc
                                endif
                              endfunction
                            
                              let current_buffer = max([index(b.buffers, cur), 0])
                              let last_buffer = len(b.buffers) - 1
                              call b.insert_titles(current_buffer, 0, last_buffer)
                            
                              call b.add_section('airline_tabfill', '')
                              call b.split()
                              call b.add_section('airline_tabfill', '')
                              if !show_buf_label_first
                                call airline#extensions#tabline#add_label(b, 'buffers', 1)
                              endif
                            
                              call airline#extensions#tabline#add_tab_label(b)
                            
                              let s:current_bufnr = cur
                              let s:column_width = &columns
                              let s:current_tabline = b.build()
                              let s:current_visible_buffers = copy(b.buffers)
                              " Do not remove from s:current_visible_buffers, this breaks s:select_tab()
                              "if b._right_title <= last_buffer
                              "  call remove(s:current_visible_buffers, b._right_title, last_buffer)
                              "endif
                              "if b._left_title > 0
                              "  call remove(s:current_visible_buffers, 0, b._left_title)
                              "endif
                              return s:current_tabline

FUNCTION  <SNR>123_OnCursorMovedNormalMode()
Called 10 times
Total time:   0.026044
 Self time:   0.024707

count  total (s)   self (s)
   10   0.001456   0.000119   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
   10              0.024528   exec s:python_command "ycm_state.OnCursorMoved()"

FUNCTION  <SNR>171_syn_jsx_escapejs()
Called 2 times
Total time:   0.000133
 Self time:   0.000133

count  total (s)   self (s)
    2              0.000130   return get(a:syns, -1) =~? '\(\(js\(Template\)\?\|javaScript\(Embed\)\?\|typescript\)Braces\|javascriptTemplateSB\|typescriptInterpolationDelimiter\)' && (get(a:syns, -2) =~? 'jsxEscapeJs' || get(a:syns, -3) =~? 'jsxEscapeJs')

FUNCTION  <SNR>123_AllowedToCompleteInBuffer()
Called 252 times
Total time:   0.033055
 Self time:   0.030074

count  total (s)   self (s)
  252              0.003514   let buftype = getbufvar( a:buffer, '&buftype' )
                            
  252              0.001752   if has_key( s:buftype_blacklist, buftype )
                                return 0
                              endif
                            
  252              0.002266   let filetype = getbufvar( a:buffer, '&filetype' )
                            
  252   0.008305   0.005324   if empty( filetype ) || s:DisableOnLargeFile( a:buffer )
                                return 0
                              endif
                            
  252              0.004311   let whitelist_allows = type( g:ycm_filetype_whitelist ) != type( {} ) || has_key( g:ycm_filetype_whitelist, '*' ) || has_key( g:ycm_filetype_whitelist, filetype )
  252              0.003353   let blacklist_allows = type( g:ycm_filetype_blacklist ) != type( {} ) || !has_key( g:ycm_filetype_blacklist, filetype )
                            
  252              0.001223   let allowed = whitelist_allows && blacklist_allows
  252              0.000580   if allowed
  252              0.001999     let s:previous_allowed_buffer_number = bufnr( a:buffer )
  252              0.000412   endif
  252              0.000661   return allowed

FUNCTION  airline#util#has_fugitive()
Called 102 times
Total time:   0.000926
 Self time:   0.000926

count  total (s)   self (s)
  102              0.000823   return exists('*fugitive#head') || exists('*FugitiveHead')

FUNCTION  fugitive#Head()
Called 102 times
Total time:   0.180723
 Self time:   0.024646

count  total (s)   self (s)
  102              0.000781   let dir = a:0 > 1 ? a:2 : s:Dir()
  102   0.086147   0.007833   if empty(dir) || !filereadable(fugitive#Find('.git/HEAD', dir))
                                return ''
                              endif
  102   0.088133   0.010369   let head = readfile(fugitive#Find('.git/HEAD', dir))[0]
  102              0.001596   if head =~# '^ref: '
  102              0.003278     return substitute(head, '\C^ref: \%(refs/\%(heads/\|remotes/\|tags/\)\=\)\=', '', '')
                              elseif head =~# '^\x\{40\}$'
                                let len = a:0 ? a:1 : 0
                                return len < 0 ? head : len ? head[0:len-1] : ''
                              else
                                return ''
                              endif

FUNCTION  ale#util#GetLineCount()
Called 20 times
Total time:   0.002067
 Self time:   0.002067

count  total (s)   self (s)
   20              0.002044     return len(getbufline(a:buffer, 1, '$'))

FUNCTION  jsx_pretty#indent#get()
Called 1 time
Total time:   0.003120
 Self time:   0.000595

count  total (s)   self (s)
    1              0.000004   let lnum = v:lnum
    1              0.000028   let line = substitute(getline(lnum), '^\s*\|\s*$', '', 'g')
    1   0.000132   0.000020   let current_syn = s:syn_sol(lnum)
    1   0.000151   0.000026   let current_syn_eol = s:syn_eol(lnum)
    1   0.000143   0.000022   let prev_syn_sol = s:syn_sol(lnum - 1)
    1   0.000078   0.000021   let prev_syn_eol = s:syn_eol(lnum - 1)
    1   0.000062   0.000028   let prev_line = s:prev_line(lnum)
    1   0.000034   0.000022   let prev_ind = s:prev_indent(lnum)
                            
    1   0.000092   0.000017   if s:syn_xmlish(current_syn)
                            
                                " {
                                "   <div></div>
                                " ##} <--
                                if s:syn_jsx_element(current_syn) && line =~ '}$'
                                  let pair_line = searchpair('{', '', '}', 'b')
                                  return indent(pair_line)
                                elseif line =~ '^-->$'
                                  if prev_line =~ '^<!--'
                                    return prev_ind
                                  else
                                    return prev_ind - s:sw()
                                  endif
                                elseif prev_line =~ '-->$'
                                  return prev_ind
                                " close tag </tag> or /> including </>
                                elseif prev_line =~ s:end_tag . '$'
                                  if line =~ '^<\s*' . s:end_tag
                                    return prev_ind - s:sw()
                                  elseif s:syn_jsx_attrib(prev_syn_sol)
                                    return prev_ind - s:sw()
                                  else
                                    return prev_ind
                                  endif
                                elseif line =~ '^\(>\|/\s*>\)'
                                  if prev_line =~ '^<'
                                    return prev_ind
                                  else
                                    return prev_ind - s:sw()
                                  endif
                                elseif prev_line =~ '^\(<\|>\)' && (s:syn_xmlish(prev_syn_eol) || s:syn_js_comment(prev_syn_eol))
                                  if line =~ '^<\s*' . s:end_tag
                                    return prev_ind
                                  else
                                    return prev_ind + s:sw()
                                  endif
                                elseif line =~ '^<\s*' . s:end_tag
                                  if !s:syn_xmlish(prev_syn_sol) 
                                    if s:syn_jsx_escapejs(prev_syn_eol) || s:syn_jsx_escapejs(prev_syn_sol)
                                      return prev_ind - s:sw()
                                    else
                                      return prev_ind
                                    endif
                                  elseif prev_line =~ '^\<return'
                                    return prev_ind
                                  else
                                    return prev_ind - s:sw()
                                  endif
                                elseif !s:syn_xmlish(prev_syn_eol)
                                  if prev_line =~ '\(&&\|||\|=>\|[([{]\|`\)$'
                                    " <div>
                                    "   {
                                    "   }
                                    " </div>
                                    if line =~ '^[)\]}]'
                                      return prev_ind
                                    else
                                      return prev_ind + s:sw()
                                    endif
                                  else
                                    return prev_ind
                                  endif
                                elseif !s:syn_xmlish(prev_syn_sol)
                                  if prev_line =~ '^\<\(return\|default\|await\|yield\)'
                                    if line !~ '^/\s*>' || line !~ '^<\s*' . s:end_tag
                                      return prev_ind + s:sw()
                                    else
                                      return prev_ind
                                    endif
                                  else
                                    return prev_ind
                                  endif
                                else
                                  return prev_ind
                                endif
                              elseif s:syn_jsx_escapejs(current_syn)
                                if line =~ '^}'
                                  let char = getline('.')[col('.') - 1]
                                  " When pressing enter after the }, keep the indent
                                  if char != '}' && search('}', 'b', lnum)
                                    return indent(lnum)
                                  else
                                    let pair_line = searchpair('{', '', '}', 'bW')
                                    return indent(pair_line)
                                  endif
                                elseif line =~ '^{' || line =~ '^\${'
                                  if s:syn_jsx_escapejs(prev_syn_eol) || s:syn_jsx_attrib(prev_syn_sol)
                                    return prev_ind
                                  elseif s:syn_xmlish(prev_syn_eol) && (prev_line =~ s:end_tag || prev_line =~ '-->$')
                                    return prev_ind
                                  else
                                    return prev_ind + s:sw()
                                  endif
                                endif
                              elseif s:syn_jsx_escapejs(current_syn_eol)
                                let pair_line = searchpair('{', '', '}', 'bW')
                                return indent(pair_line)
                              elseif line =~ '^/[/*]' " js comment in jsx tag
                                if get(prev_syn_sol, -1) =~ 'Punct'
                                  return prev_ind + s:sw()
                                elseif synIDattr(synID(lnum - 1, 1, 1), 'name') =~ 'jsxTag'
                                  return prev_ind
                                else
                                  return a:js_indent()
                                endif
                              else
    1   0.001853   0.000020     let ind = a:js_indent()
                            
                                " Issue #68
                                " return (<div>
                                " |<div>)
    1              0.000009     if prev_line =~ '^\<return' && line =~ '^<\s*' . s:end_tag
                                  return prev_ind
                                endif 
                            
                                " If current syntax is not a jsx syntax group
    1   0.000033   0.000011     if s:syn_xmlish(prev_syn_eol) && line !~ '^[)\]}]'
                                  let sol = matchstr(line, s:opfirst)
                                  if sol is ''
                                    " Fix javascript continue indent
                                    return ind - s:sw()
                                  else
                                    return ind
                                  endif
                                endif
    1              0.000002     return ind
                              endif
                            

FUNCTION  ale#lsp#HandleMessage()
Called 9 times
Total time:   0.169832
 Self time:   0.002658

count  total (s)   self (s)
    9              0.000100     let l:conn = get(s:connections, a:conn_id, {})
                            
    9              0.000038     if empty(l:conn)
                                    return
                                endif
                            
    9              0.000056     if type(a:message) isnot v:t_string
                                    " Ignore messages that aren't strings.
                                    return
                                endif
                            
    9              0.000067     let l:conn.data .= a:message
                            
                                " Parse the objects now if we can, and keep the remaining text.
    9   0.007592   0.000244     let [l:conn.data, l:response_list] = ale#lsp#ReadMessageData(l:conn.data)
                            
                                " Look for initialize responses first.
    9              0.000036     if !l:conn.initialized
                                    for l:response in l:response_list
                                        call ale#lsp#HandleInitResponse(l:conn, l:response)
                                    endfor
                                endif
                            
                                " If the connection is marked as initialized, call the callbacks with the
                                " responses.
    9              0.000026     if l:conn.initialized
   45              0.000137         for l:response in l:response_list
                                        " Call all of the registered handlers with the response.
   72              0.000265             for l:Callback in l:conn.callback_list
   36   0.160656   0.000831                 call ale#util#GetFunction(l:Callback)(a:conn_id, l:response)
   36              0.000068             endfor
   36              0.000055         endfor
    9              0.000011     endif

FUNCTION  <SNR>108_hl_group_exists()
Called 304 times
Total time:   0.010258
 Self time:   0.010258

count  total (s)   self (s)
  304              0.003377   if !hlexists(a:group)
                                return 0
                              elseif empty(synIDattr(hlID(a:group), 'fg'))
                                return 0
                              endif
  304              0.000417   return 1

FUNCTION  <SNR>174_FixList()
Called 20 times
Total time:   0.020678
 Self time:   0.005915

count  total (s)   self (s)
   20   0.000887   0.000275     let l:format = ale#Var(a:buffer, 'loclist_msg_format')
   20              0.000081     let l:new_list = []
                            
  108              0.000326     for l:item in a:list
   88              0.000956         let l:fixed_item = copy(l:item)
                            
   88   0.015780   0.001629         let l:fixed_item.text = ale#GetLocItemMessage(l:item, l:format)
                            
   88              0.000381         if l:item.bufnr == -1
                                        " If the buffer number is invalid, remove it.
                                        call remove(l:fixed_item, 'bufnr')
                                    endif
                            
   88              0.000552         call add(l:new_list, l:fixed_item)
   88              0.000161     endfor
                            
   20              0.000079     return l:new_list

FUNCTION  ale#job#HasOpenChannel()
Called 9 times
Total time:   0.000522
 Self time:   0.000222

count  total (s)   self (s)
    9   0.000427   0.000128     if ale#job#IsRunning(a:job_id)
    9              0.000050         if has('nvim')
                                        " TODO: Implement a check for NeoVim.
    9              0.000017             return 1
                                    endif
                            
                                    " Check if the Job's channel can be written to.
                                    return ch_status(s:job_map[a:job_id].job) is# 'open'
                                endif
                            
                                return 0

FUNCTION  ale#lsp#response#ReadTSServerDiagnostics()
Called 18 times
Total time:   0.004113
 Self time:   0.004113

count  total (s)   self (s)
   18              0.000076     let l:loclist = []
                            
   50              0.000173     for l:diagnostic in a:response.body.diagnostics
   32              0.000522         let l:loclist_item = {   'text': l:diagnostic.text,   'type': 'E',   'lnum': l:diagnostic.start.line,   'col': l:diagnostic.start.offset,   'end_lnum': l:diagnostic.end.line,   'end_col': l:diagnostic.end.offset - 1,}
                            
   32              0.000161         if has_key(l:diagnostic, 'code')
   32              0.000157             if type(l:diagnostic.code) == v:t_string
                                            let l:loclist_item.code = l:diagnostic.code
                                        elseif type(l:diagnostic.code) == v:t_number && l:diagnostic.code != -1
   32              0.000305                 let l:loclist_item.code = string(l:diagnostic.code)
   32              0.000149                 let l:loclist_item.nr = l:diagnostic.code
   32              0.000046             endif
   32              0.000053         endif
                            
   32              0.000181         if get(l:diagnostic, 'category') is# 'warning'
                                        let l:loclist_item.type = 'W'
                                    endif
                            
   32              0.000164         if get(l:diagnostic, 'category') is# 'suggestion'
                                        let l:loclist_item.type = 'I'
                                    endif
                            
   32              0.000182         call add(l:loclist, l:loclist_item)
   32              0.000056     endfor
                            
   18              0.000049     return l:loclist

FUNCTION  airline#parts#filetype()
Called 102 times
Total time:   0.003945
 Self time:   0.001698

count  total (s)   self (s)
  102   0.003836   0.001589   return (airline#util#winwidth() < 90 && strlen(&filetype) > 3) ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? '…' : '>') : &filetype

FUNCTION  <SNR>160_StartIfExecutable()
Called 9 times
Total time:   0.027287
 Self time:   0.000689

count  total (s)   self (s)
    9   0.000185   0.000099     if ale#command#IsDeferred(a:executable)
                                    let a:executable.result_callback = {   executable -> s:StartIfExecutable(a:options, executable)}
                            
                                    return 1
                                endif
                            
    9   0.000352   0.000106     if !ale#engine#IsExecutable(a:options.buffer, a:executable)
                                    return 0
                                endif
                            
    9   0.000365   0.000118     let l:command = ale#linter#GetCommand(a:options.buffer, a:options.linter)
                            
    9   0.026204   0.000186     return s:StartWithCommand(a:options, a:executable, l:command)

FUNCTION  <SNR>134_iscontOne()
Called 1 time
Total time:   0.000390
 Self time:   0.000096

count  total (s)   self (s)
    1              0.000011   let [l:i, l:num, bL] = [a:i, a:num + !a:num, 0]
    1              0.000008   let pind = a:num ? indent(l:num) + s:W : 0
    1              0.000008   let ind = indent(l:i) + (a:cont ? 0 : s:W)
    1              0.000007   while l:i >= l:num && (ind > pind || l:i == l:num)
    1   0.000322   0.000028 	if indent(l:i) < ind && s:OneScope(l:i)
                            	  let bL += s:W
                            	  let l:i = line('.')
                            	elseif !a:cont || bL || ind < indent(a:i)
    1              0.000002 	  break
                            	endif
                            	let ind = min([ind, indent(l:i)])
                            	let l:i = s:PrevCodeLine(l:i - 1)
                              endwhile
    1              0.000002   return bL

FUNCTION  ale#handlers#eslint#GetCommand()
Called 9 times
Total time:   0.010816
 Self time:   0.000478

count  total (s)   self (s)
    9   0.009486   0.000111     let l:executable = ale#handlers#eslint#GetExecutable(a:buffer)
                            
    9   0.000432   0.000136     let l:options = ale#Var(a:buffer, 'javascript_eslint_options')
                            
    9   0.000864   0.000197     return ale#node#Executable(a:buffer, l:executable)   . (!empty(l:options) ? ' ' . l:options : '')   . ' -f json --stdin --stdin-filename %s'

FUNCTION  airline#parts#iminsert()
Called 102 times
Total time:   0.001340
 Self time:   0.001340

count  total (s)   self (s)
  102              0.000548   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
                              endif
  102              0.000151   return ''

FUNCTION  <SNR>135_GetSyntaxNames()
Called 2 times
Total time:   0.000142
 Self time:   0.000142

count  total (s)   self (s)
    2              0.000140   return map(synstack(a:lnum, a:cnum), 'synIDattr(v:val, "name")')

FUNCTION  ale#handlers#tslint#GetExecutable()
Called 9 times
Total time:   0.007094
 Self time:   0.000231

count  total (s)   self (s)
    9   0.007073   0.000211     return ale#node#FindExecutable(a:buffer, 'typescript_tslint', [   'node_modules/.bin/tslint',])

FUNCTION  <SNR>176_UpdateCacheIfNecessary()
Called 84 times
Total time:   0.001306
 Self time:   0.001306

count  total (s)   self (s)
                                " Cache is cold, so manually ask for an update.
   84              0.000581     if !has_key(g:ale_buffer_info[a:buffer], 'count')
                                    call ale#statusline#Update(   a:buffer,   g:ale_buffer_info[a:buffer].loclist)
                                endif

FUNCTION  <SNR>154_GatherOutput()
Called 2 times
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    2              0.000022     call add(a:line_list, a:line)

FUNCTION  <SNR>123_PollCompletion()
Called 98 times
Total time:   0.215752
 Self time:   0.005998

count  total (s)   self (s)
   98   0.173452   0.001707   if !s:Pyeval( 'ycm_state.CompletionRequestReady()' )
   75              0.002258     let s:pollers.completion.id = timer_start( s:pollers.completion.wait_milliseconds, function( 's:PollCompletion' ) )
   75              0.000213     return
                              endif
                            
   23   0.036881   0.000545   let s:completion = s:Pyeval( 'ycm_state.GetCompletionResponse()' )
   23   0.002111   0.000437   call s:Complete()

FUNCTION  ale#node#Executable()
Called 9 times
Total time:   0.000667
 Self time:   0.000353

count  total (s)   self (s)
    9              0.000100     if has('win32') && a:executable =~? '\.js$'
                                    let l:node = ale#Var(a:buffer, 'windows_node_executable_path')
                            
                                    return ale#Escape(l:node) . ' ' . ale#Escape(a:executable)
                                endif
                            
    9   0.000415   0.000101     return ale#Escape(a:executable)

FUNCTION  ale#lsp_linter#CheckWithLSP()
Called 9 times
Total time:   0.038011
 Self time:   0.000254

count  total (s)   self (s)
    9   0.038002   0.000245     return ale#lsp_linter#StartLSP(a:buffer, a:linter, function('s:CheckWithLSP'))

FUNCTION  <SNR>134_continues()
Called 1 time
Total time:   0.000049
 Self time:   0.000049

count  total (s)   self (s)
    1              0.000048   return !cursor(a:ln, match(' '.a:con,s:continuation)) && eval( (['s:syn_at(line("."),col(".")) !~? "regex"'] + repeat(['getline(".")[col(".")-2] != tr(s:looking_at(),">","=")'],3) + repeat(['s:previous_token() != "."'],5) + [1])[ index(split('/ > - + typeof in instanceof void delete'),s:token())])

FUNCTION  airline#highlighter#highlight()
Called 8 times
Total time:   0.421991
 Self time:   0.055229

count  total (s)   self (s)
    8              0.000046   let bufnr = a:0 ? a:1 : ''
    8              0.000063   let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
    8              0.000186   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
    8              0.000050   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
    8              0.000030   let airline_grouplist = []
    8              0.000114   let buffers_in_tabpage = sort(tabpagebuflist())
    8              0.000045   if exists("*uniq")
    8              0.000070     let buffers_in_tabpage = uniq(buffers_in_tabpage)
    8              0.000012   endif
                              " mapped might be something like ['normal', 'normal_modified']
                              " if a group is in both modes available, only define the second
                              " that is how this was done previously overwrite the previous definition
   24              0.000118   for mode in reverse(mapped)
   16              0.000227     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
   12              0.000104       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
  258              0.001338       for kvp in items(dict)
  246              0.001084         let mode_colors = kvp[1]
  246              0.000955         let name = kvp[0]
  246              0.001463         if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
                                      let name = 'airline_c'.bufnr
                                    endif
                                    " do not re-create highlighting for buffers that are no longer visible
                                    " in the current tabpage
  246              0.003959         if name =~# 'airline_c\d\+'
   24              0.000488           let bnr = matchstr(name, 'airline_c\zs\d\+') + 0
   24              0.000169           if bnr > 0 && index(buffers_in_tabpage, bnr) == -1
                                        continue
                                      endif
   24              0.000137         elseif (name =~# '_to_') || (name[0:10] is# 'airline_tab' && !empty(suffix))
                                      " group will be redefined below at exec_separator
                                      " or is not needed for tabline with '_inactive' suffix
                                      " since active flag is 1 for builder)
  144              0.000341           continue
                                    endif
  102   0.003585   0.001465         if s:group_not_done(airline_grouplist, name.suffix)
   66   0.051440   0.001199           call airline#highlighter#exec(name.suffix, mode_colors)
   66              0.000100         endif
                            
  306              0.001339         for accent in keys(s:accents)
  204              0.001144           if !has_key(p.accents, accent)
                                        continue
                                      endif
  204              0.001868           let colors = copy(mode_colors)
  204              0.001144           if p.accents[accent][0] != ''
  102              0.000573             let colors[0] = p.accents[accent][0]
  102              0.000139           endif
  204              0.000880           if p.accents[accent][2] != ''
  102              0.000509             let colors[2] = p.accents[accent][2]
  102              0.000133           endif
  204              0.000787           if len(colors) >= 5
  204              0.001530             let colors[4] = get(p.accents[accent], 4, '')
  204              0.000296           else
                                        call add(colors, get(p.accents[accent], 4, ''))
                                      endif
  204   0.007081   0.003121           if s:group_not_done(airline_grouplist, name.suffix.'_'.accent)
  132   0.079326   0.002396             call airline#highlighter#exec(name.suffix.'_'.accent, colors)
  132              0.000194           endif
  204              0.000320         endfor
  102              0.000139       endfor
                            
   12              0.000052       if empty(s:separators)
                                    " nothing to be done
                                    continue
                                  endif
                                  " TODO: optimize this
  180              0.001003       for sep in items(s:separators)
                                    " we cannot check, that the group already exists, else the separators
                                    " might not be correctly defined. But perhaps we can skip above groups
                                    " that match the '_to_' name, because they would be redefined here...
  168   0.236877   0.003364         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
  168              0.000353       endfor
   12              0.000014     endif
   16              0.000036   endfor

FUNCTION  ale#linter#GetAll()
Called 9 times
Total time:   0.001015
 Self time:   0.000792

count  total (s)   self (s)
                                " Don't return linters in the sandbox.
                                " Otherwise a sandboxed script could modify them.
    9   0.000308   0.000086     if ale#util#InSandbox()
                                    return []
                                endif
                            
    9              0.000038     let l:combined_linters = []
                            
   18              0.000063     for l:filetype in a:filetypes
                                    " Load linters from runtimepath if we haven't done that yet.
    9              0.000061         if !has_key(s:runtime_loaded_map, l:filetype)
                                        execute 'silent! runtime! ale_linters/' . l:filetype . '/*.vim'
                            
                                        let s:runtime_loaded_map[l:filetype] = 1
                                    endif
                            
    9              0.000113         call extend(l:combined_linters, get(s:linters, l:filetype, []))
    9              0.000018     endfor
                            
    9              0.000026     return l:combined_linters

FUNCTION  <SNR>173_UpdateLineNumbers()
Called 20 times
Total time:   0.004087
 Self time:   0.004087

count  total (s)   self (s)
   20              0.000095     let l:line_map = {}
   20              0.000076     let l:line_numbers_changed = 0
                            
   57              0.000258     for [l:line, l:sign_id, l:name] in a:current_sign_list
   37              0.000241         let l:line_map[l:sign_id] = l:line
   37              0.000063     endfor
                            
  107              0.000265     for l:item in a:loclist
   87              0.000285         if l:item.bufnr == a:buffer
   87              0.000910             let l:lnum = get(l:line_map, get(l:item, 'sign_id', 0), 0)
                            
   87              0.000307             if l:lnum && l:item.lnum != l:lnum
                                            let l:item.lnum = l:lnum
                                            let l:line_numbers_changed = 1
                                        endif
   87              0.000088         endif
   87              0.000101     endfor
                            
                                " When the line numbers change, sort the list again
   20              0.000054     if l:line_numbers_changed
                                    call sort(a:loclist, 'ale#util#LocItemCompare')
                                endif

FUNCTION  provider#python3#Call()
Called 700 times
Total time:   5.547746
 Self time:   5.547746

count  total (s)   self (s)
  700              0.003713   if s:err != ''
                                return
                              endif
  700              0.004859   if !exists('s:host')
                                let s:rpcrequest = function('rpcrequest')
                            
                                " Ensure that we can load the Python3 host before bootstrapping
                                try
                                  let s:host = remote#host#Require('legacy-python3-provider')
                                catch
                                  let s:err = v:exception
                                  echohl WarningMsg
                                  echomsg v:exception
                                  echohl None
                                  return
                                endtry
                              endif
  700              5.515493   return call(s:rpcrequest, insert(insert(a:args, 'python_'.a:method), s:host))

FUNCTION  airline#extensions#tabline#buflist#list()
Called 15 times
Total time:   0.000198
 Self time:   0.000198

count  total (s)   self (s)
   15              0.000130   if exists('s:current_buffer_list')
   15              0.000045     return s:current_buffer_list
                              endif
                            
                              let exclude_buffers = get(g:, 'airline#extensions#tabline#exclude_buffers', [])
                              let exclude_paths = get(g:, 'airline#extensions#tabline#excludes', [])
                              let exclude_preview = get(g:, 'airline#extensions#tabline#exclude_preview', 1)
                            
                              let list = (exists('g:did_bufmru') && g:did_bufmru) ? BufMRUList() : range(1, bufnr("$"))
                            
                              let buffers = []
                              " If this is too slow, we can switch to a different algorithm.
                              " Basically branch 535 already does it, but since it relies on
                              " BufAdd autocommand, I'd like to avoid this if possible.
                              for nr in list
                                if buflisted(nr)
                                  " Do not add to the bufferlist, if either
                                  " 1) bufnr is exclude_buffers list
                                  " 2) buffername matches one of exclude_paths patterns
                                  " 3) buffer is a quickfix buffer
                                  " 4) when excluding preview windows:
                                  "     'bufhidden' == wipe
                                  "     'buftype' == nofile
                                  " 5) ignore buffers matching airline#extensions#tabline#ignore_bufadd_pat
                            
                                  " check buffer numbers first
                                  if index(exclude_buffers, nr) >= 0
                                    continue
                                  " check paths second
                                  elseif !empty(exclude_paths) && s:ExcludePaths(nr, exclude_paths)
                                    continue
                                  " ignore buffers matching airline#extensions#tabline#ignore_bufadd_pat
                                  elseif airline#util#ignore_buf(bufname(nr))
                                    continue
                                  " check other types last
                                  elseif s:ExcludeOther(nr, exclude_preview)
                                    continue
                                  endif
                            
                                  call add(buffers, nr)
                                endif
                              endfor
                            
                              let s:current_buffer_list = buffers
                              return buffers

FUNCTION  airline#mode_changed()
Called 8 times
Total time:   0.000427
 Self time:   0.000312

count  total (s)   self (s)
                              " airline#visual_active
                              " Boolean: for when to get visual wordcount
                              " needed for the wordcount extension
    8              0.000172   let g:airline#visual_active = (mode() =~? '[vs]')
    8   0.000220   0.000105   call airline#update_tabline()

FUNCTION  <SNR>171_prev_line()
Called 1 time
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
    1              0.000008   let lnum = prevnonblank(a:lnum - 1)
    1              0.000024   return substitute(getline(lnum), '^\s*\|\s*$', '', 'g')

FUNCTION  ale#history#RememberOutput()
Called 2 times
Total time:   0.000253
 Self time:   0.000047

count  total (s)   self (s)
    2   0.000239   0.000033     let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                            
    2              0.000009     let l:obj.output = a:output

FUNCTION  <SNR>123_InsideCommentOrString()
Called 85 times
Total time:   0.037704
 Self time:   0.037704

count  total (s)   self (s)
                              " Has to be col('.') -1 because col('.') doesn't exist at this point. We are
                              " in insert mode when this func is called.
   85              0.035282   let syntax_group = synIDattr( synIDtrans( synID( line( '.' ), col( '.' ) - 1, 1 ) ), 'name')
                            
   85              0.000625   if stridx(syntax_group, 'Comment') > -1
                                return 1
                              endif
                            
   85              0.000392   if stridx(syntax_group, 'String') > -1
                                return 2
                              endif
                            
   85              0.000142   return 0

FUNCTION  ale#ShouldDoNothing()
Called 41 times
Total time:   0.010763
 Self time:   0.007979

count  total (s)   self (s)
                                " The checks are split into separate if statements to make it possible to
                                " profile each check individually with Vim's profiling tools.
                                "
                                " Do nothing if ALE is disabled.
   41              0.000466     if !getbufvar(a:buffer, 'ale_enabled', get(g:, 'ale_enabled', 0))
                                    return 1
                                endif
                            
                                " Don't perform any checks when newer NeoVim versions are exiting.
   41              0.000307     if get(v:, 'exiting', v:null) isnot v:null
                                    return 1
                                endif
                            
   41              0.000377     let l:filetype = getbufvar(a:buffer, '&filetype')
                            
                                " Do nothing when there's no filetype.
   41              0.000148     if l:filetype is# ''
                                    return 1
                                endif
                            
                                " Do nothing for diff buffers.
   41              0.000224     if getbufvar(a:buffer, '&diff')
                                    return 1
                                endif
                            
                                " Do nothing for blacklisted files.
   41              0.000613     if index(get(g:, 'ale_filetype_blacklist', []), l:filetype) >= 0
                                    return 1
                                endif
                            
                                " Do nothing if running from command mode.
   41              0.000288     if s:getcmdwintype_exists && !empty(getcmdwintype())
                                    return 1
                                endif
                            
   41              0.000419     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
                                " Do nothing for directories.
   41              0.000267     if l:filename is# '.'
                                    return 1
                                endif
                            
                                " Don't start linting and so on when an operator is pending.
   41   0.000920   0.000549     if ale#util#Mode(1) is# 'no'
                                    return 1
                                endif
                            
                                " Do nothing if running in the sandbox.
   41   0.002061   0.000580     if ale#util#InSandbox()
                                    return 1
                                endif
                            
                                " Do nothing if the file is too large.
   41   0.001364   0.000432     if ale#FileTooLarge(a:buffer)
                                    return 1
                                endif
                            
                                " Do nothing from CtrlP buffers with CtrlP-funky.
   41              0.000635     if exists(':CtrlPFunky') is 2&& getbufvar(a:buffer, '&l:statusline') =~# 'CtrlPMode.*funky'
                                    return 1
                                endif
                            
   41              0.000064     return 0

FUNCTION  airline#extensions#ale#get_error()
Called 102 times
Total time:   0.019821
 Self time:   0.001364

count  total (s)   self (s)
  102   0.019702   0.001245   return airline#extensions#ale#get('error')

FUNCTION  ale#lsp_linter#HandleLSPResponse()
Called 36 times
Total time:   0.159183
 Self time:   0.002858

count  total (s)   self (s)
   36              0.000293     let l:method = get(a:response, 'method', '')
                            
   36              0.000291     if get(a:response, 'jsonrpc', '') is# '2.0' && has_key(a:response, 'error')
                                    let l:linter_name = get(s:lsp_linter_map, a:conn_id, '')
                            
                                    call s:HandleLSPErrorMessage(l:linter_name, a:response)
                                elseif l:method is# 'textDocument/publishDiagnostics'
                                    call s:HandleLSPDiagnostics(a:conn_id, a:response)
                                elseif get(a:response, 'type', '') is# 'event'&& get(a:response, 'event', '') is# 'semanticDiag'
    9   0.064131   0.000160         call s:HandleTSServerDiagnostics(a:response, 'semantic')
    9              0.000063     elseif get(a:response, 'type', '') is# 'event'&& get(a:response, 'event', '') is# 'syntaxDiag'
    9   0.092568   0.000214         call s:HandleTSServerDiagnostics(a:response, 'syntax')
    9              0.000014     endif

FUNCTION  <SNR>160_ShouldIgnore()
Called 18 times
Total time:   0.001809
 Self time:   0.000859

count  total (s)   self (s)
                                " Ignore all diagnostics if LSP integration is disabled.
   18   0.000708   0.000197     if ale#Var(a:buffer, 'disable_lsp')
                                    return 1
                                endif
                            
   18   0.000774   0.000335     let l:config = ale#Var(a:buffer, 'linters_ignore')
                            
                                " Don't load code for ignoring diagnostics if there's nothing to ignore.
   18              0.000071     if empty(l:config)
   18              0.000068         return 0
                                endif
                            
                                let l:filetype = getbufvar(a:buffer, '&filetype')
                                let l:ignore_list = ale#engine#ignore#GetList(l:filetype, l:config)
                            
                                return index(l:ignore_list, a:linter_name) >= 0

FUNCTION  ale#engine#IsCheckingBuffer()
Called 253 times
Total time:   0.006112
 Self time:   0.006112

count  total (s)   self (s)
  253              0.002508     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
  253              0.003020     return !empty(get(l:info, 'active_linter_list', []))   || !empty(get(l:info, 'active_other_sources_list', []))

FUNCTION  <SNR>153_RunJob()
Called 9 times
Total time:   0.063507
 Self time:   0.002965

count  total (s)   self (s)
    9   0.000200   0.000112     if ale#command#IsDeferred(a:command)
                                    let a:command.result_callback = {   command -> s:RunJob(command, a:options)}
                            
                                    return 1
                                endif
                            
    9              0.000056     let l:command = a:command
                            
    9              0.000041     if empty(l:command)
                                    return 0
                                endif
                            
    9              0.000078     let l:executable = a:options.executable
    9              0.000038     let l:buffer = a:options.buffer
    9              0.000033     let l:linter = a:options.linter
    9              0.000048     let l:output_stream = a:options.output_stream
    9              0.000040     let l:next_chain_index = a:options.next_chain_index
    9              0.000036     let l:read_buffer = a:options.read_buffer
    9              0.000059     let l:info = g:ale_buffer_info[l:buffer]
                            
    9              0.000195     let l:Callback = function('s:HandleExit', [{   'linter': l:linter,   'executable': l:executable,   'next_chain_index': l:next_chain_index,}])
    9   0.058790   0.000541     let l:result = ale#command#Run(l:buffer, l:command, l:Callback, {   'output_stream': l:output_stream,   'executable': l:executable,   'read_buffer': l:read_buffer,   'log_output': l:next_chain_index >= len(get(l:linter, 'command_chain', [])),})
                            
                                " Only proceed if the job is being run.
    9              0.000052     if empty(l:result)
                                    return 0
                                endif
                            
    9   0.000637   0.000285     call ale#engine#MarkLinterActive(l:info, l:linter)
                            
    9   0.002750   0.000896     silent doautocmd <nomodeline> User ALEJobStarted
                            
    9              0.000051     return 1

FUNCTION  <SNR>153_RunLinter()
Called 45 times
Total time:   0.152730
 Self time:   0.002252

count  total (s)   self (s)
   45              0.000281     if !empty(a:linter.lsp)
    9   0.038189   0.000178         return ale#lsp_linter#CheckWithLSP(a:buffer, a:linter)
                                else
   36   0.025567   0.000597         let l:executable = ale#linter#GetExecutable(a:buffer, a:linter)
                            
   36   0.088317   0.000820         return s:RunIfExecutable(a:buffer, a:linter, l:executable)
                                endif
                            
                                return 0

FUNCTION  airline#util#winwidth()
Called 1069 times
Total time:   0.023152
 Self time:   0.023152

count  total (s)   self (s)
 1069              0.008143   let nr = get(a:000, 0, 0)
 1069              0.005510   if get(g:, 'airline_statusline_ontop', 0)
                                return &columns
                              else
 1069              0.004004     return winwidth(nr)
                              endif

FUNCTION  ale#lsp#OpenDocument()
Called 9 times
Total time:   0.000568
 Self time:   0.000568

count  total (s)   self (s)
    9              0.000074     let l:conn = get(s:connections, a:conn_id, {})
    9              0.000030     let l:opened = 0
                            
    9              0.000080     if !empty(l:conn) && !has_key(l:conn.open_documents, a:buffer)
                                    if l:conn.is_tsserver
                                        let l:message = ale#lsp#tsserver_message#Open(a:buffer)
                                    else
                                        let l:message = ale#lsp#message#DidOpen(a:buffer, a:language_id)
                                    endif
                            
                                    call ale#lsp#Send(a:conn_id, l:message)
                                    let l:conn.open_documents[a:buffer] = getbufvar(a:buffer, 'changedtick')
                                    let l:opened = 1
                                endif
                            
    9              0.000021     return l:opened

FUNCTION  ale#engine#MarkLinterActive()
Called 18 times
Total time:   0.000803
 Self time:   0.000803

count  total (s)   self (s)
   18              0.000081     let l:found = 0
                            
   27              0.000135     for l:other_linter in a:info.active_linter_list
    9              0.000048         if l:other_linter.name is# a:linter.name
                                        let l:found = 1
                                        break
                                    endif
    9              0.000014     endfor
                            
   18              0.000042     if !l:found
   18              0.000110         call add(a:info.active_linter_list, a:linter)
   18              0.000025     endif

FUNCTION  airline#util#doautocmd()
Called 8 times
Total time:   0.001801
 Self time:   0.000790

count  total (s)   self (s)
    8   0.001792   0.000780   exe printf("silent doautocmd %s User %s", s:nomodeline, a:event)

FUNCTION  36()
Called 8 times
Total time:   0.000404
 Self time:   0.000261

count  total (s)   self (s)
                            
    8   0.000234   0.000090     if nerdtree#runningWindows()
                                    if exists('+shellslash') && &shellslash
                                        return '/'
                                    endif
                            
                                    return '\'
                                endif
                            
    8              0.000015     return '/'

FUNCTION  tagbar#currenttag()
Called 17 times
Total time:   0.001316
 Self time:   0.001179

count  total (s)   self (s)
                                " Indicate that the statusline functionality is being used. This prevents
                                " the CloseWindow() function from removing the autocommands.
   17              0.000106     let s:statusline_in_use = 1
                            
   17              0.000047     if a:0 > 0
                                    " also test for non-zero value for backwards compatibility
   17              0.000248         let longsig   = a:1 =~# 's' || (type(a:1) == type(0) && a:1 != 0)
   17              0.000122         let fullpath  = a:1 =~# 'f'
   17              0.000135         let prototype = a:1 =~# 'p'
   17              0.000028     else
                                    let longsig   = 0
                                    let fullpath  = 0
                                    let prototype = 0
                                endif
                            
   17   0.000340   0.000203     if !s:Init(1)
   17              0.000045         return a:default
                                endif
                            
                                let tag = s:GetNearbyTag(0, 1)
                            
                                if !empty(tag)
                                    if prototype
                                        return tag.getPrototype(1)
                                    else
                                        return printf(a:fmt, tag.str(longsig, fullpath))
                                    endif
                                else
                                    return a:default
                                endif

FUNCTION  ale#util#Writefile()
Called 9 times
Total time:   0.003850
 Self time:   0.003850

count  total (s)   self (s)
    9              0.000148     let l:corrected_lines = getbufvar(a:buffer, '&fileformat') is# 'dos'   ? map(copy(a:lines), 'substitute(v:val, ''\r*$'', ''\r'', '''')')   : a:lines
                            
    9              0.003679     call writefile(l:corrected_lines, a:filename, 'S') " no-custom-checks

FUNCTION  <SNR>123_PollFileParseResponse()
Called 6 times
Total time:   0.012106
 Self time:   0.004607

count  total (s)   self (s)
    6   0.003297   0.000124   if !s:Pyeval( "ycm_state.FileParseRequestReady()" )
                                let s:pollers.file_parse_response.id = timer_start( s:pollers.file_parse_response.wait_milliseconds, function( 's:PollFileParseResponse' ) )
                                return
                              endif
                            
    6              0.004110   exec s:python_command "ycm_state.HandleFileParseRequest()"
    6   0.004488   0.000161   if s:Pyeval( "ycm_state.ShouldResendFileParseRequest()" )
                                call s:OnFileReadyToParse( 1 )
                              endif

FUNCTION  42()
Called 8 times
Total time:   0.001935
 Self time:   0.000929

count  total (s)   self (s)
    8              0.000056     let options = a:0 ? a:1 : {}
    8              0.000026     let toReturn = ""
                            
    8              0.000040     if has_key(options, 'format')
                                    let format = options['format']
                                    if has_key(self, '_strFor' . format)
                                        exec 'let toReturn = self._strFor' . format . '()'
                                    else
                                        throw 'NERDTree.UnknownFormatError: unknown format "'. format .'"'
                                    endif
                                else
    8   0.001062   0.000123         let toReturn = self._str()
    8              0.000014     endif
                            
    8   0.000161   0.000094     if nerdtree#has_opt(options, 'escape')
                                    let toReturn = shellescape(toReturn)
                                endif
                            
    8              0.000036     if has_key(options, 'truncateTo')
                                    let limit = options['truncateTo']
                                    if strdisplaywidth(toReturn) > limit-1
                                        while strdisplaywidth(toReturn) > limit-1 && strchars(toReturn) > 0
                                            let toReturn = substitute(toReturn, '^.', '', '')
                                        endwhile
                                        if len(split(toReturn, '/')) > 1
                                            let toReturn = '</' . join(split(toReturn, '/')[1:], '/') . '/'
                                        else
                                            let toReturn = '<' . toReturn
                                        endif
                                    endif
                                endif
                            
    8              0.000019     return toReturn

FUNCTION  47()
Called 8 times
Total time:   0.000939
 Self time:   0.000418

count  total (s)   self (s)
    8   0.000519   0.000114     let l:separator = s:Path.Slash()
    8              0.000036     let l:leader = l:separator
                            
    8   0.000188   0.000071     if nerdtree#runningWindows()
                                    let l:leader = self.drive . l:separator
                                endif
                            
    8              0.000127     return l:leader . join(self.pathSegments, l:separator)

FUNCTION  ale#lsp_linter#GetOptions()
Called 9 times
Total time:   0.000365
 Self time:   0.000365

count  total (s)   self (s)
    9              0.000059     if has_key(a:linter, 'initialization_options_callback')
                                    return ale#util#GetFunction(a:linter.initialization_options_callback)(a:buffer)
                                endif
                            
    9              0.000040     if has_key(a:linter, 'initialization_options')
                                    let l:Options = a:linter.initialization_options
                            
                                    if type(l:Options) is v:t_func
                                        let l:Options = l:Options(a:buffer)
                                    endif
                            
                                    return l:Options
                                endif
                            
    9              0.000019     return {}

FUNCTION  ale#lsp#Register()
Called 9 times
Total time:   0.000379
 Self time:   0.000379

count  total (s)   self (s)
    9              0.000073     let l:conn_id = a:executable_or_address . ':' . a:project
                            
    9              0.000059     if !has_key(s:connections, l:conn_id)
                                    " is_tsserver: 1 if the connection is for tsserver.
                                    " data: The message data received so far.
                                    " root: The project root.
                                    " open_documents: A Dictionary mapping buffers to b:changedtick, keeping
                                    "   track of when documents were opened, and when we last changed them.
                                    " initialized: 0 if the connection is ready, 1 otherwise.
                                    " init_request_id: The ID for the init request.
                                    " init_options: Options to send to the server.
                                    " config: Configuration settings to send to the server.
                                    " callback_list: A list of callbacks for handling LSP responses.
                                    " capabilities_queue: The list of callbacks to call with capabilities.
                                    " capabilities: Features the server supports.
                                    let s:connections[l:conn_id] = {   'id': l:conn_id,   'is_tsserver': 0,   'data': '',   'root': a:project,   'open_documents': {},   'initialized': 0,   'init_request_id': 0,   'init_options': a:init_options,   'config': {},   'callback_list': [],   'init_queue': [],   'capabilities': {       'hover': 0,       'references': 0,       'completion': 0,       'completion_trigger_characters': [],       'definition': 0,       'typeDefinition': 0,       'symbol_search': 0,   },}
                                endif
                            
    9              0.000024     return l:conn_id

FUNCTION  <SNR>134_looking_at()
Called 9 times
Total time:   0.000082
 Self time:   0.000082

count  total (s)   self (s)
    9              0.000074   return getline('.')[col('.')-1]

FUNCTION  ale#util#Mode()
Called 41 times
Total time:   0.000371
 Self time:   0.000371

count  total (s)   self (s)
   41              0.000320     return call('mode', a:000)

FUNCTION  <SNR>159_NeoVimCallback()
Called 29 times
Total time:   0.194133
 Self time:   0.003525

count  total (s)   self (s)
   29              0.000355     let l:info = s:job_map[a:job]
                            
   29              0.000137     if a:event is# 'stdout'
   20   0.172961   0.000632         let l:info.out_cb_line = ale#util#JoinNeovimOutput(   a:job,   l:info.out_cb_line,   a:data,   l:info.mode,   ale#util#GetFunction(l:info.out_cb),)
   20              0.000055     elseif a:event is# 'stderr'
                                    let l:info.err_cb_line = ale#util#JoinNeovimOutput(   a:job,   l:info.err_cb_line,   a:data,   l:info.mode,   ale#util#GetFunction(l:info.err_cb),)
                                else
    9              0.000080         if has_key(l:info, 'out_cb') && !empty(l:info.out_cb_line)
                                        call ale#util#GetFunction(l:info.out_cb)(a:job, l:info.out_cb_line)
                                    endif
                            
    9              0.000060         if has_key(l:info, 'err_cb') && !empty(l:info.err_cb_line)
                                        call ale#util#GetFunction(l:info.err_cb)(a:job, l:info.err_cb_line)
                                    endif
                            
    9              0.000020         try
    9   0.018573   0.000294             call ale#util#GetFunction(l:info.exit_cb)(a:job, a:data)
    9              0.000020         finally
                                        " Automatically forget about the job after it's done.
    9              0.000064             if has_key(s:job_map, a:job)
    9              0.000074                 call remove(s:job_map, a:job)
    9              0.000015             endif
    9              0.000015         endtry
    9              0.000010     endif

FUNCTION  ale#lsp#tsserver_message#Change()
Called 9 times
Total time:   0.002466
 Self time:   0.002466

count  total (s)   self (s)
    9              0.000506     let l:lines = getbufline(a:buffer, 1, '$')
                            
                                " We will always use a very high endLine number, so we can delete
                                " lines from files. tsserver will gladly accept line numbers beyond the
                                " end.
    9              0.001919     return [1, 'ts@change', {   'file': expand('#' . a:buffer . ':p'),   'line': 1,   'offset': 1,   'endLine': 1073741824,   'endOffset': 1,   'insertString': join(l:lines, "\n") . "\n",}]

FUNCTION  <SNR>176_CreateCountDict()
Called 20 times
Total time:   0.000279
 Self time:   0.000279

count  total (s)   self (s)
                                " Keys 0 and 1 are for backwards compatibility.
                                " The count object used to be a List of [error_count, warning_count].
   20              0.000213     return {   '0': 0,   '1': 0,   'error': 0,   'warning': 0,   'info': 0,   'style_error': 0,   'style_warning': 0,   'total': 0,}

FUNCTION  ale#GetLocItemMessage()
Called 96 times
Total time:   0.015840
 Self time:   0.015840

count  total (s)   self (s)
   96              0.000474     let l:msg = a:format_string
   96              0.000433     let l:severity = g:ale_echo_msg_warning_str
   96              0.000710     let l:code = get(a:item, 'code', '')
   96              0.000812     let l:type = get(a:item, 'type', 'E')
   96              0.000671     let l:linter_name = get(a:item, 'linter_name', '')
   96              0.000734     let l:code_repl = !empty(l:code) ? '\=submatch(1) . l:code . submatch(2)' : ''
                            
   96              0.000354     if l:type is# 'E'
   96              0.000454         let l:severity = g:ale_echo_msg_error_str
   96              0.000222     elseif l:type is# 'I'
                                    let l:severity = g:ale_echo_msg_info_str
                                endif
                            
                                " Replace special markers with certain information.
                                " \=l:variable is used to avoid escaping issues.
   96              0.001692     let l:msg = substitute(l:msg, '\V%severity%', '\=l:severity', 'g')
   96              0.001267     let l:msg = substitute(l:msg, '\V%linter%', '\=l:linter_name', 'g')
   96              0.003810     let l:msg = substitute(l:msg, '\v\%([^\%]*)code([^\%]*)\%', l:code_repl, 'g')
                                " Replace %s with the text.
   96              0.001691     let l:msg = substitute(l:msg, '\V%s', '\=a:item.text', 'g')
                            
   96              0.000318     return l:msg

FUNCTION  <SNR>175_highlight_range()
Called 87 times
Total time:   0.004823
 Self time:   0.003372

count  total (s)   self (s)
                                " Set all of the positions, which are chunked into Lists which
                                " are as large as will be accepted by matchaddpos.
   87   0.004554   0.003103     call map(   ale#highlight#CreatePositions(       a:range.lnum,       a:range.col,       a:range.end_lnum,       a:range.end_col   ),   'matchaddpos(a:group, v:val)')

FUNCTION  delimitMate#GetSyntaxRegion()
Called 3 times
Total time:   0.000270
 Self time:   0.000270

count  total (s)   self (s)
    3              0.000267 	return synIDattr(synIDtrans(synID(a:line, a:col, 1)), 'name')

FUNCTION  ale#node#FindExecutable()
Called 45 times
Total time:   0.036810
 Self time:   0.003939

count  total (s)   self (s)
   45   0.002107   0.000661     if ale#Var(a:buffer, a:base_var_name . '_use_global')
                                    return ale#Var(a:buffer, a:base_var_name . '_executable')
                                endif
                            
   81              0.000342     for l:path in a:path_list
   63   0.031936   0.001088         let l:executable = ale#path#FindNearestFile(a:buffer, l:path)
                            
   63              0.000374         if !empty(l:executable)
   27              0.000081             return l:executable
                                    endif
   36              0.000061     endfor
                            
   18   0.000887   0.000308     return ale#Var(a:buffer, a:base_var_name . '_executable')

FUNCTION  <SNR>123_OnFileReadyToParse()
Called 12 times
Total time:   0.027301
 Self time:   0.010515

count  total (s)   self (s)
                              " Accepts an optional parameter that is either 0 or 1. If 1, send a
                              " FileReadyToParse event notification, whether the buffer has changed or not;
                              " effectively forcing a parse of the buffer. Default is 0.
   12              0.000070   let force_parsing = a:0 > 0 && a:1
                            
                              " We only want to send a new FileReadyToParse event notification if the buffer
                              " has changed since the last time we sent one, or if forced.
   12   0.016947   0.000161   if force_parsing || s:Pyeval( "ycm_state.NeedsReparse()" )
   12              0.009636     exec s:python_command "ycm_state.OnFileReadyToParse()"
                            
   12              0.000164     call timer_stop( s:pollers.file_parse_response.id )
   12              0.000323     let s:pollers.file_parse_response.id = timer_start( s:pollers.file_parse_response.wait_milliseconds, function( 's:PollFileParseResponse' ) )
   12              0.000027   endif

FUNCTION  ale#lsp#OnInit()
Called 9 times
Total time:   0.016684
 Self time:   0.000502

count  total (s)   self (s)
    9              0.000087     let l:conn = get(s:connections, a:conn_id, {})
                            
    9              0.000036     if empty(l:conn)
                                    return
                                endif
                            
    9              0.000022     if l:conn.initialized
    9   0.016409   0.000227         call a:Callback()
    9              0.000016     else
                                    call add(l:conn.init_queue, a:Callback)
                                endif

FUNCTION  <SNR>108_get_array()
Called 710 times
Total time:   0.013302
 Self time:   0.013302

count  total (s)   self (s)
  710              0.005606   let opts=empty(a:opts) ? '' : join(a:opts, ',')
  710              0.006798   return g:airline_gui_mode ==# 'gui' ? [ a:fg, a:bg, '', '', opts ] : [ '', '', a:fg, a:bg, opts ]

FUNCTION  airline#util#shorten()
Called 306 times
Total time:   0.018088
 Self time:   0.011259

count  total (s)   self (s)
  306   0.011366   0.004538   if airline#util#winwidth() < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
                                if get(a:000, 0, 0)
                                  " shorten from tail
                                  return '…'.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                else
                                  " shorten from beginning of string
                                  return matchstr(a:text, '^.\{'.a:minwidth.'}').'…'
                                endif
                              else
  306              0.000761     return a:text
                              endif

FUNCTION  <SNR>108_CheckDefined()
Called 374 times
Total time:   0.023787
 Self time:   0.023787

count  total (s)   self (s)
                              " Checks, whether the definition of the colors is valid and is not empty or NONE
                              " e.g. if the colors would expand to this:
                              " hi airline_c ctermfg=NONE ctermbg=NONE
                              " that means to clear that highlighting group, therefore, fallback to Normal
                              " highlighting group for the cterm values
                            
                              " This only works, if the Normal highlighting group is actually defined, so
                              " return early, if it has been cleared
  374              0.002652   if !exists("g:airline#highlighter#normal_fg_hi")
                                let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
                              endif
  374              0.002614   if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
                                return a:colors
                              endif
                            
  758              0.002845   for val in a:colors
  758              0.004015     if !empty(val) && val !=# 'NONE'
  374              0.001095       return a:colors
                                endif
  384              0.000516   endfor
                              " this adds the bold attribute to the term argument of the :hi command,
                              " but at least this makes sure, the group will be defined
                              let fg = g:airline#highlighter#normal_fg_hi
                              let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                              if bg < 0
                                " in case there is no background color defined for Normal
                                let bg = a:colors[3]
                              endif
                              return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  ale#FileTooLarge()
Called 41 times
Total time:   0.000932
 Self time:   0.000932

count  total (s)   self (s)
   41              0.000493     let l:max = getbufvar(a:buffer, 'ale_maximum_file_size', get(g:, 'ale_maximum_file_size', 0))
                            
   41              0.000299     return l:max > 0 ? (line2byte(line('$') + 1) > l:max) : 0

FUNCTION  ale#lsp#ReadMessageData()
Called 9 times
Total time:   0.007348
 Self time:   0.007348

count  total (s)   self (s)
    9              0.000044     let l:response_list = []
    9              0.000048     let l:remainder = a:data
                            
   45              0.000098     while 1
                                    " Look for the end of the HTTP headers
   45              0.000704         let l:body_start_index = matchend(l:remainder, "\r\n\r\n")
                            
   45              0.000162         if l:body_start_index < 0
                                        " No header end was found yet.
    9              0.000018             break
                                    endif
                            
                                    " Parse the Content-Length header.
   36              0.000261         let l:header_data = l:remainder[:l:body_start_index - 4]
   36              0.001102         let l:length_match = matchlist(   l:header_data,   '\vContent-Length: *(\d+)')
                            
   36              0.000183         if empty(l:length_match)
                                        throw "Invalid JSON-RPC header:\n" . l:header_data
                                    endif
                            
                                    " Split the body and the remainder of the text.
   36              0.000552         let l:remainder_start_index = l:body_start_index + str2nr(l:length_match[1])
                            
   36              0.000272         if len(l:remainder) < l:remainder_start_index
                                        " We don't have enough data yet.
                                        break
                                    endif
                            
   36              0.000279         let l:body = l:remainder[l:body_start_index : l:remainder_start_index - 1]
   36              0.000247         let l:remainder = l:remainder[l:remainder_start_index :]
                            
                                    " Parse the JSON object and add it to the list.
   36              0.001758         call add(l:response_list, json_decode(l:body))
   36              0.000103     endwhile
                            
    9              0.000050     return [l:remainder, l:response_list]

FUNCTION  <SNR>97_update_untracked()
Called 102 times
Total time:   0.032874
 Self time:   0.029854

count  total (s)   self (s)
  102              0.012654   let file = expand("%:p")
  102              0.002344   if empty(file) || isdirectory(file) || !empty(&buftype)
                                return
                              endif
                            
  102              0.000415   let needs_update = 1
  102              0.001135   let vcs_checks   = get(g:, "airline#extensions#branch#vcs_checks", ["untracked", "dirty"])
  306              0.001455   for vcs in keys(s:vcs_config)
  204              0.002477     if file =~ s:vcs_config[vcs].exclude
                                  " Skip check for files that live in the exclude directory
                                  let needs_update = 0
                                endif
  204              0.001577     if has_key(s:vcs_config[vcs].untracked, file)
  102              0.000357       let needs_update = 0
  102   0.004663   0.001643       call airline#extensions#branch#update_untracked_config(file, vcs)
  102              0.000138     endif
  204              0.000274   endfor
                            
  102              0.000247   if !needs_update
  102              0.000157     return
                              endif
                            
                              for vcs in keys(s:vcs_config)
                                " only check, for git, if fugitive is installed
                                " and for 'hg' if lawrencium is installed, else skip
                                if vcs is# 'git' && !airline#util#has_fugitive()
                                  continue
                                elseif vcs is# 'mercurial' && !airline#util#has_lawrencium()
                                  continue
                                endif
                                let config = s:vcs_config[vcs]
                                " Note that asynchronous update updates s:vcs_config only, and only
                                " s:update_untracked updates b:buffer_vcs_config. If s:vcs_config is
                                " invalidated again before s:update_untracked is called, then we lose the
                                " result of the previous call, i.e. the head string is not updated. It
                                " doesn't happen often in practice, so we let it be.
                                if index(vcs_checks, 'untracked') > -1
                                  call airline#async#vcs_untracked(config, file, vcs)
                                endif
                                " Check clean state of repo
                                if index(vcs_checks, 'dirty') > -1
                                  call airline#async#vcs_clean(config.dirty, file, vcs)
                                endif
                              endfor

FUNCTION  <SNR>134_OneScope()
Called 1 time
Total time:   0.000294
 Self time:   0.000085

count  total (s)   self (s)
    1   0.000184   0.000013   let pline = s:Trim(a:lnum)
    1              0.000003   let kw = 'else do'
    1              0.000008   if pline[-1:] == ')' && s:GetPair('(', ')', 'bW', s:skip_expr, 100) > 0
                            	call s:previous_token()
                            	let kw = 'for if let while with'
                            	if index(split('await each'),s:token()) + 1
                            	  call s:previous_token()
                            	  let kw = 'for'
                            	endif
                              endif
    1   0.000075   0.000036   return pline[-2:] == '=>' || index(split(kw),s:token()) + 1 && s:save_pos('s:previous_token') != '.'

FUNCTION  FugitiveGitDir()
Called 306 times
Total time:   0.014700
 Self time:   0.011746

count  total (s)   self (s)
  306              0.001345   if !a:0 || a:1 ==# -1
  102              0.000606     return get(b:, 'git_dir', '')
                              elseif type(a:1) == type(0)
                                return getbufvar(a:1, 'git_dir')
                              elseif type(a:1) == type('')
  204   0.008382   0.005429     return substitute(s:Slash(a:1), '/$', '', '')
                              else
                                return ''
                              endif

FUNCTION  <SNR>134_previous_token()
Called 2 times
Total time:   0.000335
 Self time:   0.000227

count  total (s)   self (s)
    2              0.000014   let l:n = line('.')
    2   0.000077   0.000059   if (s:looking_at() !~ '\k' || search('\m\<','cbW')) && search('\m\S','bW')
    2              0.000062 	if (getline('.')[col('.')-2:col('.')-1] == '*/' || line('.') != l:n && getline('.') =~ '\%<'.col('.').'c\/\/') && s:syn_at(line('.'),col('.')) =~? s:syng_com
                            	  while search('\m\/\ze[/*]','cbW')
                            		if !search('\m\S','bW')
                            		  break
                            		elseif s:syn_at(line('.'),col('.')) !~? s:syng_com
                            		  return s:token()
                            		endif
                            	  endwhile
                            	else
    2   0.000120   0.000030 	  return s:token()
                            	endif
                              endif
                              return ''

FUNCTION  ale#lsp#MarkConnectionAsTsserver()
Called 9 times
Total time:   0.000462
 Self time:   0.000462

count  total (s)   self (s)
    9              0.000074     let l:conn = s:connections[a:conn_id]
    9              0.000062     let l:conn.is_tsserver = 1
    9              0.000029     let l:conn.initialized = 1
                                " Set capabilities which are supported by tsserver.
    9              0.000032     let l:conn.capabilities.hover = 1
    9              0.000027     let l:conn.capabilities.references = 1
    9              0.000025     let l:conn.capabilities.completion = 1
    9              0.000110     let l:conn.capabilities.completion_trigger_characters = ['.']
    9              0.000031     let l:conn.capabilities.definition = 1
    9              0.000026     let l:conn.capabilities.symbol_search = 1

FUNCTION  airline#extensions#ale#get()
Called 204 times
Total time:   0.033621
 Self time:   0.018057

count  total (s)   self (s)
  204              0.001526   if !exists(':ALELint')
                                return ''
                              endif
                            
  204              0.001604   let error_symbol = get(g:, 'airline#extensions#ale#error_symbol', 'E:')
  204              0.001551   let warning_symbol = get(g:, 'airline#extensions#ale#warning_symbol', 'W:')
  204              0.001496   let checking_symbol = get(g:, 'airline#extensions#ale#checking_symbol', '...')
  204              0.001410   let show_line_numbers = get(g:, 'airline#extensions#ale#show_line_numbers', 1)
                            
  204              0.000931   let is_err = a:type ==# 'error'
                            
  204   0.007493   0.002588   if ale#engine#IsCheckingBuffer(bufnr('')) == 1
  148              0.000596     return is_err ? '' : checking_symbol
                              endif
                            
   56              0.000245   let symbol = is_err ? error_symbol : warning_symbol
                            
   56   0.005045   0.000607   let counts = ale#statusline#Count(bufnr(''))
   56              0.000480   if type(counts) == type({}) && has_key(counts, 'error')
                                " Use the current Dictionary format.
   56              0.000246     let errors = counts.error + counts.style_error
   56              0.000256     let num = is_err ? errors : counts.total - errors
   56              0.000075   else
                                " Use the old List format.
                                let num = is_err ? counts[0] : counts[1]
                              endif
                            
   56              0.000134   if show_line_numbers == 1
   56   0.007381   0.001161     return s:airline_ale_count(num, symbol) . <sid>airline_ale_get_line_number(num, a:type)
                              else
                                return s:airline_ale_count(num, symbol)
                              endif

FUNCTION  airline#util#wrap()
Called 926 times
Total time:   0.016010
 Self time:   0.012195

count  total (s)   self (s)
  926   0.010030   0.006215   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
                              endif
  926              0.002299   return a:text

FUNCTION  ale#command#Run()
Called 9 times
Total time:   0.058249
 Self time:   0.005010

count  total (s)   self (s)
    9              0.000075     let l:options = get(a:000, 0, {})
                            
    9              0.000039     if len(a:000) > 1
                                    throw 'Too many arguments!'
                                endif
                            
    9              0.000064     let l:output_stream = get(l:options, 'output_stream', 'stdout')
    9              0.000029     let l:line_list = []
                            
    9   0.012095   0.000333     let [l:temporary_file, l:command, l:file_created] = ale#command#FormatCommand(   a:buffer,   get(l:options, 'executable', ''),   a:command,   get(l:options, 'read_buffer', 0),   get(l:options, 'input', v:null),)
    9   0.002148   0.000172     let l:command = ale#job#PrepareCommand(a:buffer, l:command)
    9              0.000256     let l:job_options = {   'exit_cb': {job_id, exit_code -> s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )},   'mode': 'nl',}
                            
    9              0.000046     if l:output_stream is# 'stdout'
    9              0.000144         let l:job_options.out_cb = function('s:GatherOutput', [l:line_list])
    9              0.000028     elseif l:output_stream is# 'stderr'
                                    let l:job_options.err_cb = function('s:GatherOutput', [l:line_list])
                                elseif l:output_stream is# 'both'
                                    let l:job_options.out_cb = function('s:GatherOutput', [l:line_list])
                                    let l:job_options.err_cb = function('s:GatherOutput', [l:line_list])
                                endif
                            
    9              0.000033     let l:status = 'failed'
                            
    9              0.000056     if get(g:, 'ale_run_synchronously') == 1
                                    if get(g:, 'ale_emulate_job_failure') == 1
                                        let l:job_id = 0
                                    else
                                        " Generate a fake job ID for tests.
                                        let s:fake_job_id = get(s:, 'fake_job_id', 0) + 1
                                        let l:job_id = s:fake_job_id
                                    endif
                                elseif has('win32')
                                    let l:job_id = ale#job#StartWithCmd(l:command, l:job_options)
                                else
    9   0.038119   0.000491         let l:job_id = ale#job#Start(l:command, l:job_options)
    9              0.000026     endif
                            
    9              0.000025     if l:job_id
    9              0.000043         let l:status = 'started'
    9              0.000130         let l:job_type = getbufvar(a:buffer, 'ale_job_type', 'all')
                            
    9   0.000618   0.000418         call ale#command#InitData(a:buffer)
    9              0.000120         let s:buffer_data[a:buffer].jobs[l:job_id] = l:job_type
    9              0.000015     endif
                            
    9              0.000029     if g:ale_history_enabled
    9   0.002015   0.000341         call ale#history#Add(a:buffer, l:status, l:job_id, l:command)
    9              0.000017     endif
                            
    9              0.000026     if !l:job_id
                                    return 0
                                endif
                            
                                " We'll return this Dictionary. A `result_callback` can be assigned to it
                                " later for capturing the result of a:Callback.
                                "
                                " The `_deferred_job_id` is used for both checking the type of object, and
                                " for checking the job ID and status.
                                "
                                " The original command here is used in tests.
    9              0.000299     let l:result = {   '_deferred_job_id': l:job_id,   'executable': get(l:options, 'executable', ''),   'command': a:command,}
                            
    9              0.000062     if get(g:, 'ale_run_synchronously') == 1 && l:job_id
                                    if !exists('g:ale_run_synchronously_callbacks')
                                        let g:ale_run_synchronously_callbacks = []
                                    endif
                            
                                    if get(g:, 'ale_run_synchronously_emulate_commands', 0)
                                        call add(   g:ale_run_synchronously_callbacks,   {exit_code, output -> [       extend(l:line_list, output),       l:job_options.exit_cb(l:job_id, exit_code),   ]})
                                    else
                                        " Run a command synchronously if this test option is set.
                                        call extend(l:line_list, systemlist(   type(l:command) is v:t_list       ? join(l:command[0:1]) . ' ' . ale#Escape(l:command[2])       : l:command))
                            
                                        " Don't capture output when the callbacks aren't set.
                                        if !has_key(l:job_options, 'out_cb')&& !has_key(l:job_options, 'err_cb')
                                            let l:line_list = []
                                        endif
                            
                                        call add(   g:ale_run_synchronously_callbacks,   {-> l:job_options.exit_cb(l:job_id, v:shell_error)})
                                    endif
                                endif
                            
    9              0.000057     return l:result

FUNCTION  ale#command#IsDeferred()
Called 63 times
Total time:   0.000703
 Self time:   0.000703

count  total (s)   self (s)
   63              0.000571     return type(a:value) is v:t_dict && has_key(a:value, '_deferred_job_id')

FUNCTION  airline#extensions#tabline#get()
Called 15 times
Total time:   0.007993
 Self time:   0.001442

count  total (s)   self (s)
   15              0.000224   let show_buffers = get(g:, 'airline#extensions#tabline#show_buffers', 1)
   15              0.000112   let show_tabs = get(g:, 'airline#extensions#tabline#show_tabs', 1)
                            
   15              0.000090   let curtabcnt = tabpagenr('$')
   15              0.000067   if curtabcnt != s:current_tabcnt
                                let s:current_tabcnt = curtabcnt
                                call airline#extensions#tabline#tabs#invalidate()
                                call airline#extensions#tabline#buffers#invalidate()
                                call airline#extensions#tabline#ctrlspace#invalidate()
                              endif
                            
   15              0.000131   if !exists('#airline#BufAdd#*')
                                autocmd airline BufAdd * call <sid>update_tabline()
                              endif
   15              0.000033   if s:ctrlspace
                                return airline#extensions#tabline#ctrlspace#get()
                              elseif show_buffers && curtabcnt == 1 || !show_tabs
   15   0.006799   0.000248     return airline#extensions#tabline#buffers#get()
                              else
                                return airline#extensions#tabline#tabs#get()
                              endif

FUNCTION  <SNR>146_GetAliasedFiletype()
Called 9 times
Total time:   0.000939
 Self time:   0.000939

count  total (s)   self (s)
    9              0.000110     let l:buffer_aliases = get(b:, 'ale_linter_aliases', {})
                            
                                " b:ale_linter_aliases can be set to a List or String.
    9              0.000088     if type(l:buffer_aliases) is v:t_list|| type(l:buffer_aliases) is v:t_string
                                    return l:buffer_aliases
                                endif
                            
                                " Check for aliased filetypes first in a buffer variable,
                                " then the global variable,
                                " then in the default mapping,
                                " otherwise use the original filetype.
   36              0.000161     for l:dict in [   l:buffer_aliases,   g:ale_linter_aliases,   s:default_ale_linter_aliases,]
   27              0.000162         if has_key(l:dict, a:original_filetype)
                                        return l:dict[a:original_filetype]
                                    endif
   27              0.000049     endfor
                            
    9              0.000027     return a:original_filetype

FUNCTION  <SNR>166_syn_name()
Called 20 times
Total time:   0.005455
 Self time:   0.005455

count  total (s)   self (s)
   20              0.005236   let syn_id = get(synstack(a:lnum, a:cnum), -1)
   20              0.000166   return synIDattr(syn_id, "name")

FUNCTION  ale#handlers#eslint#HandleJSON()
Called 2 times
Total time:   0.003079
 Self time:   0.000044

count  total (s)   self (s)
    2   0.003078   0.000042     return s:HandleESLintOutput(a:buffer, a:lines, 'json')

FUNCTION  <SNR>134_token()
Called 3 times
Total time:   0.000129
 Self time:   0.000076

count  total (s)   self (s)
    3   0.000127   0.000074   return s:looking_at() =~ '\k' ? expand('<cword>') : s:looking_at()

FUNCTION  airline#extensions#hunks#get_raw_hunks()
Called 102 times
Total time:   0.017179
 Self time:   0.006329

count  total (s)   self (s)
  102              0.001510   if !exists('b:source_func') || get(b:, 'source_func', '') is# 's:get_hunks_empty'
                                if get(g:, 'loaded_signify') && sy#buffer_is_active()
                                  let b:source_func = 's:get_hunks_signify'
                                elseif exists('*GitGutterGetHunkSummary')
                                  let b:source_func = 's:get_hunks_gitgutter'
                                elseif exists('*changes#GetStats')
                                  let b:source_func = 's:get_hunks_changes'
                                elseif exists('*quickfixsigns#vcsdiff#GetHunkSummary')
                                  let b:source_func = 'quickfixsigns#vcsdiff#GetHunkSummary'
                                else
                                  let b:source_func = 's:get_hunks_empty'
                                endif
                              endif
  102   0.012319   0.001469   return {b:source_func}()

FUNCTION  airline#extensions#tabline#formatters#default#wrap_name()
Called 15 times
Total time:   0.000680
 Self time:   0.000680

count  total (s)   self (s)
   15              0.000118   let _ = s:buf_nr_show ? printf(s:buf_nr_format, a:bufnr) : ''
   15              0.000265   let _ .= substitute(a:buffer_name, '\\', '/', 'g')
                            
   15              0.000113   if getbufvar(a:bufnr, '&modified') == 1
   15              0.000076     let _ .= s:buf_modified_symbol
   15              0.000020   endif
   15              0.000034   return _

FUNCTION  <SNR>113_Lint()
Called 9 times
Total time:   0.173263
 Self time:   0.002615

count  total (s)   self (s)
                                " Use the filetype from the buffer
    9              0.000103     let l:filetype = getbufvar(a:buffer, '&filetype')
    9   0.006573   0.000218     let l:linters = ale#linter#Get(l:filetype)
                            
                                " Apply ignore lists for linters only if needed.
    9   0.000388   0.000133     let l:ignore_config = ale#Var(a:buffer, 'linters_ignore')
    9   0.000344   0.000115     let l:disable_lsp = ale#Var(a:buffer, 'disable_lsp')
    9              0.000108     let l:linters = !empty(l:ignore_config) || l:disable_lsp   ? ale#engine#ignore#Exclude(l:filetype, l:linters, l:ignore_config, l:disable_lsp)   : l:linters
                            
                                " Tell other sources that they can start checking the buffer now.
    9              0.000098     let g:ale_want_results_buffer = a:buffer
    9   0.001330   0.001071     silent doautocmd <nomodeline> User ALEWantResults
    9              0.000045     unlet! g:ale_want_results_buffer
                            
                                " Don't set up buffer data and so on if there are no linters to run.
    9              0.000103     if !has_key(g:ale_buffer_info, a:buffer) && empty(l:linters)
                                    return
                                endif
                            
                                " Clear lint_file linters, or only run them if the file exists.
    9              0.000112     let l:lint_file = empty(l:linters)   || (a:should_lint_file && filereadable(expand('#' . a:buffer . ':p')))
                            
    9   0.163822   0.000272     call ale#engine#RunLinters(a:buffer, l:linters, l:lint_file)

FUNCTION  ale#Queue()
Called 12 times
Total time:   0.135746
 Self time:   0.001715

count  total (s)   self (s)
   12              0.000048     if a:0 > 2
                                    throw 'too many arguments!'
                                endif
                            
   12              0.000203     let l:buffer = get(a:000, 1, v:null)
                            
   12              0.000050     if l:buffer is v:null
   12              0.000070         let l:buffer = bufnr('')
   12              0.000018     endif
                            
   12              0.000076     if type(l:buffer) isnot v:t_number
                                    throw 'buffer_number must be a Number'
                                endif
                            
   12   0.003242   0.000168     if ale#ShouldDoNothing(l:buffer)
                                    return
                                endif
                            
                                " Default linting_flag to ''
   12              0.000093     let l:should_lint_file = get(a:000, 0) is# 'lint_file'
                            
   12              0.000059     if s:lint_timer != -1
    4              0.000027         call timer_stop(s:lint_timer)
    4              0.000015         let s:lint_timer = -1
    4              0.000006     endif
                            
   12              0.000030     if a:delay > 0
    5              0.000100         let s:lint_timer = timer_start(   a:delay,   function('s:Lint', [l:buffer, l:should_lint_file]))
    5              0.000009     else
    7   0.131227   0.000270         call s:Lint(l:buffer, l:should_lint_file, 0)
    7              0.000015     endif

FUNCTION  <SNR>122_Tree()
Called 204 times
Total time:   0.027326
 Self time:   0.003046

count  total (s)   self (s)
  204   0.027142   0.002862   return a:0 ? FugitiveWorkTree(a:1) : FugitiveWorkTree()

FUNCTION  <SNR>108_group_not_done()
Called 306 times
Total time:   0.006079
 Self time:   0.006079

count  total (s)   self (s)
  306              0.002226   if index(a:list, a:name) == -1
  198              0.001211     call add(a:list, a:name)
  198              0.000402     return 1
                              else
  108              0.000263     if &vbs
                                  echomsg printf("airline: group: %s already done, skipping", a:name)
                                endif
  108              0.000167     return 0
                              endif

FUNCTION  <SNR>174_ShouldOpen()
Called 22 times
Total time:   0.001344
 Self time:   0.000645

count  total (s)   self (s)
   22   0.001003   0.000304     let l:val = ale#Var(a:buffer, 'open_list')
   22              0.000169     let l:saved = getbufvar(a:buffer, 'ale_save_event_fired', 0)
                            
   22              0.000116     return l:val is 1 || (l:val is# 'on_save' && l:saved)

FUNCTION  ale#engine#IsExecutable()
Called 45 times
Total time:   0.008570
 Self time:   0.006144

count  total (s)   self (s)
   45              0.000245     if empty(a:executable)
                                    " Don't log the executable check if the executable string is empty.
                                    return 0
                                endif
                            
                                " Check for a cached executable() check.
   45              0.000399     let l:result = get(s:executable_cache_map, a:executable, v:null)
                            
   45              0.000203     if l:result isnot v:null
   18              0.000042         return l:result
                                endif
                            
                                " Check if the file is executable, and convert -1 to 1.
   27              0.003414     let l:result = executable(a:executable) isnot 0
                            
                                " Cache the executable check if we found it, or if the option to cache
                                " failing checks is on.
   27              0.000233     if l:result || get(g:, 'ale_cache_executable_check_failures', 0)
                                    let s:executable_cache_map[a:executable] = l:result
                                endif
                            
   27              0.000079     if g:ale_history_enabled
   27   0.002952   0.000526         call ale#history#Add(a:buffer, l:result, 'executable', a:executable)
   27              0.000054     endif
                            
   27              0.000080     return l:result

FUNCTION  <SNR>62_g()
Called 22 times
Total time:   0.000944
 Self time:   0.000944

count  total (s)   self (s)
   22              0.000078 	if a:0 == 2
                            		return deepcopy(get(a:2, 'delimitMate_' . a:name, a:1))
                            	elseif a:0 == 1
                            		let bufoptions = get(s:options, bufnr('%'), {})
                            		return deepcopy(get(bufoptions, a:name, a:1))
                            	else
   22              0.000363 		return deepcopy(eval('s:options.' . bufnr('%') . '.' . a:name))
                            	endif

FUNCTION  <SNR>155_FilterResult()
Called 2 times
Total time:   0.000145
 Self time:   0.000083

count  total (s)   self (s)
    2   0.000088   0.000025     if ale#Var(a:buffer, 'javascript_eslint_suppress_eslintignore')
                                    if a:obj.text =~# '^File ignored'
                                        return 0
                                    endif
                                endif
                            
    2              0.000023     if has_key(a:obj, 'code') && a:obj.code is# 'no-trailing-spaces'&& !ale#Var(a:buffer, 'warn_about_trailing_whitespace')
                                    return 0
                                endif
                            
    2              0.000003     return 1

FUNCTION  ale#Escape()
Called 36 times
Total time:   0.001249
 Self time:   0.001249

count  total (s)   self (s)
   36              0.000372     if fnamemodify(&shell, ':t') is? 'cmd.exe'
                                    " If the string contains spaces, it will be surrounded by quotes.
                                    " Otherwise, special characters will be escaped with carets (^).
                                    return substitute(   a:str =~# ' '       ?  '"' .  substitute(a:str, '"', '""', 'g') . '"'       : substitute(a:str, '\v([&|<>^])', '^\1', 'g'),   '%',   '%%',   'g',)
                                endif
                            
   36              0.000287     return shellescape (a:str)

FUNCTION  <SNR>18_Tree()
Called 204 times
Total time:   0.006004
 Self time:   0.006004

count  total (s)   self (s)
  204              0.001011   let dir = a:path
  204              0.002918   if dir =~# '/\.git$'
  204              0.001628     return len(dir) ==# 5 ? '/' : dir[0:-6]
                              elseif dir ==# ''
                                return ''
                              endif
                              if !has_key(s:worktree_for_dir, dir)
                                let s:worktree_for_dir[dir] = ''
                                let config_file = dir . '/config'
                                if filereadable(config_file)
                                  let config = readfile(config_file,'',10)
                                  call filter(config,'v:val =~# "^\\s*worktree *="')
                                  if len(config) == 1
                                    let worktree = matchstr(config[0], '= *\zs.*')
                                  endif
                                elseif filereadable(dir . '/gitdir')
                                  let worktree = fnamemodify(readfile(dir . '/gitdir')[0], ':h')
                                  if worktree ==# '.'
                                    unlet! worktree
                                  endif
                                endif
                                if exists('worktree')
                                  let s:worktree_for_dir[dir] = worktree
                                  let s:dir_for_worktree[s:worktree_for_dir[dir]] = dir
                                endif
                              endif
                              if s:worktree_for_dir[dir] =~# '^\.'
                                return simplify(dir . '/' . s:worktree_for_dir[dir])
                              else
                                return s:worktree_for_dir[dir]
                              endif

FUNCTION  <SNR>160_CheckWithLSP()
Called 9 times
Total time:   0.005805
 Self time:   0.001438

count  total (s)   self (s)
    9              0.000048     let l:buffer = a:details.buffer
    9              0.000082     let l:info = get(g:ale_buffer_info, l:buffer)
                            
    9              0.000041     if empty(l:info)
                                    return
                                endif
                            
    9              0.000045     let l:id = a:details.connection_id
                            
                                " Register a callback now for handling errors now.
    9              0.000087     let l:Callback = function('ale#lsp_linter#HandleLSPResponse')
    9   0.000490   0.000146     call ale#lsp#RegisterCallback(l:id, l:Callback)
                            
                                " Remember the linter this connection is for.
    9              0.000074     let s:lsp_linter_map[l:id] = a:linter.name
                            
    9              0.000038     if a:linter.lsp is# 'tsserver'
    9   0.001292   0.000137         let l:message = ale#lsp#tsserver_message#Geterr(l:buffer)
    9   0.002587   0.000171         let l:notified = ale#lsp#Send(l:id, l:message) != 0
                            
    9              0.000024         if l:notified
    9   0.000574   0.000123             call ale#engine#MarkLinterActive(l:info, a:linter)
    9              0.000012         endif
    9              0.000009     else
                                    let l:notified = ale#lsp#NotifyForChanges(l:id, l:buffer)
                                endif
                            
                                " If this was a file save event, also notify the server of that.
    9              0.000060     if a:linter.lsp isnot# 'tsserver'&& getbufvar(l:buffer, 'ale_save_event_fired', 0)
                                    let l:save_message = ale#lsp#message#DidSave(l:buffer)
                                    let l:notified = ale#lsp#Send(l:id, l:save_message) != 0
                                endif

FUNCTION  nerdtree#runningWindows()
Called 16 times
Total time:   0.000261
 Self time:   0.000261

count  total (s)   self (s)
   16              0.000245     return has("win16") || has("win32") || has("win64")

FUNCTION  ale#util#GetFunction()
Called 76 times
Total time:   0.001342
 Self time:   0.001342

count  total (s)   self (s)
   76              0.000526     if type(a:string_or_ref) is v:t_string
    2              0.000011         return function(a:string_or_ref)
                                endif
                            
   74              0.000204     return a:string_or_ref

FUNCTION  <SNR>158_FindHistoryItem()
Called 4 times
Total time:   0.000406
 Self time:   0.000331

count  total (s)   self (s)
                                " Search backwards to find a matching job ID. IDs might be recycled,
                                " so finding the last one should be good enough.
   16   0.000177   0.000102     for l:obj in reverse(ale#history#Get(a:buffer))
   16              0.000099         if l:obj.job_id == a:job_id
    4              0.000018             return l:obj
                                    endif
   12              0.000016     endfor
                            
                                return {}

FUNCTION  ale#job#SendRaw()
Called 18 times
Total time:   0.001132
 Self time:   0.001132

count  total (s)   self (s)
   18              0.000137     if has('nvim')
   18              0.000560         call jobsend(a:job_id, a:string)
   18              0.000041     else
                                    let l:job = s:job_map[a:job_id].job
                            
                                    if ch_status(l:job) is# 'open'
                                        call ch_sendraw(job_getchannel(l:job), a:string)
                                    endif
                                endif

FUNCTION  ale#job#PrepareCommand()
Called 18 times
Total time:   0.003474
 Self time:   0.002805

count  total (s)   self (s)
   18   0.000914   0.000244     let l:wrapper = ale#Var(a:buffer, 'command_wrapper')
                            
                                " The command will be executed in a subshell. This fixes a number of
                                " issues, including reading the PATH variables correctly, %PATHEXT%
                                " expansion on Windows, etc.
                                "
                                " NeoVim handles this issue automatically if the command is a String,
                                " but we'll do this explicitly, so we use the same exact command for both
                                " versions.
   18              0.000222     let l:command = !empty(l:wrapper) ? s:PrepareWrappedCommand(l:wrapper, a:command) : a:command
                            
                                " If a custom shell is specified, use that.
   18              0.000099     if exists('g:ale_shell')
                                    let l:shell_arguments = get(g:, 'ale_shell_arguments', &shellcmdflag)
                            
                                    return split(g:ale_shell) + split(l:shell_arguments) + [l:command]
                                endif
                            
   18              0.000132     if has('win32')
                                    return 'cmd /s/c "' . l:command . '"'
                                endif
                            
   18              0.000550     if &shell =~? 'fish$\|pwsh$'
                                    return ['/bin/sh', '-c', l:command]
                                endif
                            
   18              0.000744     return split(&shell) + split(&shellcmdflag) + [l:command]

FUNCTION  FugitiveHead()
Called 102 times
Total time:   0.185407
 Self time:   0.003522

count  total (s)   self (s)
  102   0.002439   0.001277   let dir = FugitiveGitDir(a:0 > 1 ? a:2 : -1)
  102              0.000406   if empty(dir)
                                return ''
                              endif
  102   0.182119   0.001396   return fugitive#Head(a:0 ? a:1 : 0, dir)

FUNCTION  ale#job#Start()
Called 9 times
Total time:   0.037628
 Self time:   0.037512

count  total (s)   self (s)
    9   0.000241   0.000125     call ale#job#ValidateArguments(a:command, a:options)
                            
    9              0.000076     let l:job_info = copy(a:options)
    9              0.000034     let l:job_options = {}
                            
    9              0.000051     if has('nvim')
    9              0.000047         if has_key(a:options, 'out_cb')
    9              0.000105             let l:job_options.on_stdout = function('s:NeoVimCallback')
    9              0.000039             let l:job_info.out_cb_line = ''
    9              0.000013         endif
                            
    9              0.000046         if has_key(a:options, 'err_cb')
                                        let l:job_options.on_stderr = function('s:NeoVimCallback')
                                        let l:job_info.err_cb_line = ''
                                    endif
                            
    9              0.000041         if has_key(a:options, 'exit_cb')
    9              0.000092             let l:job_options.on_exit = function('s:NeoVimCallback')
    9              0.000014         endif
                            
    9              0.034752         let l:job_info.job = jobstart(a:command, l:job_options)
    9              0.000172         let l:job_id = l:job_info.job
    9              0.000029     else
                                    let l:job_options = {   'in_mode': l:job_info.mode,   'out_mode': l:job_info.mode,   'err_mode': l:job_info.mode,}
                            
                                    if has_key(a:options, 'out_cb')
                                        let l:job_options.out_cb = function('s:VimOutputCallback')
                                    endif
                            
                                    if has_key(a:options, 'err_cb')
                                        let l:job_options.err_cb = function('s:VimErrorCallback')
                                    endif
                            
                                    if has_key(a:options, 'exit_cb')
                                        " Set a close callback to which simply calls job_status()
                                        " when the channel is closed, which can trigger the exit callback
                                        " earlier on.
                                        let l:job_options.close_cb = function('s:VimCloseCallback')
                                        let l:job_options.exit_cb = function('s:VimExitCallback')
                                    endif
                            
                                    " Use non-blocking writes for Vim versions that support the option.
                                    if has('patch-8.1.350')
                                        let l:job_options.noblock = 1
                                    endif
                            
                                    " Vim 8 will read the stdin from the file's buffer.
                                    let l:job_info.job = job_start(a:command, l:job_options)
                                    let l:job_id = ale#job#ParseVim8ProcessID(string(l:job_info.job))
                                endif
                            
    9              0.000033     if l:job_id > 0
                                    " Store the job in the map for later only if we can get the ID.
    9              0.000115         let s:job_map[l:job_id] = l:job_info
    9              0.000016     endif
                            
    9              0.000159     return l:job_id

FUNCTION  <SNR>153_HandleExit()
Called 2 times
Total time:   0.016630
 Self time:   0.000354

count  total (s)   self (s)
    2              0.000024     let l:buffer_info = get(g:ale_buffer_info, a:buffer)
                            
    2              0.000010     if empty(l:buffer_info)
                                    return
                                endif
                            
    2              0.000010     let l:linter = a:job_info.linter
    2              0.000011     let l:executable = a:job_info.executable
    2              0.000011     let l:next_chain_index = a:job_info.next_chain_index
                            
                                " Remove this job from the list.
    2   0.000064   0.000032     call ale#engine#MarkLinterInactive(l:buffer_info, l:linter.name)
                            
                                " Stop here if we land in the handle for a job completing if we're in
                                " a sandbox.
    2   0.000086   0.000021     if ale#util#InSandbox()
                                    return
                                endif
                            
    2              0.000033     if has('nvim') && !empty(a:output) && empty(a:output[-1])
                                    call remove(a:output, -1)
                                endif
                            
    2              0.000017     if l:next_chain_index < len(get(l:linter, 'command_chain', []))
                                    let [l:command, l:options] = ale#engine#ProcessChain(   a:buffer,   l:executable,   l:linter,   l:next_chain_index,   a:output,)
                            
                                    call s:RunJob(l:command, l:options)
                            
                                    return
                                endif
                            
    2              0.000003     try
    2   0.003155   0.000051         let l:loclist = ale#util#GetFunction(l:linter.callback)(a:buffer, a:output)
                                " Handle the function being unknown, or being deleted.
    2              0.000005     catch /E700/
                                    let l:loclist = []
                                endtry
                            
    2   0.013107   0.000032     call ale#engine#HandleLoclist(l:linter.name, a:buffer, l:loclist, 0)

FUNCTION  fugitive#CommonDir()
Called 204 times
Total time:   0.010881
 Self time:   0.010881

count  total (s)   self (s)
  204              0.001015   if empty(a:dir)
                                return ''
                              endif
  204              0.001171   if !has_key(s:commondirs, a:dir)
                                if getfsize(a:dir . '/HEAD') < 10
                                  let s:commondirs[a:dir] = ''
                                elseif filereadable(a:dir . '/commondir')
                                  let dir = get(readfile(a:dir . '/commondir', 1), 0, '')
                                  if dir =~# '^/\|^\a:/'
                                    let s:commondirs[a:dir] = dir
                                  else
                                    let s:commondirs[a:dir] = simplify(a:dir . '/' . dir)
                                  endif
                                else
                                  let s:commondirs[a:dir] = a:dir
                                endif
                              endif
  204              0.001034   return s:commondirs[a:dir]

FUNCTION  airline#parts#ffenc()
Called 102 times
Total time:   0.005047
 Self time:   0.005047

count  total (s)   self (s)
  102              0.000902   let expected = get(g:, 'airline#parts#ffenc#skip_expected_string', '')
  102              0.000517   let bomb     = &l:bomb ? '[BOM]' : ''
  102              0.001458   let ff       = strlen(&ff) ? '['.&ff.']' : ''
  102              0.000917   if expected is# &fenc.bomb.ff
                                return ''
                              else
  102              0.000673     return &fenc.bomb.ff
                              endif

FUNCTION  ale#Var()
Called 255 times
Total time:   0.007916
 Self time:   0.007916

count  total (s)   self (s)
  255              0.001760     let l:full_name = 'ale_' . a:variable_name
  255              0.003121     let l:vars = getbufvar(str2nr(a:buffer), '', {})
                            
  255              0.002377     return get(l:vars, l:full_name, g:[l:full_name])

FUNCTION  <SNR>135_CountOccurencesInEOL()
Called 1 time
Total time:   0.000113
 Self time:   0.000056

count  total (s)   self (s)
    1              0.000005   let l:occurence = 0
                            
                              " iterate through all items in the given line
    2   0.000081   0.000024   for item in s:SynEOL(a:lnum, a:offset)
                                " if the syntax-item equals the given str increment the counter
                                " `==?` is a case insensitive equal operation
    1              0.000005     if item == a:str
                                  let l:occurence += 1
                                endif
    1              0.000001   endfor
                            
                              " return the accumulated count of occurences
    1              0.000002   return l:occurence

FUNCTION  ale#linter#GetCommand()
Called 18 times
Total time:   0.011345
 Self time:   0.000530

count  total (s)   self (s)
   18              0.000214     let l:Command = has_key(a:linter, 'command_callback')   ? function(a:linter.command_callback)   : a:linter.command
                            
   18   0.011043   0.000227     return type(l:Command) is v:t_func   ? l:Command(a:buffer)   : l:Command

FUNCTION  airline#util#ignore_buf()
Called 102 times
Total time:   0.005626
 Self time:   0.005626

count  total (s)   self (s)
  102              0.001611   let pat = '\c\v'. get(g:, 'airline#ignore_bufadd_pat', ''). get(g:, 'airline#extensions#tabline#ignore_bufadd_pat',  'gundo|undotree|vimfiler|tagbar|nerd_tree|startify|!')
  102              0.003841   return match(a:name, pat) > -1

FUNCTION  <SNR>153_RemoveProblemsForDisabledLinters()
Called 9 times
Total time:   0.001126
 Self time:   0.001126

count  total (s)   self (s)
                                " Figure out which linters are still enabled, and remove
                                " problems for linters which are no longer enabled.
                                " Problems from other sources will be kept.
    9              0.000046     let l:name_map = {}
                            
   54              0.000141     for l:linter in a:linters
   45              0.000245         let l:name_map[l:linter.name] = 1
   45              0.000083     endfor
                            
    9              0.000472     call filter(   get(g:ale_buffer_info[a:buffer], 'loclist', []),   'get(v:val, ''from_other_source'') || get(l:name_map, get(v:val, ''linter_name''))',)

FUNCTION  <SNR>77_Highlight_Matching_Pair()
Called 187 times
Total time:   0.056029
 Self time:   0.056029

count  total (s)   self (s)
                              " Remove any previous match.
  187              0.002060   if exists('w:paren_hl_on') && w:paren_hl_on
   10              0.000056     silent! call matchdelete(3)
   10              0.000039     let w:paren_hl_on = 0
   10              0.000015   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
  187              0.001880   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
  187              0.001307   let c_lnum = line('.')
  187              0.001121   let c_col = col('.')
  187              0.000550   let before = 0
                            
  187              0.001120   let text = getline(c_lnum)
  187              0.007373   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
  187              0.001032   if empty(matches)
                                let [c_before, c] = ['', '']
                              else
  187              0.001813     let [c_before, c] = matches[1:2]
  187              0.000290   endif
  187              0.006071   let plist = split(&matchpairs, '.\zs[:,]')
  187              0.001507   let i = index(plist, c)
  187              0.000557   if i < 0
                                " not found, in Insert mode try character before the cursor
  171              0.001453     if c_col > 1 && (mode() == 'i' || mode() == 'R')
  154              0.000954       let before = strlen(c_before)
  154              0.000531       let c = c_before
  154              0.000852       let i = index(plist, c)
  154              0.000241     endif
  171              0.000391     if i < 0
                                  " not found, nothing to do
  171              0.000333       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
   16              0.000039   if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
   16              0.000049     let s_flags = 'nbW'
   16              0.000046     let c2 = c
   16              0.000069     let c = plist[i - 1]
   16              0.000023   endif
   16              0.000050   if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
   16              0.000035   if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
   16              0.000155   if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
                              else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial.
   16              0.000113     let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
   16              0.000035     try
   16              0.002902       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
   16              0.000039     catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
   16              0.000015   endif
                            
                              " Limit the search to lines visible in the window.
   16              0.000118   let stoplinebottom = line('w$')
   16              0.000098   let stoplinetop = line('w0')
   16              0.000049   if i % 2 == 0
                                let stopline = stoplinebottom
                              else
   16              0.000071     let stopline = stoplinetop
   16              0.000022   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
   16              0.000104   if mode() == 'i' || mode() == 'R'
   16              0.000183     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
   16              0.000028   else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
   16              0.000029   try
   16              0.009299     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
   16              0.000054   catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
   16              0.000048   if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
   16              0.000076   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
   10              0.000057     if exists('*matchaddpos')
   10              0.000434       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
   10              0.000019     else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
   10              0.000037     let w:paren_hl_on = 1
   10              0.000013   endif

FUNCTION  ale#cursor#EchoCursorWarning()
Called 15 times
Total time:   0.013984
 Self time:   0.001950

count  total (s)   self (s)
   15              0.000115     let l:buffer = bufnr('')
                            
   15              0.000058     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
                                endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
   15              0.000076     if mode(1) isnot# 'n'
    6              0.000008         return
                                endif
                            
    9   0.002782   0.000140     if ale#ShouldDoNothing(l:buffer)
                                    return
                                endif
                            
    9   0.002490   0.000201     let [l:info, l:loc] = ale#util#FindItemAtCursor(l:buffer)
                            
    9              0.000028     if g:ale_echo_cursor
    9              0.000041         if !empty(l:loc)
    8   0.000388   0.000120             let l:format = ale#Var(l:buffer, 'echo_msg_format')
    8   0.001872   0.000183             let l:msg = ale#GetLocItemMessage(l:loc, l:format)
    8   0.005401   0.000256             call ale#cursor#TruncatedEcho(l:msg)
    8              0.000083             let l:info.echoed = 1
    8              0.000038         elseif get(l:info, 'echoed')
                                        " We'll only clear the echoed message when moving off errors once,
                                        " so we don't continually clear the echo line.
    1              0.000044             execute 'echo'
    1              0.000010             let l:info.echoed = 0
    1              0.000002         endif
    9              0.000011     endif
                            
    9              0.000028     if g:ale_cursor_detail
                                    if !empty(l:loc)
                                        call s:ShowCursorDetailForItem(l:loc, {'stay_here': 1})
                                    else
                                        call ale#preview#CloseIfTypeMatches('ale-preview')
                                    endif
                                endif

FUNCTION  <SNR>162_SendMessageData()
Called 18 times
Total time:   0.001955
 Self time:   0.000824

count  total (s)   self (s)
   18              0.000114     if has_key(a:conn, 'job_id')
   18   0.001397   0.000266         call ale#job#SendRaw(a:conn.job_id, a:data)
   18              0.000136     elseif has_key(a:conn, 'channel_id') && ale#socket#IsOpen(a:conn.channel_id)
                                    " Send the message to the server
                                    call ale#socket#Send(a:conn.channel_id, a:data)
                                else
                                    return 0
                                endif
                            
   18              0.000029     return 1

FUNCTION  airline#update_tabline()
Called 18 times
Total time:   0.000276
 Self time:   0.000276

count  total (s)   self (s)
   18              0.000142   if get(g:, 'airline_statusline_ontop', 0)
                                call airline#extensions#tabline#redraw()
                              endif

FUNCTION  ale#handlers#tsserver#GetProjectRoot()
Called 9 times
Total time:   0.003576
 Self time:   0.000266

count  total (s)   self (s)
    9   0.003457   0.000147     let l:tsconfig_file = ale#path#FindNearestFile(a:buffer, 'tsconfig.json')
                            
    9              0.000096     return !empty(l:tsconfig_file) ? fnamemodify(l:tsconfig_file, ':h') : ''

FUNCTION  airline#parts#get()
Called 204 times
Total time:   0.001849
 Self time:   0.001849

count  total (s)   self (s)
  204              0.001643   return get(s:parts, a:key, {})

FUNCTION  ale#lsp_linter#StartLSP()
Called 9 times
Total time:   0.037757
 Self time:   0.000936

count  total (s)   self (s)
    9              0.000039     let l:command = ''
    9              0.000026     let l:address = ''
    9   0.004748   0.000162     let l:root = ale#lsp_linter#FindProjectRoot(a:buffer, a:linter)
                            
    9              0.000052     if empty(l:root) && a:linter.lsp isnot# 'tsserver'
                                    " If there's no project root, then we can't check files with LSP,
                                    " unless we are using tsserver, which doesn't use project roots.
                                    return 0
                                endif
                            
    9              0.000099     let l:options = {   'buffer': a:buffer,   'linter': a:linter,   'callback': a:Callback,   'root': l:root,}
                            
    9              0.000036     if a:linter.lsp is# 'socket'
                                    let l:address = ale#linter#GetAddress(a:buffer, a:linter)
                            
                                    return s:StartWithAddress(l:options, l:address)
                                endif
                            
    9   0.005073   0.000125     let l:executable = ale#linter#GetExecutable(a:buffer, a:linter)
                            
    9   0.027441   0.000154     return s:StartIfExecutable(l:options, l:executable)

FUNCTION  airline#parts#paste()
Called 102 times
Total time:   0.000726
 Self time:   0.000726

count  total (s)   self (s)
  102              0.000638   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  <SNR>123_IdentifierFinishedOperations()
Called 85 times
Total time:   0.197096
 Self time:   0.012428

count  total (s)   self (s)
   85   0.185739   0.001070   if !s:Pyeval( 'base.CurrentIdentifierFinished()' )
   83              0.000444     return
                              endif
    2              0.010680   exec s:python_command "ycm_state.OnCurrentIdentifierFinished()"
    2              0.000024   let s:force_semantic = 0
    2              0.000018   let s:completion = s:default_completion

FUNCTION  ale#lsp#NotifyForChanges()
Called 9 times
Total time:   0.007565
 Self time:   0.001402

count  total (s)   self (s)
    9              0.000149     let l:conn = get(s:connections, a:conn_id, {})
    9              0.000030     let l:notified = 0
                            
    9              0.000074     if !empty(l:conn) && has_key(l:conn.open_documents, a:buffer)
    9              0.000067         let l:new_tick = getbufvar(a:buffer, 'changedtick')
                            
    9              0.000049         if l:conn.open_documents[a:buffer] < l:new_tick
    9              0.000024             if l:conn.is_tsserver
    9   0.002973   0.000507                 let l:message = ale#lsp#tsserver_message#Change(a:buffer)
    9              0.000026             else
                                            let l:message = ale#lsp#message#DidChange(a:buffer)
                                        endif
                            
    9   0.003865   0.000168             call ale#lsp#Send(a:conn_id, l:message)
    9              0.000087             let l:conn.open_documents[a:buffer] = l:new_tick
    9              0.000035             let l:notified = 1
    9              0.000015         endif
    9              0.000008     endif
                            
    9              0.000023     return l:notified

FUNCTION  ale#util#BinarySearch()
Called 9 times
Total time:   0.001728
 Self time:   0.001728

count  total (s)   self (s)
    9              0.000040     let l:min = 0
    9              0.000058     let l:max = len(a:loclist) - 1
                            
   15              0.000035     while 1
   15              0.000047         if l:max < l:min
    1              0.000001             return -1
                                    endif
                            
   14              0.000065         let l:mid = (l:min + l:max) / 2
   14              0.000077         let l:item = a:loclist[l:mid]
                            
                                    " Binary search for equal buffers, equal lines, then near columns.
   14              0.000052         if l:item.bufnr < a:buffer
                                        let l:min = l:mid + 1
                                    elseif l:item.bufnr > a:buffer
                                        let l:max = l:mid - 1
                                    elseif l:item.lnum < a:line
    6              0.000020             let l:min = l:mid + 1
    6              0.000015         elseif l:item.lnum > a:line
                                        let l:max = l:mid - 1
                                    else
                                        " This part is a small sequential search.
    8              0.000051             let l:index = l:mid
                            
                                        " Search backwards to find the first problem on the line.
    8              0.000074             while l:index > 0&& a:loclist[l:index - 1].bufnr == a:buffer&& a:loclist[l:index - 1].lnum == a:line
                                            let l:index -= 1
                                        endwhile
                            
                                        " Find the last problem on or before this column.
   10              0.000100             while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col <= a:column
    2              0.000008                 let l:index += 1
    2              0.000004             endwhile
                            
                                        " Scan forwards to find the last item on the column for the item
                                        " we found, which will have the most serious problem.
    8              0.000049             let l:item_column = a:loclist[l:index].col
                            
    8              0.000072             while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col == l:item_column
                                            let l:index += 1
                                        endwhile
                            
    8              0.000021             return l:index
                                    endif
    6              0.000008     endwhile

FUNCTION  airline#parts#readonly()
Called 110 times
Total time:   0.009973
 Self time:   0.004347

count  total (s)   self (s)
                              " only consider regular buffers (e.g. ones that represent actual files,
                              " but not special ones like e.g. NERDTree)
  110   0.007667   0.002041   if !empty(&buftype) || airline#util#ignore_buf(bufname('%'))
    8              0.000018     return ''
                              endif
  102              0.000588   if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
                              else
  102              0.000363     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  UltiSnips#TrackChange()
Called 179 times
Total time:   3.407786
 Self time:   3.407786

count  total (s)   self (s)
  179              3.407556     exec g:_uspy "UltiSnips_Manager._track_change()"

FUNCTION  <SNR>95_get_hunks_gitgutter()
Called 102 times
Total time:   0.010850
 Self time:   0.002786

count  total (s)   self (s)
  102   0.003216   0.001490   if !get(g:, 'gitgutter_enabled', 0) || s:is_branch_empty()
                                return ''
                              endif
  102   0.007186   0.000849   return GitGutterGetHunkSummary()

FUNCTION  <SNR>99_airline_ale_count()
Called 56 times
Total time:   0.000305
 Self time:   0.000305

count  total (s)   self (s)
   56              0.000252   return a:cnt ? a:symbol. a:cnt : ''

FUNCTION  GetTypescriptIndent()
Called 1 time
Total time:   0.001833
 Self time:   0.000723

count  total (s)   self (s)
    1              0.000011   let b:js_cache = get(b:,'js_cache',[0,0,0])
                              " Get the current line.
    1              0.000007   call cursor(v:lnum,1)
    1              0.000006   let l:line = getline('.')
                              " use synstack as it validates syn state and works in an empty line
    1              0.000077   let s:stack = synstack(v:lnum,1)
    1              0.000010   let syns = synIDattr(get(s:stack,-1),'name')
                            
                              " start with strings,comments,etc.
    1              0.000018   if syns =~? s:syng_com
                            	if l:line =~ '^\s*\*'
                            	  return cindent(v:lnum)
                            	elseif l:line !~ '^\s*\/[/*]'
                            	  return -1
                            	endif
                              elseif syns =~? s:syng_str && l:line !~ '^[''"]'
                            	if b:js_cache[0] == v:lnum - 1 && s:Balanced(v:lnum-1)
                            	  let b:js_cache[0] = v:lnum
                            	endif
                            	return -1
                              endif
    1   0.000108   0.000021   let l:lnum = s:PrevCodeLine(v:lnum - 1)
    1              0.000003   if !l:lnum
                            	return
                              endif
                            
    1              0.000016   let l:line = substitute(l:line,'^\s*','','')
    1              0.000005   if l:line[:1] == '/*'
                            	let l:line = substitute(l:line,'^\%(\/\*.\{-}\*\/\s*\)*','','')
                              endif
    1              0.000008   if l:line =~ '^\/[/*]'
                            	let l:line = ''
                              endif
                            
                              " the containing paren, bracket, or curly. Many hacks for performance
    1              0.000012   let idx = index([']',')','}'],l:line[0])
    1              0.000013   if b:js_cache[0] >= l:lnum && b:js_cache[0] < v:lnum && (b:js_cache[0] > l:lnum || s:Balanced(l:lnum))
                            	call call('cursor',b:js_cache[1:])
                              else
    1   0.000079   0.000056 	let [s:looksyn, s:free, top] = [v:lnum - 1, 1, (!indent(l:lnum) && s:syn_at(l:lnum,1) !~? s:syng_str) * l:lnum]
    1              0.000004 	if idx + 1
                            	  call s:GetPair(['\[','(','{'][idx],'])}'[idx],'bW','s:skip_func()',2000,top)
                            	elseif getline(v:lnum) !~ '^\S' && syns =~? 'block'
                            	  call s:GetPair('{','}','bW','s:skip_func()',2000,top)
                            	else
    1   0.000295   0.000028 	  call s:alternatePair(top)
    1              0.000002 	endif
    1              0.000002   endif
                            
    1              0.000017   let b:js_cache = [v:lnum] + (line('.') == v:lnum ? [0,0] : getpos('.')[1:2])
    1              0.000006   let num = b:js_cache[1]
                            
    1   0.000030   0.000025   let [s:W, isOp, bL, switch_offset] = [s:sw(),0,0,0]
    1              0.000006   if !num || s:IsBlock()
    1              0.000006 	let ilnum = line('.')
    1   0.000316   0.000028 	let pline = s:save_pos('s:Trim',l:lnum)
    1              0.000010 	if num && s:looking_at() == ')' && s:GetPair('(', ')', 'bW', s:skip_expr, 100) > 0
                            	  let num = ilnum == num ? line('.') : num
                            	  if idx < 0 && s:previous_token() ==# 'switch' && s:previous_token() != '.'
                            		if &cino !~ ':'
                            		  let switch_offset = s:W
                            		else
                            		  let cinc = matchlist(&cino,'.*:\zs\(-\)\=\(\d*\)\(\.\d\+\)\=\(s\)\=\C')
                            		  let switch_offset = max([cinc[0] is '' ? 0 : (cinc[1].1) * ((strlen(cinc[2].cinc[3]) ? str2nr(cinc[2].str2nr(cinc[3][1])) : 10) * (cinc[4] is '' ? 1 : s:W)) / 10, -indent(num)])
                            		endif
                            		if pline[-1:] != '.' && l:line =~# '^\%(default\|case\)\>'
                            		  return indent(num) + switch_offset
                            		endif
                            	  endif
                            	endif
    1              0.000012 	if idx < 0 && pline !~ '[{;]$'
    1              0.000010 	  if pline =~# ':\@<!:$'
                            		call cursor(l:lnum,strlen(pline))
                            		let isOp = s:tern_col(b:js_cache[1:2]) * s:W
                            	  else
    1   0.000109   0.000060 		let isOp = (l:line =~# s:opfirst || s:continues(l:lnum,pline)) * s:W
    1              0.000002 	  endif
    1   0.000414   0.000024 	  let bL = s:iscontOne(l:lnum,b:js_cache[1],isOp)
    1              0.000005 	  let bL -= (bL && l:line[0] == '{') * s:W
    1              0.000002 	endif
    1              0.000001   endif
                            
                              " main return
    1              0.000005   if idx + 1 || l:line[:1] == '|}'
                            	return indent(num)
                              elseif num
                            	return indent(num) + s:W + switch_offset + bL + isOp
                              endif
    1              0.000002   return bL + isOp

FUNCTION  ale#util#GetItemPriority()
Called 87 times
Total time:   0.003679
 Self time:   0.003679

count  total (s)   self (s)
   87              0.000384     if a:item.type is# 'I'
                                    return g:ale#util#info_priority
                                endif
                            
   87              0.000276     if a:item.type is# 'W'
                                    if get(a:item, 'sub_type', '') is# 'style'
                                        return g:ale#util#style_warning_priority
                                    endif
                            
                                    return g:ale#util#warning_priority
                                endif
                            
   87              0.000643     if get(a:item, 'sub_type', '') is# 'style'
                                    return g:ale#util#style_error_priority
                                endif
                            
   87              0.000230     return g:ale#util#error_priority

FUNCTION  ale#cursor#TruncatedEcho()
Called 8 times
Total time:   0.005145
 Self time:   0.005119

count  total (s)   self (s)
    8              0.000055     let l:message = a:original_message
                                " Change tabs to spaces.
    8              0.000137     let l:message = substitute(l:message, "\t", ' ', 'g')
                                " Remove any newlines in the message.
    8              0.000088     let l:message = substitute(l:message, "\n", '', 'g')
                            
                                " We need to remember the setting for shortmess and reset it again.
    8              0.000052     let l:shortmess_options = &l:shortmess
                            
    8              0.000018     try
    8              0.000062         let l:cursor_position = getpos('.')
                            
                                    " The message is truncated and saved to the history.
    8   0.000141   0.000125         silent! setlocal shortmess+=T
                            
    8              0.000016         try
    8              0.003830             exec "norm! :echomsg l:message\n"
    8              0.000030         catch /^Vim\%((\a\+)\)\=:E523/
                                        " Fallback into manual truncate (#1987)
                                        let l:winwidth = winwidth(0)
                            
                                        if l:winwidth < strdisplaywidth(l:message)
                                            " Truncate message longer than window width with trailing '...'
                                            let l:message = l:message[:l:winwidth - 4] . '...'
                                        endif
                            
                                        exec 'echomsg l:message'
                                    endtry
                            
                                    " Reset the cursor position if we moved off the end of the line.
                                    " Using :norm and :echomsg can move the cursor off the end of the
                                    " line.
    8              0.000082         if l:cursor_position != getpos('.')
                                        call setpos('.', l:cursor_position)
                                    endif
    8              0.000014     finally
    8   0.000159   0.000149         let &l:shortmess = l:shortmess_options
    8              0.000020     endtry

FUNCTION  nerdtree#has_opt()
Called 8 times
Total time:   0.000067
 Self time:   0.000067

count  total (s)   self (s)
    8              0.000060     return has_key(a:options, a:name) && a:options[a:name] == 1

FUNCTION  ale#path#FindNearestFile()
Called 72 times
Total time:   0.034157
 Self time:   0.034157

count  total (s)   self (s)
   72              0.008272     let l:buffer_filename = fnamemodify(bufname(a:buffer), ':p')
   72              0.000898     let l:buffer_filename = fnameescape(l:buffer_filename)
                            
   72              0.020641     let l:relative_path = findfile(a:filename, l:buffer_filename . ';')
                            
   72              0.000468     if !empty(l:relative_path)
   36              0.003171         return fnamemodify(l:relative_path, ':p')
                                endif
                            
   36              0.000065     return ''

FUNCTION  <SNR>174_WinFindBuf()
Called 20 times
Total time:   0.000338
 Self time:   0.000338

count  total (s)   self (s)
   20              0.000302     return exists('*win_findbuf') ? win_findbuf(str2nr(a:buffer)) : [0]

FUNCTION  airline#highlighter#exec()
Called 374 times
Total time:   0.226791
 Self time:   0.061304

count  total (s)   self (s)
  374              0.001460   if pumvisible()
                                return
                              endif
  374              0.001330   let colors = a:colors
  374              0.000952   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
                              endif
  374   0.120194   0.005584   let old_hi = airline#highlighter#get_highlight(a:group)
  374              0.012130   if len(colors) == 4
  168              0.000887     call add(colors, '')
  168              0.000223   endif
  374              0.001328   if g:airline_gui_mode ==# 'gui'
                                let new_hi = [colors[0], colors[1], '', '', colors[4]]
                              else
  374              0.005690     let new_hi = ['', '', printf("%s", colors[2]), printf("%s", colors[3]), colors[4]]
  374              0.000563   endif
  374   0.028270   0.004483   let colors = s:CheckDefined(colors)
  374   0.014981   0.004723   if old_hi != new_hi || !s:hl_group_exists(a:group)
   70   0.018177   0.001346     let cmd = printf('hi %s%s', a:group, s:GetHiCmd(colors))
   70              0.001634     exe cmd
   70              0.000496     if has_key(s:hl_groups, a:group)
   70              0.000424       let s:hl_groups[a:group] = colors
   70              0.000104     endif
   70              0.000067   endif

FUNCTION  ale#engine#RunLinters()
Called 9 times
Total time:   0.163550
 Self time:   0.004218

count  total (s)   self (s)
                                " Initialise the buffer information if needed.
    9   0.000388   0.000168     let l:new_buffer = ale#engine#InitBufferInfo(a:buffer)
    9   0.004745   0.000160     call s:StopCurrentJobs(a:buffer, a:should_lint_file)
    9   0.001304   0.000178     call s:RemoveProblemsForDisabledLinters(a:buffer, a:linters)
                            
                                " We can only clear the results if we aren't checking the buffer.
    9   0.000357   0.000129     let l:can_clear_results = !ale#engine#IsCheckingBuffer(a:buffer)
                            
    9   0.001419   0.000974     silent doautocmd <nomodeline> User ALELintPre
                            
   54              0.000288     for l:linter in a:linters
                                    " Only run lint_file linters if we should.
   45              0.000203         if !l:linter.lint_file || a:should_lint_file
   45   0.153548   0.000817             if s:RunLinter(a:buffer, l:linter)
                                            " If a single linter ran, we shouldn't clear everything.
   18              0.000099                 let l:can_clear_results = 0
   18              0.000030             endif
   45              0.000057         else
                                        " If we skipped running a lint_file linter still in the list,
                                        " we shouldn't clear everything.
                                        let l:can_clear_results = 0
                                    endif
   45              0.000067     endfor
                            
                                " Clear the results if we can. This needs to be done when linters are
                                " disabled, or ALE itself is disabled.
    9              0.000030     if l:can_clear_results
                                    call ale#engine#SetResults(a:buffer, [])
                                elseif l:new_buffer
                                    call s:AddProblemsFromOtherBuffers(a:buffer, a:linters)
                                endif

FUNCTION  airline#themes#get_highlight()
Called 336 times
Total time:   0.125893
 Self time:   0.006151

count  total (s)   self (s)
  336   0.125612   0.005870   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  <SNR>123_OnTextChangedInsertMode()
Called 85 times
Total time:   2.086566
 Self time:   0.223469

count  total (s)   self (s)
   85   0.013864   0.001249   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
   85              0.000217   if s:completion_stopped
                                let s:completion_stopped = 0
                                let s:completion = s:default_completion
                                return
                              endif
                            
   85   0.198149   0.001053   call s:IdentifierFinishedOperations()
                            
                              " We have to make sure we correctly leave semantic mode even when the user
                              " inserts something like a "operator[]" candidate string which fails
                              " CurrentIdentifierFinished check.
   85              0.000964   if s:force_semantic && !s:Pyeval( 'base.LastEnteredCharIsIdentifierChar()' )
                                let s:force_semantic = 0
                              endif
                            
   85   0.117708   0.003134   if &completefunc == "youcompleteme#CompleteFunc" && ( g:ycm_auto_trigger || s:force_semantic ) && !s:InsideCommentOrStringAndShouldStop() && !s:OnBlankLine()
                                " Immediately call previous completion to avoid flickers.
   84   0.006178   0.001542     call s:Complete()
   84   1.535128   0.000953     call s:InvokeCompletion()
   84              0.000172   endif
                            
   85              0.208471   exec s:python_command "ycm_state.OnCursorMoved()"
                            
   85              0.000757   if g:ycm_autoclose_preview_window_after_completion
                                call s:ClosePreviewWindowIfNeeded()
                              endif

FUNCTION  airline#extensions#whitespace#check()
Called 102 times
Total time:   0.032896
 Self time:   0.026874

count  total (s)   self (s)
  102              0.000829   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
  102              0.001238   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
                              endif
  102              0.002553   let skip_check_ft = extend(s:skip_check_ft, get(g:, 'airline#extensions#whitespace#skip_indent_check_ft', {}), 'force')
                            
  102              0.000688   if !exists('b:airline_whitespace_check')
                                let b:airline_whitespace_check = ''
                                let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
                                let trailing = 0
                                let check = 'trailing'
                                if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                  try
                                    let regexp = get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$')
                                    let trailing = search(regexp, 'nw')
                                  catch
                                    call airline#util#warning(printf('Whitespace: error occurred evaluating "%s"', regexp))
                                    echomsg v:exception
                                    return ''
                                  endtry
                                endif
                            
                                let mixed = 0
                                let check = 'indent'
                                if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                  let mixed = s:check_mixed_indent()
                                endif
                            
                                let mixed_file = ''
                                let check = 'mixed-indent-file'
                                if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                  let mixed_file = s:check_mixed_indent_file()
                                endif
                            
                                let long = 0
                                if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
                                endif
                            
                                let conflicts = 0
                                if index(checks, 'conflicts') > -1
                                  let conflicts = s:conflict_marker()
                                endif
                            
                                if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file) || conflicts != 0
                                  let b:airline_whitespace_check = s:symbol
                                  if strlen(s:symbol) > 0
                                    let space = (g:airline_symbols.space)
                                  else
                                    let space = ''
                                  endif
                            
                                  if s:show_message
                                    if trailing != 0
                                      let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
                                      let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
                                    endif
                                    if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
                                    endif
                                    if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
                                    endif
                                    if !empty(mixed_file)
                                      let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
                                    endif
                                    if conflicts != 0
                                      let conflicts_fmt = get(g:, 'airline#extensions#whitespace#conflicts_format', '[%s]conflicts')
                                      let b:airline_whitespace_check .= space.printf(conflicts_fmt, conflicts)
                                    endif
                                  endif
                                endif
                              endif
  102   0.007437   0.001415   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  airline#extensions#tabline#formatters#default#format()
Called 15 times
Total time:   0.004575
 Self time:   0.003895

count  total (s)   self (s)
   15              0.000118   let fmod = get(g:, 'airline#extensions#tabline#fnamemod', ':~:.')
   15              0.000047   let _ = ''
                            
   15              0.000089   let name = bufname(a:bufnr)
   15              0.000068   if empty(name)
                                let _ .= '[No Name]'
                              else
   15              0.000036     if s:fnamecollapse
                                  " Does not handle non-ascii characters like Cyrillic: 'D/Учёба/t.c'
                                  "let _ .= substitute(fnamemodify(name, fmod), '\v\w\zs.{-}\ze(\\|/)', '', 'g')
   15              0.002720       let _ .= pathshorten(fnamemodify(name, fmod))
   15              0.000038     else
                                  let _ .= fnamemodify(name, fmod)
                                endif
   15              0.000121     if a:bufnr != bufnr('%') && s:fnametruncate && strlen(_) > s:fnametruncate
                                  let _ = strpart(_, 0, s:fnametruncate)
                                endif
   15              0.000017   endif
                            
   15   0.000940   0.000259   return airline#extensions#tabline#formatters#default#wrap_name(a:bufnr, _)

FUNCTION  ale#engine#InitBufferInfo()
Called 9 times
Total time:   0.000219
 Self time:   0.000219

count  total (s)   self (s)
    9              0.000080     if !has_key(g:ale_buffer_info, a:buffer)
                                    " active_linter_list will hold the list of active linter names
                                    " loclist holds the loclist items after all jobs have completed.
                                    let g:ale_buffer_info[a:buffer] = {   'active_linter_list': [],   'active_other_sources_list': [],   'loclist': [],}
                            
                                    return 1
                                endif
                            
    9              0.000016     return 0

FUNCTION  <SNR>141_Init()
Called 17 times
Total time:   0.000137
 Self time:   0.000137

count  total (s)   self (s)
   17              0.000073     if s:checked_ctags == 2 && a:silent
   17              0.000035         return 0
                                elseif s:checked_ctags != 1
                                    if !s:CheckForExCtags(a:silent)
                                        return 0
                                    endif
                                endif
                            
                                if !s:type_init_done
                                    call s:InitTypes()
                                endif
                            
                                if !s:autocommands_done
                                    call s:CreateAutocommands()
                                    call s:AutoUpdate(fnamemodify(expand('%'), ':p'), 0)
                                endif
                            
                                let s:init_done = 1
                                return 1

FUNCTION  <SNR>153_RunIfExecutable()
Called 36 times
Total time:   0.087497
 Self time:   0.004115

count  total (s)   self (s)
   36   0.000875   0.000423     if ale#command#IsDeferred(a:executable)
                                    let a:executable.result_callback = {   executable -> s:RunIfExecutable(a:buffer, a:linter, executable)}
                            
                                    return 1
                                endif
                            
   36   0.008743   0.000418     if ale#engine#IsExecutable(a:buffer, a:executable)
                                    " Use different job types for file or linter jobs.
    9              0.000051         let l:job_type = a:linter.lint_file ? 'file_linter' : 'linter'
    9              0.000085         call setbufvar(a:buffer, 'ale_job_type', l:job_type)
                            
    9              0.000046         if has_key(a:linter, 'command_chain')
                                        let [l:command, l:options] = ale#engine#ProcessChain(   a:buffer,   a:executable,   a:linter,   0,   [])
                            
                                        return s:RunJob(l:command, l:options)
                                    endif
                            
    9   0.011222   0.000123         let l:command = ale#linter#GetCommand(a:buffer, a:linter)
    9              0.000172         let l:options = {   'executable': a:executable,   'buffer': a:buffer,   'linter': a:linter,   'output_stream': get(a:linter, 'output_stream', 'stdout'),   'next_chain_index': 1,   'read_buffer': a:linter.read_buffer,}
                            
    9   0.063879   0.000372         return s:RunJob(l:command, l:options)
                                endif
                            
   27              0.000048     return 0

FUNCTION  ale#util#StartPartialTimer()
Called 20 times
Total time:   0.000600
 Self time:   0.000600

count  total (s)   self (s)
   20              0.000306     let l:timer_id = timer_start(a:delay, function('s:ApplyPartialTimer'))
   20              0.000189     let s:partial_timers[l:timer_id] = [a:callback, a:args]
                            
   20              0.000054     return l:timer_id

FUNCTION  <SNR>134_Trim()
Called 2 times
Total time:   0.000409
 Self time:   0.000074

count  total (s)   self (s)
    2              0.000014   call cursor(a:ln+1,1)
    2   0.000375   0.000040   call s:previous_token()
    2              0.000017   return strpart(getline('.'),0,col('.'))

FUNCTION  <SNR>108_get_syn()
Called 1420 times
Total time:   0.119261
 Self time:   0.119261

count  total (s)   self (s)
 1420              0.009241   if !exists("g:airline_gui_mode")
                                let g:airline_gui_mode = airline#init#gui_mode()
                              endif
 1420              0.004028   let color = ''
 1420              0.015492   if hlexists(a:group)
 1372              0.024367     let color = synIDattr(synIDtrans(hlID(a:group)), a:what, g:airline_gui_mode)
 1372              0.002475   endif
 1420              0.007445   if empty(color) || color == -1
                                " should always exists
   48              0.001491     let color = synIDattr(synIDtrans(hlID('Normal')), a:what, g:airline_gui_mode)
                                " however, just in case
   48              0.000279     if empty(color) || color == -1
                                  let color = 'NONE'
                                endif
   48              0.000044   endif
 1420              0.003081   return color

FUNCTION  ale#lsp#tsserver_message#Geterr()
Called 9 times
Total time:   0.001155
 Self time:   0.001155

count  total (s)   self (s)
    9              0.001144     return [1, 'ts@geterr', {'files': [expand('#' . a:buffer . ':p')]}]

FUNCTION  ale#command#InitData()
Called 18 times
Total time:   0.000374
 Self time:   0.000374

count  total (s)   self (s)
   18              0.000186     if !has_key(s:buffer_data, a:buffer)
    2              0.000024         let s:buffer_data[a:buffer] = {   'jobs': {},   'file_list': [],   'directory_list': [],}
    2              0.000003     endif

FUNCTION  <SNR>176_GetCounts()
Called 56 times
Total time:   0.003545
 Self time:   0.001794

count  total (s)   self (s)
   56   0.001392   0.000519     if !s:BufferCacheExists(a:buffer)
                                    return s:CreateCountDict()
                                endif
                            
   56   0.001446   0.000567     call s:UpdateCacheIfNecessary(a:buffer)
                            
   56              0.000256     return g:ale_buffer_info[a:buffer].count

FUNCTION  <SNR>176_BufferCacheExists()
Called 84 times
Total time:   0.001344
 Self time:   0.001344

count  total (s)   self (s)
   84              0.000784     if !exists('g:ale_buffer_info') || !has_key(g:ale_buffer_info, a:buffer)
                                    return 0
                                endif
                            
   84              0.000110     return 1

FUNCTION  <SNR>97_update_git_branch()
Called 102 times
Total time:   0.192005
 Self time:   0.005672

count  total (s)   self (s)
  102   0.001882   0.000956   if !airline#util#has_fugitive()
                                let s:vcs_config['git'].branch = ''
                                return
                              endif
                            
  102   0.187709   0.002301   let s:vcs_config['git'].branch = exists("*FugitiveHead") ? FugitiveHead(s:sha1size) : fugitive#head(s:sha1size)
  102              0.000970   if s:vcs_config['git'].branch is# 'master' && airline#util#winwidth() < 81
                                " Shorten default a bit
                                let s:vcs_config['git'].branch='mas'
                              endif

FUNCTION  ale#util#LocItemCompare()
Called 84 times
Total time:   0.027710
 Self time:   0.027710

count  total (s)   self (s)
   84              0.000344     if a:left.bufnr < a:right.bufnr
                                    return -1
                                endif
                            
   84              0.000241     if a:left.bufnr > a:right.bufnr
                                    return 1
                                endif
                            
   84              0.000205     if a:left.bufnr == -1
                                    if a:left.filename < a:right.filename
                                        return -1
                                    endif
                            
                                    if a:left.filename > a:right.filename
                                        return 1
                                    endif
                                endif
                            
   84              0.000253     if a:left.lnum < a:right.lnum
   17              0.000034         return -1
                                endif
                            
   67              0.000184     if a:left.lnum > a:right.lnum
   17              0.000028         return 1
                                endif
                            
   50              0.023891     if a:left.col < a:right.col
   48              0.000094         return -1
                                endif
                            
    2              0.000004     if a:left.col > a:right.col
    2              0.000003         return 1
                                endif
                            
                                " When either of the items lacks a problem type, then the two items should
                                " be considered equal. This is important for loclist jumping.
                                if !has_key(a:left, 'type') || !has_key(a:right, 'type')
                                    return 0
                                endif
                            
                                let l:left_priority = ale#util#GetItemPriority(a:left)
                                let l:right_priority = ale#util#GetItemPriority(a:right)
                            
                                if l:left_priority < l:right_priority
                                    return -1
                                endif
                            
                                if l:left_priority > l:right_priority
                                    return 1
                                endif
                            
                                return 0

FUNCTION  <SNR>146_LanguageGetter()
Called 9 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    9              0.000035     return l:self.language

FUNCTION  <SNR>105_map_keys()
Called 15 times
Total time:   0.005689
 Self time:   0.005689

count  total (s)   self (s)
   15              0.000142   let bidx_mode = get(g:, 'airline#extensions#tabline#buffer_idx_mode', 1)
   15              0.000045   if bidx_mode > 0
   15              0.000033     if bidx_mode == 1
  150              0.000477       for i in range(1, 9)
  135              0.003754         exe printf('noremap <silent> <Plug>AirlineSelectTab%d :call <SID>select_tab(%d)<CR>', i, i-1)
  135              0.000277       endfor
   15              0.000021     else
                                  for i in range(11, 99)
                                    exe printf('noremap <silent> <Plug>AirlineSelectTab%d :call <SID>select_tab(%d)<CR>', i, i-11)
                                  endfor
                                endif
   15              0.000264     noremap <silent> <Plug>AirlineSelectPrevTab :<C-u>call <SID>jump_to_tab(-v:count1)<CR>
   15              0.000223     noremap <silent> <Plug>AirlineSelectNextTab :<C-u>call <SID>jump_to_tab(v:count1)<CR>
                                " Enable this for debugging
                                " com! AirlineBufferList :echo map(copy(s:current_visible_buffers), {i,k -> k.": ".bufname(k)})
   15              0.000022   endif

FUNCTION  ale#history#SetExitCode()
Called 2 times
Total time:   0.000266
 Self time:   0.000066

count  total (s)   self (s)
    2   0.000239   0.000039     let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                            
                                " If we find a match, then set the code and status.
    2              0.000012     let l:obj.exit_code = a:exit_code
    2              0.000009     let l:obj.status = 'finished'

FUNCTION  <SNR>174_CloseWindowIfNeeded()
Called 2 times
Total time:   0.000187
 Self time:   0.000045

count  total (s)   self (s)
    2   0.000181   0.000039     if ale#Var(a:buffer, 'keep_list_window_open') || !s:ShouldOpen(a:buffer)
    2              0.000003         return
                                endif
                            
                                try
                                    " Only close windows if the quickfix list or loclist is completely empty,
                                    " including errors set through other means.
                                    if g:ale_set_quickfix
                                        if empty(getqflist())
                                            cclose
                                        endif
                                    else
                                        let l:win_ids = s:WinFindBuf(a:buffer)
                            
                                        for l:win_id in l:win_ids
                                            if g:ale_set_loclist && empty(getloclist(l:win_id))
                                                lclose
                                            endif
                                        endfor
                                    endif
                                " Ignore 'Cannot close last window' errors.
                                catch /E444/
                                endtry

FUNCTION  ale#command#ManageDirectory()
Called 9 times
Total time:   0.000405
 Self time:   0.000231

count  total (s)   self (s)
    9   0.000294   0.000119     call ale#command#InitData(a:buffer)
    9              0.000096     call add(s:buffer_data[a:buffer].directory_list, a:directory)

FUNCTION  ale#statusline#Update()
Called 20 times
Total time:   0.009798
 Self time:   0.009519

count  total (s)   self (s)
   20              0.000207     if !exists('g:ale_buffer_info') || !has_key(g:ale_buffer_info, a:buffer)
                                    return
                                endif
                            
   20              0.000343     let l:loclist = filter(copy(a:loclist), 'v:val.bufnr == a:buffer')
   20   0.000516   0.000237     let l:count = s:CreateCountDict()
   20              0.000112     let l:count.total = len(l:loclist)
                            
                                " Allows easy access to the first instance of each problem type.
   20              0.000072     let l:first_problems = {}
                            
  107              0.000286     for l:entry in l:loclist
   87              0.000319         if l:entry.type is# 'W'
                                        if get(l:entry, 'sub_type', '') is# 'style'
                                            let l:count.style_warning += 1
                            
                                            if l:count.style_warning == 1
                                                let l:first_problems.style_warning = l:entry
                                            endif
                                        else
                                            let l:count.warning += 1
                            
                                            if l:count.warning == 1
                                                let l:first_problems.warning = l:entry
                                            endif
                                        endif
                                    elseif l:entry.type is# 'I'
                                        let l:count.info += 1
                            
                                        if l:count.info == 1
                                            let l:first_problems.info = l:entry
                                        endif
                                    elseif get(l:entry, 'sub_type', '') is# 'style'
                                        let l:count.style_error += 1
                            
                                        if l:count.style_error == 1
                                            let l:first_problems.style_error = l:entry
                                        endif
                                    else
   87              0.000293             let l:count.error += 1
                            
   87              0.000259             if l:count.error == 1
   20              0.000091                 let l:first_problems.error = l:entry
   20              0.000028             endif
   87              0.000093         endif
   87              0.000109     endfor
                            
                                " Set keys for backwards compatibility.
   20              0.000152     let l:count[0] = l:count.error + l:count.style_error
   20              0.000128     let l:count[1] = l:count.total - l:count[0]
                            
   20              0.000202     let g:ale_buffer_info[a:buffer].count = l:count
   20              0.000147     let g:ale_buffer_info[a:buffer].first_problems = l:first_problems

FUNCTION  ale#lsp#Send()
Called 18 times
Total time:   0.006113
 Self time:   0.001513

count  total (s)   self (s)
   18              0.000177     let l:conn = get(s:connections, a:conn_id, {})
                            
   18              0.000078     if empty(l:conn)
                                    return 0
                                endif
                            
   18              0.000051     if !l:conn.initialized
                                    throw 'LSP server not initialized yet!'
                                endif
                            
   18   0.003091   0.000446     let [l:id, l:data] = ale#lsp#CreateMessageData(a:message)
   18   0.002311   0.000355     call s:SendMessageData(l:conn, l:data)
                            
   18              0.000074     return l:id == 0 ? -1 : l:id

FUNCTION  airline#parts#spell()
Called 102 times
Total time:   0.005724
 Self time:   0.005724

count  total (s)   self (s)
  102              0.002652   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
  102              0.000467   if g:airline_detect_spell && &spell
                                let winwidth = airline#util#winwidth()
                                if winwidth >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth >= 70
                                  return g:airline_symbols.spell
                                else
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
                              endif
  102              0.000164   return ''

FUNCTION  gitgutter#hunk#summary()
Called 102 times
Total time:   0.005071
 Self time:   0.001728

count  total (s)   self (s)
  102   0.004970   0.001627   return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  ale#linter#ResolveFiletype()
Called 9 times
Total time:   0.001283
 Self time:   0.000344

count  total (s)   self (s)
    9   0.001122   0.000184     let l:filetype = s:GetAliasedFiletype(a:original_filetype)
                            
    9              0.000096     if type(l:filetype) isnot v:t_list
    9              0.000036         return [l:filetype]
                                endif
                            
                                return l:filetype

FUNCTION  ale#engine#MarkLinterInactive()
Called 20 times
Total time:   0.000327
 Self time:   0.000327

count  total (s)   self (s)
   20              0.000303     call filter(a:info.active_linter_list, 'v:val.name isnot# a:linter_name')

FUNCTION  airline#extensions#tagbar#currenttag()
Called 102 times
Total time:   0.006568
 Self time:   0.005252

count  total (s)   self (s)
  102              0.000669   if get(w:, 'airline_active', 0)
  102              0.000261     if !s:init
                                  try
                                    " try to load the plugin, if filetypes are disabled,
                                    " this will cause an error, so try only once
                                    let a=tagbar#currenttag('%', '', '')
                                  catch
                                  endtry
                                  unlet! a
                                  let s:init=1
                                endif
                                " function tagbar#currenttag does not exist, if filetype is not enabled
  102              0.000802     if s:airline_tagbar_last_lookup_time != localtime() && exists("*tagbar#currenttag")
   17   0.001655   0.000340       let s:airline_tagbar_last_lookup_val = tagbar#currenttag('%s', '', s:flags)
   17              0.000106       let s:airline_tagbar_last_lookup_time = localtime()
   17              0.000024     endif
  102              0.000308     return s:airline_tagbar_last_lookup_val
                              endif
                              return ''

FUNCTION  ale#engine#SetResults()
Called 20 times
Total time:   0.099882
 Self time:   0.003408

count  total (s)   self (s)
   20   0.000724   0.000249     let l:linting_is_done = !ale#engine#IsCheckingBuffer(a:buffer)
                            
                                " Set signs first. This could potentially fix some line numbers.
                                " The List could be sorted again here by SetSigns.
   20              0.000060     if g:ale_set_signs
   20   0.060402   0.000548         call ale#sign#SetSigns(a:buffer, a:loclist)
   20              0.000030     endif
                            
   20              0.000078     if g:ale_set_quickfix || g:ale_set_loclist
   20   0.001865   0.000274         call ale#list#SetLists(a:buffer, a:loclist)
   20              0.000023     endif
                            
   20              0.000122     if exists('*ale#statusline#Update')
                                    " Don't load/run if not already loaded.
   20   0.010077   0.000280         call ale#statusline#Update(a:buffer, a:loclist)
   20              0.000031     endif
                            
   20              0.000058     if g:ale_set_highlights
   20   0.021060   0.000295         call ale#highlight#SetHighlights(a:buffer, a:loclist)
   20              0.000029     endif
                            
   20              0.000059     if l:linting_is_done
    2              0.000005         if g:ale_echo_cursor
                                        " Try and echo the warning now.
                                        " This will only do something meaningful if we're in normal mode.
    2   0.000053   0.000017             call ale#cursor#EchoCursorWarning()
    2              0.000002         endif
                            
    2              0.000003         if g:ale_virtualtext_cursor
                                        " Try and show the warning now.
                                        " This will only do something meaningful if we're in normal mode.
                                        call ale#virtualtext#ShowCursorWarning()
                                    endif
                            
                                    " Reset the save event marker, used for opening windows, etc.
    2              0.000010         call setbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Set a marker showing how many times a buffer has been checked.
    2              0.000014         call setbufvar(   a:buffer,   'ale_linted',   getbufvar(a:buffer, 'ale_linted', 0) + 1)
                            
                                    " Automatically remove all managed temporary files and directories
                                    " now that all jobs have completed.
    2   0.003853   0.000052         call ale#command#RemoveManagedFiles(a:buffer)
                            
                                    " Call user autocommands. This allows users to hook into ALE's lint cycle.
    2   0.000283   0.000130         silent doautocmd <nomodeline> User ALELintPost
    2              0.000003     endif

FUNCTION  <SNR>98_ModifierFlags()
Called 102 times
Total time:   0.000927
 Self time:   0.000927

count  total (s)   self (s)
  102              0.000801   return (exists("+autochdir") && &autochdir) ? ':p' : ':.'

FUNCTION  <SNR>171_prev_indent()
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000007   let lnum = prevnonblank(a:lnum - 1)
    1              0.000004   return indent(lnum)

FUNCTION  <SNR>99_ale_refresh()
Called 11 times
Total time:   0.000162
 Self time:   0.000162

count  total (s)   self (s)
   11              0.000098   if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh!'
                              endif

FUNCTION  ale#list#SetLists()
Called 20 times
Total time:   0.001591
 Self time:   0.000991

count  total (s)   self (s)
   20              0.000225     if get(g:, 'ale_set_lists_synchronously') == 1|| getbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Update lists immediately if running a test synchronously, or if the
                                    " buffer was saved.
                                    "
                                    " The lists need to be updated immediately when saving a buffer so
                                    " that we can reliably close window automatically, if so configured.
                                    call s:SetListsImpl(-1, a:buffer, a:loclist)
                                else
   20   0.001049   0.000448         call ale#util#StartPartialTimer(   0,   function('s:SetListsImpl'),   [a:buffer, a:loclist],)
   20              0.000029     endif

FUNCTION  <SNR>155_parseJSON()
Called 2 times
Total time:   0.000507
 Self time:   0.000507

count  total (s)   self (s)
    2              0.000006     try
    2              0.000137         let l:parsed = json_decode(a:lines[-1])
    2              0.000005     catch
                                    return []
                                endtry
                            
    2              0.000017     if type(l:parsed) != v:t_list || empty(l:parsed)
                                    return []
                                endif
                            
    2              0.000014     let l:errors = l:parsed[0]['messages']
                            
    2              0.000008     if empty(l:errors)
                                    return []
                                endif
                            
    2              0.000006     let l:output = []
                            
    4              0.000013     for l:error in l:errors
    2              0.000030         let l:obj = ({   'lnum': get(l:error, 'line', 0),   'text': get(l:error, 'message', ''),   'type': 'E',})
                            
    2              0.000010         if get(l:error, 'severity', 0) is# 1
                                        let l:obj.type = 'W'
                                    endif
                            
    2              0.000008         if has_key(l:error, 'ruleId')
    2              0.000008             let l:code = l:error['ruleId']
                            
                                        " Sometimes ESLint returns null here
    2              0.000007             if !empty(l:code)
                                            let l:obj.code = l:code
                                        endif
    2              0.000002         endif
                            
    2              0.000007         if has_key(l:error, 'column')
    2              0.000009             let l:obj.col = l:error['column']
    2              0.000002         endif
                            
    2              0.000009         if has_key(l:error, 'endColumn')
                                        let l:obj.end_col = l:error['endColumn'] - 1
                                    endif
                            
    2              0.000006         if has_key(l:error, 'endLine')
                                        let l:obj.end_lnum = l:error['endLine']
                                    endif
                            
    2              0.000009         call add(l:output, l:obj)
    2              0.000003     endfor
                            
    2              0.000005     return l:output

FUNCTION  ale#util#InSandbox()
Called 54 times
Total time:   0.001807
 Self time:   0.001699

count  total (s)   self (s)
   54              0.000134     try
   54   0.000990   0.000882         let &l:equalprg=&l:equalprg
   54              0.000132     catch /E48/
                                    " E48 is the sandbox error.
                                    return 1
                                endtry
                            
   54              0.000087     return 0

FUNCTION  delimitMate#ParenDelim()
Called 3 times
Total time:   0.002134
 Self time:   0.000657

count  total (s)   self (s)
    3   0.000452   0.000136 	let left = s:g('left_delims')[index(s:g('right_delims'),a:right)]
    3   0.000838   0.000055 	if delimitMate#IsForbidden(a:right)
                            		return left
                            	endif
                            	" Try to balance matchpairs
    3   0.000154   0.000038 	if s:g('balance_matchpairs') && delimitMate#BalancedParens(a:right) < 0
                            		return left
                            	endif
    3              0.000019 	let line = getline('.')
    3              0.000015 	let col = col('.')-2
    3   0.000152   0.000032 	if s:g('smart_matchpairs') != ''
    3   0.000202   0.000094 		let smart_matchpairs = substitute(s:g('smart_matchpairs'), '\\!', left, 'g')
    3              0.000044 		let smart_matchpairs = substitute(smart_matchpairs, '\\#', a:right, 'g')
    3              0.000062 		if line[col+1:] =~ smart_matchpairs
                            			return left
                            		endif
    3              0.000003 	endif
    3   0.000070   0.000035 	let tail = len(line) == (col + 1) ? s:g('eol_marker') : ''
                            	"if (col) < 0
                            	"	call setline('.',a:right.line)
                            	"endif
    3              0.000064 	return left . a:right . tail . repeat("\<Left>", len(split(tail, '\zs')) + 1)

FUNCTION  airline#parts#crypt()
Called 102 times
Total time:   0.001640
 Self time:   0.001640

count  total (s)   self (s)
  102              0.001532   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  jsx_pretty#comment#update_commentstring()
Called 10 times
Total time:   0.007061
 Self time:   0.001606

count  total (s)   self (s)
   10   0.003121   0.000276   let syn_current = s:syn_name(line('.'), col('.'))
   10   0.002897   0.000288   let syn_start = s:syn_name(line('.'), 1)
   10              0.000076   let save_cursor = getcurpos()
                            
   10              0.000133   if syn_start =~? '^jsx'
                                let line = getline(".")
                                let start = len(matchstr(line, '^\s*'))
                                let syn_name = s:syn_name(line('.'), start + 1)
                            
                                if line =~ '^\s*//'
                                  let &l:commentstring = '// %s'
                                elseif s:syn_contains(line('.'), col('.'), 'jsxTaggedRegion')
                                  let &l:commentstring = '<!-- %s -->'
                                elseif syn_name =~? '^jsxAttrib'
                                  let &l:commentstring = '// %s'
                                else
                                  let &l:commentstring = '{/* %s */}'
                                endif
                              else
   10              0.000172     let &l:commentstring = a:original
   10              0.000020   endif
                            
                              " Restore the cursor position
   10              0.000074   call setpos('.', save_cursor)

FUNCTION  airline#extensions#keymap#status()
Called 102 times
Total time:   0.002308
 Self time:   0.002308

count  total (s)   self (s)
  102              0.001076   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
  102              0.001072     return printf('%s', (!empty(&keymap) ? (g:airline_symbols.keymap . ' '. &keymap) : ''))
                              else
                                return ''
                              endif

FUNCTION  ale#lsp#CreateMessageData()
Called 18 times
Total time:   0.002645
 Self time:   0.000455

count  total (s)   self (s)
   18              0.000115     if a:message[1][:2] is# 'ts@'
   18   0.002502   0.000311         return s:CreateTSServerMessageData(a:message)
                                endif
                            
                                let l:is_notification = a:message[0]
                            
                                let l:obj = {   'method': a:message[1],   'jsonrpc': '2.0',}
                            
                                if !l:is_notification
                                    let l:obj.id = ale#lsp#GetNextMessageID()
                                endif
                            
                                if len(a:message) > 2
                                    let l:obj.params = a:message[2]
                                endif
                            
                                let l:body = json_encode(l:obj)
                                let l:data = 'Content-Length: ' . strlen(l:body) . "\r\n\r\n" . l:body
                            
                                return [l:is_notification ? 0 : l:obj.id, l:data]

FUNCTION  <SNR>123_Complete()
Called 107 times
Total time:   0.006311
 Self time:   0.004891

count  total (s)   self (s)
                              " Do not call user's completion function if the start column is after the
                              " current column or if there are no candidates. Close the completion menu
                              " instead. This avoids keeping the user in completion mode.
  107              0.001153   if s:completion.completion_start_column > s:completion.column || empty( s:completion.completions )
  107   0.003048   0.001628     call s:CloseCompletionMenu()
  107              0.000164   else
                                " <c-x><c-u> invokes the user's completion function (which we have set to
                                " youcompleteme#CompleteFunc), and <c-p> tells Vim to select the previous
                                " completion candidate. This is necessary because by default, Vim selects
                                " the first candidate when completion is invoked, and selecting a candidate
                                " automatically replaces the current text with it. Calling <c-p> forces Vim
                                " to deselect the first candidate and in turn preserve the user's current
                                " text until he explicitly chooses to replace it with a completion.
                                call s:SendKeys( "\<C-X>\<C-U>\<C-P>" )
                              endif

FUNCTION  airline#extensions#branch#head()
Called 102 times
Total time:   0.253436
 Self time:   0.005604

count  total (s)   self (s)
  102              0.000683   if !exists('b:buffer_vcs_config')
                                call s:init_buffer()
                              endif
                            
  102   0.216115   0.001157   call s:update_branch()
  102   0.034357   0.001483   call s:update_untracked()
                            
  102              0.000917   if exists('b:airline_head') && !empty(b:airline_head)
  102              0.000282     return b:airline_head
                              endif
                            
                              let b:airline_head = ''
                              let vcs_priority = get(g:, "airline#extensions#branch#vcs_priority", ["git", "mercurial"])
                            
                              let heads = []
                              for vcs in vcs_priority
                                if !empty(b:buffer_vcs_config[vcs].branch)
                                  let heads += [vcs]
                                endif
                              endfor
                            
                              for vcs in heads
                                if !empty(b:airline_head)
                                  let b:airline_head .= ' | '
                                endif
                                if len(heads) > 1
                                  let b:airline_head .= s:vcs_config[vcs].exe .':'
                                endif
                                let b:airline_head .= s:format_name({s:vcs_config[vcs].display_branch}())
                                let additional = b:buffer_vcs_config[vcs].untracked
                                if empty(additional) && has_key(b:buffer_vcs_config[vcs], 'dirty') && b:buffer_vcs_config[vcs].dirty
                                  let additional = g:airline_symbols['dirty']
                                endif
                                let b:airline_head .= additional
                              endfor
                            
                              if empty(heads)
                                if airline#util#has_vcscommand()
                                  noa call VCSCommandEnableBufferSetup()
                                  if exists('b:VCSCommandBufferInfo')
                                    let b:airline_head = s:format_name(get(b:VCSCommandBufferInfo, 0, ''))
                                  endif
                                endif
                              endif
                            
                              if empty(heads)
                                if airline#util#has_custom_scm()
                                  try
                                    let Fn = function(g:airline#extensions#branch#custom_head)
                                    let b:airline_head = Fn()
                                  endtry
                                endif
                              endif
                            
                              if exists("g:airline#extensions#branch#displayed_head_limit")
                                let w:displayed_head_limit = g:airline#extensions#branch#displayed_head_limit
                                if len(b:airline_head) > w:displayed_head_limit - 1
                                  let b:airline_head = b:airline_head[0:(w:displayed_head_limit - 1)].(&encoding ==? 'utf-8' ?  '…' : '.')
                                endif
                              endif
                            
                              return b:airline_head

FUNCTION  <SNR>134_syn_at()
Called 1 time
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    1              0.000022   return synIDattr(synID(a:l,a:c,0),'name')

FUNCTION  ale#handlers#eslint#GetExecutable()
Called 18 times
Total time:   0.019381
 Self time:   0.000410

count  total (s)   self (s)
   18   0.019360   0.000389     return ale#node#FindExecutable(a:buffer, 'javascript_eslint', [   'node_modules/.bin/eslint_d',   'node_modules/eslint/bin/eslint.js',   'node_modules/.bin/eslint',])

FUNCTION  <SNR>123_OnInsertChar()
Called 94 times
Total time:   0.017746
 Self time:   0.003491

count  total (s)   self (s)
   94   0.014480   0.001365   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
   94              0.000646   call timer_stop( s:pollers.completion.id )
   94   0.002140   0.000999   call s:CloseCompletionMenu()

FUNCTION  ale#engine#FixLocList()
Called 20 times
Total time:   0.022922
 Self time:   0.020279

count  total (s)   self (s)
   20              0.000083     let l:bufnr_map = {}
   20              0.000065     let l:new_loclist = []
                            
                                " Some errors have line numbers beyond the end of the file,
                                " so we need to adjust them so they set the error at the last line
                                " of the file instead.
   20   0.002366   0.000299     let l:last_line_number = ale#util#GetLineCount(a:buffer)
                            
   86              0.000291     for l:old_item in a:loclist
                                    " Copy the loclist item with some default values and corrections.
                                    "
                                    " line and column numbers will be converted to numbers.
                                    " The buffer will default to the buffer being checked.
                                    " The vcol setting will default to 0, a byte index.
                                    " The error type will default to 'E' for errors.
                                    " The error number will default to -1.
                                    "
                                    " The line number and text are the only required keys.
                                    "
                                    " The linter_name will be set on the errors so it can be used in
                                    " output, filtering, etc..
   66              0.002144         let l:item = {   'bufnr': a:buffer,   'text': l:old_item.text,   'lnum': str2nr(l:old_item.lnum),   'col': str2nr(get(l:old_item, 'col', 0)),   'vcol': 0,   'type': get(l:old_item, 'type', 'E'),   'nr': get(l:old_item, 'nr', -1),   'linter_name': a:linter_name,}
                            
   66              0.000212         if a:from_other_source
                                        let l:item.from_other_source = 1
                                    endif
                            
   66              0.000312         if has_key(l:old_item, 'code')
   64              0.000328             let l:item.code = l:old_item.code
   64              0.000089         endif
                            
   66              0.000503         if has_key(l:old_item, 'filename')&& !ale#path#IsTempName(l:old_item.filename)
                                        " Use the filename given.
                                        " Temporary files are assumed to be for this buffer,
                                        " and the filename is not included then, because it looks bad
                                        " in the loclist window.
                                        let l:filename = l:old_item.filename
                                        let l:item.filename = l:filename
                            
                                        if has_key(l:old_item, 'bufnr')
                                            " If a buffer number is also given, include that too.
                                            " If Vim detects that he buffer number is valid, it will
                                            " be used instead of the filename.
                                            let l:item.bufnr = l:old_item.bufnr
                                        elseif has_key(l:bufnr_map, l:filename)
                                            " Get the buffer number from the map, which can be faster.
                                            let l:item.bufnr = l:bufnr_map[l:filename]
                                        else
                                            " Look up the buffer number.
                                            let l:item.bufnr = bufnr(l:filename)
                                            let l:bufnr_map[l:filename] = l:item.bufnr
                                        endif
                                    elseif has_key(l:old_item, 'bufnr')
                                        let l:item.bufnr = l:old_item.bufnr
                                    endif
                            
   66              0.000298         if has_key(l:old_item, 'detail')
                                        let l:item.detail = l:old_item.detail
                                    endif
                            
                                    " Pass on a end_col key if set, used for highlights.
   66              0.000307         if has_key(l:old_item, 'end_col')
   64              0.000520             let l:item.end_col = str2nr(l:old_item.end_col)
   64              0.000098         endif
                            
   66              0.000308         if has_key(l:old_item, 'end_lnum')
   64              0.000479             let l:item.end_lnum = str2nr(l:old_item.end_lnum)
   64              0.000099         endif
                            
   66              0.000301         if has_key(l:old_item, 'sub_type')
                                        let l:item.sub_type = l:old_item.sub_type
                                    endif
                            
   66              0.000188         if l:item.lnum < 1
                                        " When errors appear before line 1, put them at line 1.
                                        let l:item.lnum = 1
                                    elseif l:item.bufnr == a:buffer && l:item.lnum > l:last_line_number
                                        " When errors go beyond the end of the file, put them at the end.
                                        " This is only done for the current buffer.
                                        let l:item.lnum = l:last_line_number
                                    elseif get(l:old_item, 'vcol', 0)
                                        " Convert virtual column positions to byte positions.
                                        " The positions will be off if the buffer has changed recently.
                                        let l:line = getbufline(a:buffer, l:item.lnum)[0]
                            
                                        let l:item.col = ale#util#Col(l:line, l:item.col)
                            
                                        if has_key(l:item, 'end_col')
                                            let l:end_line = get(l:item, 'end_lnum', l:line) != l:line   ? getbufline(a:buffer, l:item.end_lnum)[0]   : l:line
                            
                                            let l:item.end_col = ale#util#Col(l:end_line, l:item.end_col)
                                        endif
                                    endif
                            
   66              0.000402         call add(l:new_loclist, l:item)
   66              0.000145     endfor
                            
   20   0.000996   0.000421     let l:type_map = get(ale#Var(a:buffer, 'type_map'), a:linter_name, {})
                            
   20              0.000090     if !empty(l:type_map)
                                    call s:RemapItemTypes(l:type_map, l:new_loclist)
                                endif
                            
   20              0.000053     return l:new_loclist

FUNCTION  <SNR>97_update_branch()
Called 102 times
Total time:   0.214958
 Self time:   0.011109

count  total (s)   self (s)
  306              0.001633   for vcs in keys(s:vcs_config)
  204   0.207520   0.003671     call {s:vcs_config[vcs].update_branch}()
  204              0.001891     if b:buffer_vcs_config[vcs].branch != s:vcs_config[vcs].branch
                                  let b:buffer_vcs_config[vcs].branch = s:vcs_config[vcs].branch
                                  unlet! b:airline_head
                                endif
  204              0.000319   endfor

FUNCTION  <SNR>134_alternatePair()
Called 1 time
Total time:   0.000267
 Self time:   0.000143

count  total (s)   self (s)
    1              0.000012   let pos = getpos('.')[1:2]
    1              0.000020   while search('\m[][(){}]','bW',a:stop)
    1   0.000097   0.000020 	if !s:skip_func()
    1   0.000035   0.000024 	  let idx = stridx('])}',s:looking_at())
    1              0.000004 	  if idx + 1
    1   0.000071   0.000035 		if s:GetPair(['\[','(','{'][idx], '])}'[idx],'bW','s:skip_func()',2000,a:stop) <= 0
    1              0.000003 		  break
                            		endif
                            	  else
                            		return
                            	  endif
                            	endif
                              endwhile
    1              0.000008   call call('cursor',pos)

FUNCTION  GitGutterGetHunkSummary()
Called 102 times
Total time:   0.006337
 Self time:   0.001266

count  total (s)   self (s)
  102   0.006246   0.001175   return gitgutter#hunk#summary(winbufnr(0))

FUNCTION  airline#parts#mode()
Called 102 times
Total time:   0.008287
 Self time:   0.001912

count  total (s)   self (s)
  102   0.008176   0.001800   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  ale#highlight#UpdateHighlights()
Called 20 times
Total time:   0.018905
 Self time:   0.009943

count  total (s)   self (s)
   20              0.000292     let l:item_list = get(b:, 'ale_enabled', 1) && g:ale_enabled   ? get(b:, 'ale_highlight_items', [])   : []
                            
   20   0.004464   0.000326     call ale#highlight#RemoveHighlights()
                            
  107              0.000329     for l:item in l:item_list
   87              0.000409         if l:item.type is# 'W'
                                        if get(l:item, 'sub_type', '') is# 'style'
                                            let l:group = 'ALEStyleWarning'
                                        else
                                            let l:group = 'ALEWarning'
                                        endif
                                    elseif l:item.type is# 'I'
                                        let l:group = 'ALEInfo'
                                    elseif get(l:item, 'sub_type', '') is# 'style'
                                        let l:group = 'ALEStyleError'
                                    else
   87              0.000282             let l:group = 'ALEError'
   87              0.000116         endif
                            
   87              0.001664         let l:range = {   'lnum': l:item.lnum,   'col': l:item.col,   'end_lnum': get(l:item, 'end_lnum', l:item.lnum),   'end_col': get(l:item, 'end_col', l:item.col)}
                            
   87   0.006184   0.001360         call s:highlight_range(l:item.bufnr, l:range, l:group)
   87              0.000202     endfor
                            
                                " If highlights are enabled and signs are not enabled, we should still
                                " offer line highlights by adding a separate set of highlights.
   20              0.000067     if !g:ale_set_signs
                                    let l:available_groups = {   'ALEWarningLine': hlexists('ALEWarningLine'),   'ALEInfoLine': hlexists('ALEInfoLine'),   'ALEErrorLine': hlexists('ALEErrorLine'),}
                            
                                    for l:item in l:item_list
                                        if l:item.type is# 'W'
                                            let l:group = 'ALEWarningLine'
                                        elseif l:item.type is# 'I'
                                            let l:group = 'ALEInfoLine'
                                        else
                                            let l:group = 'ALEErrorLine'
                                        endif
                            
                                        if l:available_groups[l:group]
                                            call s:highlight_line(l:item.bufnr, l:item.lnum, l:group)
                                        endif
                                    endfor
                                endif

FUNCTION  <SNR>160_HandleTSServerDiagnostics()
Called 18 times
Total time:   0.156326
 Self time:   0.004118

count  total (s)   self (s)
   18              0.000082     let l:linter_name = 'tsserver'
   18              0.001057     let l:buffer = bufnr('^' . a:response.body.file . '$')
   18              0.000205     let l:info = get(g:ale_buffer_info, l:buffer, {})
                            
   18              0.000076     if empty(l:info)
                                    return
                                endif
                            
   18   0.000540   0.000245     call ale#engine#MarkLinterInactive(l:info, l:linter_name)
                            
   18   0.002037   0.000229     if s:ShouldIgnore(l:buffer, l:linter_name)
                                    return
                                endif
                            
   18   0.004385   0.000272     let l:thislist = ale#lsp#response#ReadTSServerDiagnostics(a:response)
   18              0.000065     let l:no_changes = 0
                            
                                " tsserver sends syntax and semantic errors in separate messages, so we
                                " have to collect the messages separately for each buffer and join them
                                " back together again.
   18              0.000070     if a:error_type is# 'syntax'
    9              0.000071         if len(l:thislist) is 0 && len(get(l:info, 'syntax_loclist', [])) is 0
                                        let l:no_changes = 1
                                    endif
                            
    9              0.000185         let l:info.syntax_loclist = l:thislist
    9              0.000015     else
    9              0.000065         if len(l:thislist) is 0 && len(get(l:info, 'semantic_loclist', [])) is 0
                                        let l:no_changes = 1
                                    endif
                            
    9              0.000089         let l:info.semantic_loclist = l:thislist
    9              0.000013     endif
                            
   18              0.000047     if l:no_changes
                                    return
                                endif
                            
   18              0.000222     let l:loclist = get(l:info, 'semantic_loclist', [])   + get(l:info, 'syntax_loclist', [])
                            
   18   0.146362   0.000371     call ale#engine#HandleLoclist(l:linter_name, l:buffer, l:loclist, 0)

FUNCTION  ale#highlight#SetHighlights()
Called 20 times
Total time:   0.020765
 Self time:   0.001860

count  total (s)   self (s)
   20              0.000575     let l:new_list = getbufvar(a:buffer, 'ale_enabled', 1) && g:ale_enabled   ? filter(copy(a:loclist), 'v:val.bufnr == a:buffer && v:val.col > 0')   : []
                            
                                " Set the list in the buffer variable.
   20              0.000837     call setbufvar(str2nr(a:buffer), 'ale_highlight_items', l:new_list)
                            
                                " Update highlights for the current buffer, which may or may not
                                " be the buffer we just set highlights for.
   20   0.019235   0.000330     call ale#highlight#UpdateHighlights()

FUNCTION  <SNR>134_GetPair()
Called 1 time
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    1              0.000035 	return searchpair('\m'.a:start,'','\m'.a:end,a:flags,a:skip,max([prevnonblank(v:lnum) - 2000,0] + a:000),a:time)

FUNCTION  <SNR>99_new_airline_ale_get_line_number()
Called 56 times
Total time:   0.004669
 Self time:   0.002094

count  total (s)   self (s)
                              " The FirstProblem call in ALE is a far more efficient way
                              " of obtaining line number data. If the installed ALE supports
                              " it, we should use this method of getting line data.
   56              0.000152   if a:cnt == 0
   28              0.000050     return ''
                              endif
   28              0.000135   let l:buffer = bufnr('')
                            
                              " Try to get the first error from ALE.
   28   0.002913   0.000338   let l:result = ale#statusline#FirstProblem(l:buffer, a:type)
   28              0.000107   if empty(l:result)
                                " If there are no errors then try and check for style errors.
                                let l:result =  ale#statusline#FirstProblem(l:buffer, 'style_' . a:type)
                              endif
                            
   28              0.000084   if empty(l:result)
                                  return ''
                              endif
                            
   28              0.000193   let l:open_lnum_symbol  = get(g:, 'airline#extensions#ale#open_lnum_symbol', '(L')
   28              0.000187   let l:close_lnum_symbol = get(g:, 'airline#extensions#ale#close_lnum_symbol', ')')
                            
   28              0.000177   return open_lnum_symbol . l:result.lnum . close_lnum_symbol

FUNCTION  <SNR>18_Slash()
Called 204 times
Total time:   0.002953
 Self time:   0.002953

count  total (s)   self (s)
  204              0.001125   if exists('+shellslash')
                                return tr(a:path, '\', '/')
                              else
  204              0.000569     return a:path
                              endif

FUNCTION  ale#sign#ParseSigns()
Called 20 times
Total time:   0.021915
 Self time:   0.021915

count  total (s)   self (s)
                                " Matches output like :
                                " line=4  id=1  name=ALEErrorSign
                                " строка=1  id=1000001  имя=ALEErrorSign
                                " 行=1  識別子=1000001  名前=ALEWarningSign
                                " línea=12 id=1000001 nombre=ALEWarningSign
                                " riga=1 id=1000001, nome=ALEWarningSign
   20              0.000091     let l:pattern = '\v^.*\=(\d+).*\=(\d+).*\=(ALE[a-zA-Z]+Sign)'
   20              0.000059     let l:result = []
   20              0.000068     let l:is_dummy_sign_set = 0
                            
  317              0.001251     for l:line in a:line_list
  297              0.012394         let l:match = matchlist(l:line, l:pattern)
                            
  297              0.001573         if len(l:match) > 0
   57              0.000261             if l:match[3] is# 'ALEDummySign'
   20              0.000062                 let l:is_dummy_sign_set = 1
   20              0.000031             else
   37              0.000477                 call add(l:result, [   str2nr(l:match[1]),   str2nr(l:match[2]),   l:match[3],])
   37              0.000058             endif
   57              0.000060         endif
  297              0.000396     endfor
                            
   20              0.000094     return [l:is_dummy_sign_set, l:result]

FUNCTION  fugitive#Find()
Called 204 times
Total time:   0.156077
 Self time:   0.105771

count  total (s)   self (s)
  204              0.001412   if type(a:object) == type(0)
                                let name = bufname(a:object)
                                return s:PlatformSlash(name =~# '^$\|^/\|^\a\+:' ? name : getcwd() . '/' . name)
                              elseif a:object =~# '^[~$]'
                                let prefix = matchstr(a:object, '^[~$]\i*')
                                let owner = expand(prefix)
                                return s:PlatformSlash((len(owner) ? owner : prefix) . strpart(a:object, len(prefix)))
                              elseif s:Slash(a:object) =~# '^$\|^/\|^\%(\a\a\+:\).*\%(//\|::\)' . (has('win32') ? '\|^\a:/' : '')
                                return s:PlatformSlash(a:object)
                              elseif s:Slash(a:object) =~# '^\.\.\=\%(/\|$\)'
                                return s:PlatformSlash(simplify(getcwd() . '/' . a:object))
                              endif
  204              0.001570   let dir = a:0 ? a:1 : s:Dir()
  204              0.000887   if empty(dir)
                                let file = matchstr(a:object, '^\%(:\d:\|[^:]*:\)\zs.*', '', '')
                                let dir = FugitiveExtractGitDir(file)
                                if empty(dir)
                                  return fnamemodify(len(file) ? file : a:object, ':p')
                                endif
                              endif
  204   0.005715   0.002870   let rev = s:Slash(a:object)
  204   0.029813   0.002486   let tree = s:Tree(dir)
  204              0.001424   let base = len(tree) ? tree : 'fugitive://' . dir . '//0'
  204              0.000653   if rev ==# '.git'
                                let f = len(tree) ? tree . '/.git' : dir
                              elseif rev =~# '^\.git/'
  204              0.003356     let f = substitute(rev, '^\.git', '', '')
  204   0.013508   0.002627     let cdir = fugitive#CommonDir(dir)
  204              0.002514     if f =~# '^/\.\./\.\.\%(/\|$\)'
                                  let f = simplify(len(tree) ? tree . f[3:-1] : dir . f)
                                elseif f =~# '^/\.\.\%(/\|$\)'
                                  let f = base . f[3:-1]
                                elseif cdir !=# dir && ( f =~# '^/\%(config\|hooks\|info\|logs/refs\|objects\|refs\|worktrees\)\%(/\|$\)' || f !~# '^/\%(index$\|index\.lock$\|\w*MSG$\|\w*HEAD$\|logs/\w*HEAD$\|logs$\|rebase-\w\+\)\%(/\|$\)' && getftime(dir . f) < 0 && getftime(cdir . f) >= 0)
                                  let f = simplify(cdir . f)
                                else
  204              0.001594       let f = simplify(dir . f)
  204              0.000289     endif
  204              0.000364   elseif rev ==# ':/'
                                let f = base
                              elseif rev =~# '^\.\%(/\|$\)'
                                let f = base . rev[1:-1]
                              elseif rev =~# '^::\%(/\|\a\+\:\)'
                                let f = rev[2:-1]
                              elseif rev =~# '^::\.\.\=\%(/\|$\)'
                                let f = simplify(getcwd() . '/' . rev[2:-1])
                              elseif rev =~# '^::'
                                let f = base . '/' . rev[2:-1]
                              elseif rev =~# '^:\%([0-3]:\)\=\.\.\=\%(/\|$\)\|^:[0-3]:\%(/\|\a\+:\)'
                                let f = rev =~# '^:\%([0-3]:\)\=\.' ? simplify(getcwd() . '/' . matchstr(rev, '\..*')) : rev[3:-1]
                                if s:cpath(base . '/', (f . '/')[0 : len(base)])
                                  let f = 'fugitive://' . dir . '//' . +matchstr(rev, '^:\zs\d\ze:') . '/' . strpart(f, len(base) + 1)
                                else
                                  let altdir = FugitiveExtractGitDir(f)
                                  if len(altdir) && !s:cpath(dir, altdir)
                                    return fugitive#Find(a:object, altdir)
                                  endif
                                endif
                              elseif rev =~# '^:[0-3]:'
                                let f = 'fugitive://' . dir . '//' . rev[1] . '/' . rev[3:-1]
                              elseif rev ==# ':'
                                if $GIT_INDEX_FILE =~# '/[^/]*index[^/]*\.lock$' && s:cpath(fnamemodify($GIT_INDEX_FILE,':p')[0:strlen(dir)]) ==# s:cpath(dir . '/') && filereadable($GIT_INDEX_FILE)
                                  let f = fnamemodify($GIT_INDEX_FILE, ':p')
                                else
                                  let f = fugitive#Find('.git/index', dir)
                                endif
                              elseif rev =~# '^:(\%(top\|top,literal\|literal,top\|literal\))'
                                let f = base . '/' . matchstr(rev, ')\zs.*')
                              elseif rev =~# '^:/\@!'
                                let f = 'fugitive://' . dir . '//0/' . rev[1:-1]
                              else
                                if rev =~# 'HEAD$\|^refs/' && rev !~# ':'
                                  let cdir = rev =~# '^refs/' ? fugitive#CommonDir(dir) : dir
                                  if filereadable(cdir . '/' . rev)
                                    let f = simplify(cdir . '/' . rev)
                                  endif
                                endif
                                if !exists('f')
                                  let commit = substitute(matchstr(rev, '^[^:]\+\|^:.*'), '^@\%($\|[~^]\|@{\)\@=', 'HEAD', '')
                                  let file = substitute(matchstr(rev, '^[^:]\+\zs:.*'), '^:', '/', '')
                                  if file =~# '^/\.\.\=\%(/\|$\)\|^//\|^/\a\+:'
                                    let file = file =~# '^/\.' ? simplify(getcwd() . file) : file[1:-1]
                                    if s:cpath(base . '/', (file . '/')[0 : len(base)])
                                      let file = '/' . strpart(file, len(base) + 1)
                                    else
                                      let altdir = FugitiveExtractGitDir(file)
                                      if len(altdir) && !s:cpath(dir, altdir)
                                        return fugitive#Find(a:object, altdir)
                                      endif
                                      return file
                                    endif
                                  endif
                                  if commit !~# '^[0-9a-f]\{40\}$'
                                    let commit = system(s:Prepare(dir, 'rev-parse', '--verify', commit, '--'))[0:-2]
                                    let commit = v:shell_error ? '' : commit
                                  endif
                                  if len(commit)
                                    let f = 'fugitive://' . dir . '//' . commit . file
                                  else
                                    let f = base . '/' . substitute(rev, '^:/:\=\|^[^:]\+:', '', '')
                                  endif
                                endif
                              endif
  204   0.005705   0.002428   return s:PlatformSlash(f)

FUNCTION  delimitMate#IsForbidden()
Called 3 times
Total time:   0.000783
 Self time:   0.000166

count  total (s)   self (s)
    3   0.000157   0.000038 	if !s:g('excluded_regions_enabled')
                            		return 0
                            	endif
    3   0.000414   0.000047 	let region = delimitMate#GetCurrentSyntaxRegion()
                            	"if index(s:g('excluded_regions_list'), region) >= 0
                            	"	"echom "Forbidden 1!"
                            	"	return 1
                            	"endif
                            	"let region = delimitMate#GetCurrentSyntaxRegionIf(a:char)
                            	"echom "Forbidden 2!"
    3   0.000181   0.000051 	return index(s:g('excluded_regions_list'), region) >= 0

FUNCTION  ale#lsp_linter#FindProjectRoot()
Called 9 times
Total time:   0.004586
 Self time:   0.001010

count  total (s)   self (s)
    9              0.000084     let l:buffer_ale_root = getbufvar(a:buffer, 'ale_lsp_root', {})
                            
    9              0.000053     if type(l:buffer_ale_root) is v:t_string
                                    return l:buffer_ale_root
                                endif
                            
                                " Try to get a buffer-local setting for the root
    9              0.000053     if has_key(l:buffer_ale_root, a:linter.name)
                                    let l:Root = l:buffer_ale_root[a:linter.name]
                            
                                    if type(l:Root) is v:t_func
                                        return l:Root(a:buffer)
                                    else
                                        return l:Root
                                    endif
                                endif
                            
                                " Try to get a global setting for the root
    9              0.000089     if has_key(g:ale_lsp_root, a:linter.name)
                                    let l:Root = g:ale_lsp_root[a:linter.name]
                            
                                    if type(l:Root) is v:t_func
                                        return l:Root(a:buffer)
                                    else
                                        return l:Root
                                    endif
                                endif
                            
                                " Fall back to the linter-specific configuration
    9              0.000044     if has_key(a:linter, 'project_root')
    9              0.000063         let l:Root = a:linter.project_root
                            
    9   0.003769   0.000193         return type(l:Root) is v:t_func ? l:Root(a:buffer) : l:Root
                                endif
                            
                                return ale#util#GetFunction(a:linter.project_root_callback)(a:buffer)

FUNCTION  <SNR>123_OnDeleteChar()
Called 51 times
Total time:   0.010968
 Self time:   0.002488

count  total (s)   self (s)
   51   0.009463   0.000982   if !s:AllowedToCompleteInCurrentBuffer()
                                return a:key
                              endif
                            
   51              0.000437   call timer_stop( s:pollers.completion.id )
   51              0.000223   if pumvisible()
                                return "\<C-y>" . a:key
                              endif
   51              0.000185   return a:key

FUNCTION  <SNR>134_PrevCodeLine()
Called 1 time
Total time:   0.000087
 Self time:   0.000087

count  total (s)   self (s)
    1              0.000007   let l:n = prevnonblank(a:lnum)
    1              0.000003   while l:n
    1              0.000017 	if getline(l:n) =~ '^\s*\/[/*]' 
                            	  if (stridx(getline(l:n),'`') > 0 || getline(l:n-1)[-1:] == '\') && s:syn_at(l:n,1) =~? s:syng_str
                            		return l:n
                            	  endif
                            	  let l:n = prevnonblank(l:n-1)
                            	elseif getline(l:n) =~ '\([/*]\)\1\@![/*]' && s:syn_at(l:n,1) =~? s:syng_com
                            	  let l:n = s:save_pos('eval', 'cursor('.l:n.',1) + search(''\m\/\*'',"bW")')
                            	else
    1              0.000003 	  return l:n
                            	endif
                              endwhile

FUNCTION  ale#job#Stop()
Called 7 times
Total time:   0.002680
 Self time:   0.002680

count  total (s)   self (s)
    7              0.000055     if !has_key(s:job_map, a:job_id)
                                    return
                                endif
                            
    7              0.000047     if has('nvim')
                                    " FIXME: NeoVim kills jobs on a timer, but will not kill any processes
                                    " which are child processes on Unix. Some work needs to be done to
                                    " kill child processes to stop long-running processes like pylint.
    7              0.001949         silent! call jobstop(a:job_id)
    7              0.000020     else
                                    let l:job = s:job_map[a:job_id].job
                            
                                    " We must close the channel for reading the buffer if it is open
                                    " when stopping a job. Otherwise, we will get errors in the status line.
                                    if ch_status(job_getchannel(l:job)) is# 'open'
                                        call ch_close_in(job_getchannel(l:job))
                                    endif
                            
                                    " Ask nicely for the job to stop.
                                    call job_stop(l:job)
                            
                                    if ale#job#IsRunning(l:job)
                                        " Set a 100ms delay for killing the job with SIGKILL.
                                        let s:job_kill_timers[timer_start(100, function('s:KillHandler'))] = l:job
                                    endif
                                endif

FUNCTION  ale#lsp_linter#GetConfig()
Called 9 times
Total time:   0.000357
 Self time:   0.000357

count  total (s)   self (s)
    9              0.000060     if has_key(a:linter, 'lsp_config_callback')
                                    return ale#util#GetFunction(a:linter.lsp_config_callback)(a:buffer)
                                endif
                            
    9              0.000039     if has_key(a:linter, 'lsp_config')
                                    let l:Config = a:linter.lsp_config
                            
                                    if type(l:Config) is v:t_func
                                        let l:Config = l:Config(a:buffer)
                                    endif
                            
                                    return l:Config
                                endif
                            
    9              0.000018     return {}

FUNCTION  <lambda>1()
Called 9 times
Total time:   0.004680
 Self time:   0.000149

count  total (s)   self (s)
    9   0.004670   0.000139 return ale#node#FindExecutable(b, 'typescript_tsserver', [       'node_modules/.bin/tsserver',   ])

FUNCTION  <lambda>3()
Called 9 times
Total time:   0.170619
 Self time:   0.000788

count  total (s)   self (s)
    9   0.170608   0.000776 return ale#lsp#HandleMessage(a:conn_id, message)

FUNCTION  <SNR>54_SetDefaultCompletionType()
Called 7 times
Total time:   0.000339
 Self time:   0.000339

count  total (s)   self (s)
    7              0.000280   if exists('b:SuperTabDefaultCompletionType') && (!exists('b:complCommandLine') || !b:complCommandLine)
                                call SuperTabSetCompletionType(b:SuperTabDefaultCompletionType)
                              endif

FUNCTION  airline#extensions#tabline#get_buffer_name()
Called 15 times
Total time:   0.005429
 Self time:   0.000655

count  total (s)   self (s)
   15   0.000427   0.000229   let buffers = a:0 ? a:1 : airline#extensions#tabline#buflist#list()
   15              0.000121   let formatter = get(g:, 'airline#extensions#tabline#formatter', 'default')
   15   0.004852   0.000276   return airline#extensions#tabline#formatters#{formatter}#format(a:nr, buffers)

FUNCTION  ale#engine#HandleLoclist()
Called 20 times
Total time:   0.159065
 Self time:   0.003506

count  total (s)   self (s)
   20              0.000187     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
   20              0.000076     if empty(l:info)
                                    return
                                endif
                            
   20              0.000050     if !a:from_other_source
                                    " Remove this linter from the list of active linters.
                                    " This may have already been done when the job exits.
   20              0.000192         call filter(l:info.active_linter_list, 'v:val.name isnot# a:linter_name')
   20              0.000028     endif
                            
                                " Make some adjustments to the loclists to fix common problems, and also
                                " to set default values for loclist items.
   20   0.023340   0.000419     let l:linter_loclist = ale#engine#FixLocList(   a:buffer,   a:linter_name,   a:from_other_source,   a:loclist,)
                            
                                " Remove previous items for this linter.
   20              0.000430     call filter(l:info.loclist, 'v:val.linter_name isnot# a:linter_name')
                            
                                " We don't need to add items or sort the list when this list is empty.
   20              0.000094     if !empty(l:linter_loclist)
                                    " Add the new items.
   20              0.000126         call extend(l:info.loclist, l:linter_loclist)
                            
                                    " Sort the loclist again.
                                    " We need a sorted list so we can run a binary search against it
                                    " for efficient lookup of the messages in the cursor handler.
   20   0.028554   0.000844         call sort(l:info.loclist, 'ale#util#LocItemCompare')
   20              0.000027     endif
                            
   20   0.005270   0.000223     if ale#ShouldDoNothing(a:buffer)
                                    return
                                endif
                            
   20   0.100243   0.000361     call ale#engine#SetResults(a:buffer, l:info.loclist)

FUNCTION  <SNR>123_CloseCompletionMenu()
Called 201 times
Total time:   0.002561
 Self time:   0.002561

count  total (s)   self (s)
  201              0.000916   if pumvisible()
                                call s:SendKeys( "\<C-e>" )
                              endif

FUNCTION  <SNR>123_AllowedToCompleteInCurrentBuffer()
Called 252 times
Total time:   0.037546
 Self time:   0.004491

count  total (s)   self (s)
  252   0.037233   0.004178   return s:AllowedToCompleteInBuffer( '%' )

FUNCTION  <SNR>176_GetFirstProblems()
Called 28 times
Total time:   0.001706
 Self time:   0.000806

count  total (s)   self (s)
   28   0.000732   0.000260     if !s:BufferCacheExists(a:buffer)
                                    return {}
                                endif
                            
   28   0.000695   0.000267     call s:UpdateCacheIfNecessary(a:buffer)
                            
   28              0.000123     return g:ale_buffer_info[a:buffer].first_problems

FUNCTION  ale_linters#typescript#xo#GetExecutable()
Called 9 times
Total time:   0.006605
 Self time:   0.000160

count  total (s)   self (s)
    9   0.006596   0.000151     return ale#node#FindExecutable(a:buffer, 'typescript_xo', [   'node_modules/.bin/xo',])

FUNCTION  ale#statusline#FirstProblem()
Called 28 times
Total time:   0.002575
 Self time:   0.000869

count  total (s)   self (s)
   28   0.002027   0.000321     let l:first_problems = s:GetFirstProblems(a:buffer)
                            
   28              0.000224     if !empty(l:first_problems) && has_key(l:first_problems, a:type)
   28              0.000254         return copy(l:first_problems[a:type])
                                endif
                            
                                return {}

FUNCTION  <SNR>95_is_branch_empty()
Called 102 times
Total time:   0.001726
 Self time:   0.001726

count  total (s)   self (s)
  102              0.001624   return exists('*airline#extensions#branch#head') && empty(get(b:, 'airline_head', ''))

FUNCTION  ale#lsp#StartProgram()
Called 9 times
Total time:   0.001375
 Self time:   0.000853

count  total (s)   self (s)
    9              0.000066     let l:conn = s:connections[a:conn_id]
    9              0.000031     let l:started = 0
                            
    9   0.000688   0.000166     if !has_key(l:conn, 'job_id') || !ale#job#HasOpenChannel(l:conn.job_id)
                                    let l:options = {   'mode': 'raw',   'out_cb': {_, message -> ale#lsp#HandleMessage(a:conn_id, message)},}
                            
                                    if has('win32')
                                        let l:job_id = ale#job#StartWithCmd(a:command, l:options)
                                    else
                                        let l:job_id = ale#job#Start(a:command, l:options)
                                    endif
                            
                                    let l:started = 1
                                else
    9              0.000043         let l:job_id = l:conn.job_id
    9              0.000013     endif
                            
    9              0.000025     if l:job_id > 0
    9              0.000068         let l:conn.job_id = l:job_id
    9              0.000014     endif
                            
    9              0.000029     if l:started && !l:conn.is_tsserver
                                    call s:SendInitMessage(l:conn)
                                endif
                            
    9              0.000026     return l:job_id > 0

FUNCTION  ale#history#Get()
Called 4 times
Total time:   0.000075
 Self time:   0.000075

count  total (s)   self (s)
    4              0.000071     return copy(getbufvar(a:buffer, 'ale_history', []))

FUNCTION  <SNR>122_Slash()
Called 612 times
Total time:   0.008822
 Self time:   0.008822

count  total (s)   self (s)
  612              0.003480   if exists('+shellslash')
                                return tr(a:path, '\', '/')
                              else
  612              0.001505     return a:path
                              endif

FUNCTION  <SNR>155_CheckForBadConfig()
Called 2 times
Total time:   0.001832
 Self time:   0.001832

count  total (s)   self (s)
    2              0.000021     let l:config_error_pattern = '\v^ESLint couldn''t find a configuration file'   . '|^Cannot read config file'   . '|^.*Configuration for rule .* is invalid'   . '|^ImportDeclaration should appear'
                            
                                " Look for a message in the first few lines which indicates that
                                " a configuration file couldn't be found.
    4              0.000021     for l:line in a:lines[:10]
    2              0.001681         let l:match = matchlist(l:line, l:config_error_pattern)
                            
    2              0.000011         if len(l:match) > 0
                                        " Don't show the missing config error if we've disabled it.
                                        if ale#Var(a:buffer, 'javascript_eslint_suppress_missing_config')&& l:match[0] is# 'ESLint couldn''t find a configuration file'
                                            return 0
                                        endif
                            
                                        return 1
                                    endif
    2              0.000003     endfor
                            
    2              0.000004     return 0

FUNCTION  airline#statusline()
Called 110 times
Total time:   0.003332
 Self time:   0.003332

count  total (s)   self (s)
  110              0.001475   if has_key(s:contexts, a:winnr)
  110              0.001607     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  <SNR>123_OnBlankLine()
Called 85 times
Total time:   0.073617
 Self time:   0.001167

count  total (s)   self (s)
   85   0.073521   0.001071   return s:Pyeval( 'not vim.current.line or vim.current.line.isspace()' )

FUNCTION  <SNR>108_GetHiCmd()
Called 70 times
Total time:   0.016831
 Self time:   0.016831

count  total (s)   self (s)
                              " a:list needs to have 5 items!
   70              0.000234   let res = ''
   70              0.000223   let i = -1
  420              0.000961   while i < 4
  350              0.000983     let i += 1
  350              0.002300     let item = get(a:list, i, '')
  350              0.001171     if item is ''
  128              0.000283       continue
                                endif
  222              0.000437     if i == 0
   58              0.000330       let res .= ' guifg='.item
   58              0.000118     elseif i == 1
   32              0.000174       let res .= ' guibg='.item
   32              0.000059     elseif i == 2
   70              0.000457       let res .= ' ctermfg='.item
   70              0.000143     elseif i == 3
   44              0.000265       let res .= ' ctermbg='.item
   44              0.000087     elseif i == 4
   18              0.000225       let res .= printf(' gui=%s cterm=%s term=%s', item, item, item)
   18              0.000028     endif
  222              0.000321   endwhile
   70              0.000201   return res

FUNCTION  airline#util#has_lawrencium()
Called 102 times
Total time:   0.000805
 Self time:   0.000805

count  total (s)   self (s)
  102              0.000710   return exists('*lawrencium#statusline')

FUNCTION  <SNR>123_OnInsertLeave()
Called 7 times
Total time:   0.084631
 Self time:   0.066024

count  total (s)   self (s)
    7   0.001410   0.000170   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
    7              0.000052   call timer_stop( s:pollers.completion.id )
    7              0.000065   let s:force_semantic = 0
    7              0.000054   let s:completion = s:default_completion
                            
    7   0.017587   0.000219   call s:OnFileReadyToParse()
    7              0.065210   exec s:python_command "ycm_state.OnInsertLeave()"
    7              0.000094   if g:ycm_autoclose_preview_window_after_completion || g:ycm_autoclose_preview_window_after_insertion
                                call s:ClosePreviewWindowIfNeeded()
                              endif

FUNCTION  <SNR>174_SetListsImpl()
Called 20 times
Total time:   0.032163
 Self time:   0.009196

count  total (s)   self (s)
   20              0.002750     let l:title = expand('#' . a:buffer . ':p')
                            
   20              0.000089     if g:ale_set_quickfix
                                    let l:quickfix_list = ale#list#GetCombinedList()
                            
                                    if has('nvim')
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list), ' ', l:title)
                                    else
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list))
                                        call setqflist([], 'r', {'title': l:title})
                                    endif
                                elseif g:ale_set_loclist
                                    " If windows support is off, win_findbuf() may not exist.
                                    " We'll set result in the current window, which might not be correct,
                                    " but it's better than nothing.
   20   0.000654   0.000316         let l:ids = s:WinFindBuf(a:buffer)
                            
   40              0.000147         for l:id in l:ids
   20              0.000137             if has('nvim')
   20   0.021958   0.001280                 call setloclist(l:id, s:FixList(a:buffer, a:loclist), ' ', l:title)
   20              0.000055             else
                                            call setloclist(l:id, s:FixList(a:buffer, a:loclist))
                                            call setloclist(l:id, [], 'r', {'title': l:title})
                                        endif
   20              0.000034         endfor
   20              0.000029     endif
                            
                                " Open a window to show the problems if we need to.
                                "
                                " We'll check if the current buffer's List is not empty here, so the
                                " window will only be opened if the current buffer has problems.
   20   0.001671   0.000411     if s:ShouldOpen(a:buffer) && !empty(a:loclist)
                                    let l:winnr = winnr()
                                    let l:mode = mode()
                                    let l:reset_visual_selection = l:mode is? 'v' || l:mode is# "\<c-v>"
                                    let l:reset_character_selection = l:mode is? 's' || l:mode is# "\<c-s>"
                            
                                    " open windows vertically instead of default horizontally
                                    let l:open_type = ''
                            
                                    if ale#Var(a:buffer, 'list_vertical') == 1
                                        let l:open_type = 'vert rightbelow '
                                    endif
                            
                                    if g:ale_set_quickfix
                                        if !ale#list#IsQuickfixOpen()
                                            silent! execute l:open_type . 'copen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                        endif
                                    elseif g:ale_set_loclist
                                        silent! execute l:open_type . 'lopen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                    endif
                            
                                    " If focus changed, restore it (jump to the last window).
                                    if l:winnr isnot# winnr()
                                        wincmd p
                                    endif
                            
                                    if l:reset_visual_selection || l:reset_character_selection
                                        " If we were in a selection mode before, select the last selection.
                                        normal! gv
                            
                                        if l:reset_character_selection
                                            " Switch back to Select mode, if we were in that.
                                            normal! "\<c-g>"
                                        endif
                                    endif
                                endif
                            
                                " If ALE isn't currently checking for more problems, close the window if
                                " needed now. This check happens inside of this timer function, so
                                " the window can be closed reliably.
   20   0.000737   0.000233     if !ale#engine#IsCheckingBuffer(a:buffer)
    2   0.000226   0.000039         call s:CloseWindowIfNeeded(a:buffer)
    2              0.000002     endif

FUNCTION  airline#highlighter#get_highlight()
Called 710 times
Total time:   0.234352
 Self time:   0.101790

count  total (s)   self (s)
  710              0.028142   let reverse = get(g:, 'airline_gui_mode', '') ==# 'gui' ? synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'gui') : synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')|| synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'term')
  710              0.005923   if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                let res = s:hl_groups[a:group]
                                return reverse ? [ res[1], res[0], res[3], res[2], res[4] ] : res
                              else
  710   0.077885   0.009929     let fg = s:get_syn(a:group, 'fg')
  710   0.060519   0.009214     let bg = s:get_syn(a:group, 'bg')
  710              0.011092     let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
  710              0.001844     if reverse
                                  let res = s:get_array(bg, fg, bold ? ['bold'] : a:000)
                                else
  710   0.023907   0.010605       let res = s:get_array(fg, bg, bold ? ['bold'] : a:000)
  710              0.001078     endif
  710              0.000662   endif
  710              0.006181   let s:hl_groups[a:group] = res
  710              0.001676   return res

FUNCTION  ale#history#Add()
Called 36 times
Total time:   0.004100
 Self time:   0.004100

count  total (s)   self (s)
   36              0.000181     if g:ale_max_buffer_history_size <= 0
                                    " Don't save anything if the history isn't a positive number.
                                    call setbufvar(a:buffer, 'ale_history', [])
                            
                                    return
                                endif
                            
   36              0.000376     let l:history = getbufvar(a:buffer, 'ale_history', [])
                            
                                " Remove the first item if we hit the max history size.
   36              0.000257     if len(l:history) >= g:ale_max_buffer_history_size
   36              0.000811         let l:history = l:history[1:]
   36              0.000061     endif
                            
   36              0.000427     call add(l:history, {   'status': a:status,   'job_id': a:job_id,   'command': a:command,})
                            
   36              0.001312     call setbufvar(a:buffer, 'ale_history', l:history)

FUNCTION  ale#util#FindItemAtCursor()
Called 9 times
Total time:   0.002289
 Self time:   0.000561

count  total (s)   self (s)
    9              0.000101     let l:info = get(g:ale_buffer_info, a:buffer, {})
    9              0.000069     let l:loclist = get(l:info, 'loclist', [])
    9              0.000063     let l:pos = getpos('.')
    9   0.001920   0.000192     let l:index = ale#util#BinarySearch(l:loclist, a:buffer, l:pos[1], l:pos[2])
    9              0.000062     let l:loc = l:index >= 0 ? l:loclist[l:index] : {}
                            
    9              0.000039     return [l:info, l:loc]

FUNCTION  ale#linter#GetExecutable()
Called 45 times
Total time:   0.029918
 Self time:   0.001533

count  total (s)   self (s)
   45              0.000618     let l:Executable = has_key(a:linter, 'executable_callback')   ? function(a:linter.executable_callback)   : a:linter.executable
                            
   45   0.029170   0.000785     return type(l:Executable) is v:t_func   ? l:Executable(a:buffer)   : l:Executable

FUNCTION  <SNR>153_StopCurrentJobs()
Called 9 times
Total time:   0.004585
 Self time:   0.000598

count  total (s)   self (s)
    9              0.000085     let l:info = get(g:ale_buffer_info, a:buffer, {})
    9   0.004136   0.000149     call ale#command#StopJobs(a:buffer, 'linter')
                            
                                " Update the active linter list, clearing out anything not running.
    9              0.000031     if a:clear_lint_file_jobs
                                    call ale#command#StopJobs(a:buffer, 'file_linter')
                                    let l:info.active_linter_list = []
                                else
                                    " Keep jobs for linting files when we're only linting buffers.
    9              0.000196         call filter(l:info.active_linter_list, 'get(v:val, ''lint_file'')')
    9              0.000016     endif

FUNCTION  <SNR>123_Pyeval()
Called 315 times
Total time:   0.489483
 Self time:   0.489483

count  total (s)   self (s)
  315              0.001228   if s:using_python3
  315              0.487741     return py3eval( a:eval_string )
                              endif
                              return pyeval( a:eval_string )

FUNCTION  airline#highlighter#highlight_modified_inactive()
Called 8 times
Total time:   0.007578
 Self time:   0.000644

count  total (s)   self (s)
    8              0.000070   if getbufvar(a:bufnr, '&modified')
    8              0.000170     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
    8              0.000015   else
                                let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
                              endif
                            
    8              0.000038   if !empty(colors)
    8   0.007159   0.000225     call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
    8              0.000013   endif

FUNCTION  <SNR>165_StopCursorTimer()
Called 10 times
Total time:   0.000226
 Self time:   0.000226

count  total (s)   self (s)
   10              0.000040     if s:cursor_timer != -1
   10              0.000062         call timer_stop(s:cursor_timer)
   10              0.000057         let s:cursor_timer = -1
   10              0.000016     endif

FUNCTION  airline#extensions#branch#get_head()
Called 102 times
Total time:   0.269587
 Self time:   0.009545

count  total (s)   self (s)
  102   0.256306   0.002870   let head = airline#extensions#branch#head()
  102   0.002435   0.001520   let winwidth = get(airline#parts#get('branch'), 'minwidth', 120)
  102              0.000940   let minwidth = empty(get(b:, 'airline_hunks', '')) ? 14 : 7
  102   0.006998   0.001308   let head = airline#util#shorten(head, winwidth, minwidth)
  102              0.000996   let symbol = get(g:, 'airline#extensions#branch#symbol', g:airline_symbols.branch)
  102              0.001603   return empty(head) ? get(g:, 'airline#extensions#branch#empty_message', '') : printf('%s%s', empty(symbol) ? '' : symbol.(g:airline_symbols.space), head)

FUNCTION  ale#util#Tempname()
Called 9 times
Total time:   0.000422
 Self time:   0.000422

count  total (s)   self (s)
    9              0.000047     let l:clear_tempdir = 0
                            
    9              0.000076     if exists('$TMPDIR') && empty($TMPDIR)
                                    let l:clear_tempdir = 1
                                    let $TMPDIR = '/tmp'
                                endif
                            
    9              0.000016     try
    9              0.000066         let l:name = tempname() " no-custom-checks
    9              0.000020     finally
    9              0.000024         if l:clear_tempdir
                                        let $TMPDIR = ''
                                    endif
    9              0.000015     endtry
                            
    9              0.000025     return l:name

FUNCTION  <SNR>160_StartWithCommand()
Called 9 times
Total time:   0.026018
 Self time:   0.000500

count  total (s)   self (s)
    9   0.000165   0.000089     if ale#command#IsDeferred(a:command)
                                    let a:command.result_callback = {   command -> s:StartWithCommand(a:options, a:executable, command)}
                            
                                    return 1
                                endif
                            
    9              0.000038     if empty(a:command)
                                    return 0
                                endif
                            
    9   0.025658   0.000216     return s:StartLSP(a:options, '', a:executable, a:command)

FUNCTION  airline#extensions#hunks#get_hunks()
Called 102 times
Total time:   0.052367
 Self time:   0.023994

count  total (s)   self (s)
  102              0.000704   if !get(w:, 'airline_active', 0)
                                return ''
                              endif
                              " Cache values, so that it isn't called too often
  102   0.005849   0.004726   if exists("b:airline_hunks") && get(b:,  'airline_changenr', 0) == b:changedtick && airline#util#winwidth() == get(s:, 'airline_winwidth', 0) && get(b:, 'source_func', '') isnot# 's:get_hunks_signify' && get(b:, 'source_func', '') isnot# 's:get_hunks_gitgutter' && get(b:, 'source_func', '') isnot# 's:get_hunks_empty' && get(b:, 'source_func', '') isnot# 's:get_hunks_changes'
                                return b:airline_hunks
                              endif
  102   0.018321   0.001142   let hunks = airline#extensions#hunks#get_raw_hunks()
  102              0.000326   let string = ''
  102   0.002425   0.001492   let winwidth = get(airline#parts#get('hunks'), 'minwidth', 100)
  102              0.000423   if !empty(hunks)
  408              0.001254     for i in [0, 1, 2]
  306   0.010951   0.003690       if (s:non_zero_only == 0 && airline#util#winwidth() > winwidth) || hunks[i] > 0
  306              0.003833         let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
  306              0.000485       endif
  306              0.000473     endfor
  102              0.000120   endif
  102              0.000431   let b:airline_hunks = string
  102              0.000411   let b:airline_changenr = b:changedtick
  102   0.002907   0.001029   let s:airline_winwidth = airline#util#winwidth()
  102              0.000251   return string

FUNCTION  ale#command#FormatCommand()
Called 18 times
Total time:   0.014117
 Self time:   0.005166

count  total (s)   self (s)
   18              0.000135     let l:temporary_file = ''
   18              0.000084     let l:command = a:command
                            
                                " First replace all uses of %%, used for literal percent characters,
                                " with an ugly string.
   18              0.000352     let l:command = substitute(l:command, '%%', '<<PERCENTS>>', 'g')
                            
                                " Replace %e with the escaped executable, if available.
   18              0.000197     if !empty(a:executable) && l:command =~# '%e'
    9   0.000634   0.000275         let l:command = substitute(l:command, '%e', '\=ale#Escape(a:executable)', 'g')
    9              0.000015     endif
                            
                                " Replace all %s occurrences in the string with the name of the current
                                " file.
   18              0.000129     if l:command =~# '%s'
    9              0.000982         let l:filename = fnamemodify(bufname(a:buffer), ':p')
    9   0.000564   0.000267         let l:command = substitute(l:command, '%s', '\=ale#Escape(l:filename)', 'g')
    9              0.000015     endif
                            
   18              0.000132     if a:input isnot v:false && l:command =~# '%t'
                                    " Create a temporary filename, <temp_dir>/<original_basename>
                                    " The file itself will not be created by this function.
                                    let l:temporary_file = s:TemporaryFilename(a:buffer)
                                    let l:command = substitute(l:command, '%t', '\=ale#Escape(l:temporary_file)', 'g')
                                endif
                            
                                " Finish formatting so %% becomes %.
   18              0.000278     let l:command = substitute(l:command, '<<PERCENTS>>', '%', 'g')
                            
   18              0.000103     if a:pipe_file_if_needed && empty(l:temporary_file)
                                    " If we are to send the Vim buffer to a command, we'll do it
                                    " in the shell. We'll write out the file to a temporary file,
                                    " and then read it back in, in the shell.
    9   0.001096   0.000138         let l:temporary_file = s:TemporaryFilename(a:buffer)
    9   0.000424   0.000144         let l:command = l:command . ' < ' . ale#Escape(l:temporary_file)
    9              0.000013     endif
                            
   18   0.007831   0.000775     let l:file_created = ale#command#CreateTempFile(   a:buffer,   l:temporary_file,   a:input,)
                            
   18              0.000125     return [l:temporary_file, l:command, l:file_created]

FUNCTION  gitgutter#utility#getbufvar()
Called 102 times
Total time:   0.003343
 Self time:   0.003343

count  total (s)   self (s)
  102              0.000830   let bvars = getbufvar(a:buffer, '')
  102              0.000428   if !empty(bvars)
  102              0.000779     let dict = get(bvars, 'gitgutter', {})
  102              0.000604     if has_key(dict, a:varname)
  102              0.000432       return dict[a:varname]
                                endif
                              endif
                              if a:0
                                return a:1
                              endif

FUNCTION  ale#command#RemoveManagedFiles()
Called 2 times
Total time:   0.003801
 Self time:   0.003762

count  total (s)   self (s)
    2              0.000019     let l:info = get(s:buffer_data, a:buffer, {})
                            
    2              0.000010     if !empty(l:info) && empty(l:info.jobs)
                                    " We can't delete anything in a sandbox, so wait until we escape from
                                    " it to delete temporary files and directories.
    2   0.000054   0.000016         if ale#util#InSandbox()
                                        return
                                    endif
                            
                                    " Delete files with a call akin to a plan `rm` command.
    2              0.000008         for l:filename in l:info.file_list
                                        call delete(l:filename)
                                    endfor
                            
                                    " Delete directories like `rm -rf`.
                                    " Directories are handled differently from files, so paths that are
                                    " intended to be single files can be set up for automatic deletion
                                    " without accidentally deleting entire directories.
   11              0.000043         for l:directory in l:info.directory_list
    9              0.003550             call delete(l:directory, 'rf')
    9              0.000031         endfor
                            
    2              0.000021         call remove(s:buffer_data, a:buffer)
    2              0.000004     endif

FUNCTION  <SNR>171_syn_sol()
Called 2 times
Total time:   0.000233
 Self time:   0.000233

count  total (s)   self (s)
    2              0.000014   let line = getline(a:lnum)
    2              0.000052   let sol = matchstr(line, '^\s*')
    2              0.000162   return map(synstack(a:lnum, len(sol) + 1), 'synIDattr(v:val, "name")')

FUNCTION  ale#job#ValidateArguments()
Called 9 times
Total time:   0.000116
 Self time:   0.000116

count  total (s)   self (s)
    9              0.000057     if a:options.mode isnot# 'nl' && a:options.mode isnot# 'raw'
                                    throw 'Invalid mode: ' . a:options.mode
                                endif

FUNCTION  ale#sign#GetSignCommands()
Called 20 times
Total time:   0.005453
 Self time:   0.005453

count  total (s)   self (s)
   20              0.000093     let l:command_list = []
   20              0.000090     let l:is_dummy_sign_set = a:was_sign_set
                            
                                " Set the dummy sign if we need to.
                                " The dummy sign is needed to keep the sign column open while we add
                                " and remove signs.
   20              0.000122     if !l:is_dummy_sign_set && (!empty(a:sign_map) || g:ale_sign_column_always)
                                    call add(l:command_list, 'sign place '   .  g:ale_sign_offset   . ' line=1 name=ALEDummySign buffer='   . a:buffer)
                                    let l:is_dummy_sign_set = 1
                                endif
                            
                                " Place new items first.
   58              0.000367     for [l:line_str, l:info] in items(a:sign_map)
   38              0.000102         if l:info.new_id
                                        " Save the sign IDs we are setting back on our loclist objects.
                                        " These IDs will be used to preserve items which are set many times.
  124              0.000302             for l:item in l:info.items
   87              0.000360                 let l:item.sign_id = l:info.new_id
   87              0.000167             endfor
                            
   37              0.000199             if index(l:info.current_id_list, l:info.new_id) < 0
    1              0.000008                 call add(l:command_list, 'sign place '   . (l:info.new_id)   . ' line=' . l:line_str   . ' name=' . (l:info.new_name)   . ' buffer=' . a:buffer)
    1              0.000001             endif
   37              0.000040         endif
   38              0.000037     endfor
                            
                                " Remove signs without new IDs.
   58              0.000212     for l:info in values(a:sign_map)
   75              0.000191         for l:current_id in l:info.current_id_list
   37              0.000116             if l:current_id isnot l:info.new_id
    1              0.000014                 call add(l:command_list, 'sign unplace '   . l:current_id   . ' buffer=' . a:buffer)
    1              0.000002             endif
   37              0.000063         endfor
   38              0.000039     endfor
                            
                                " Remove the dummy sign to close the sign column if we need to.
   20              0.000079     if l:is_dummy_sign_set && !g:ale_sign_column_always
                                    call add(l:command_list, 'sign unplace '   . g:ale_sign_offset   . ' buffer=' . a:buffer)
                                endif
                            
   20              0.000053     return l:command_list

FUNCTION  airline#util#prepend()
Called 408 times
Total time:   0.006708
 Self time:   0.006708

count  total (s)   self (s)
  408              0.002626   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
                              endif
  408              0.002402   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  <SNR>134_skip_func()
Called 1 time
Total time:   0.000077
 Self time:   0.000077

count  total (s)   self (s)
    1              0.000024   if !s:free || search('\m`\|\${\|\*\/','nW',s:looksyn)
                            	let s:free = !eval(s:skip_expr)
                            	let s:looksyn = line('.')
                            	return !s:free
                              endif
    1              0.000006   let s:looksyn = line('.')
    1              0.000031   return getline('.') =~ '\%<'.col('.').'c\/.\{-}\/\|\%>'.col('.').'c[''"]\|\\$' && eval(s:skip_expr)

FUNCTION  ale#command#StopJobs()
Called 9 times
Total time:   0.003987
 Self time:   0.001307

count  total (s)   self (s)
    9              0.000082     let l:info = get(s:buffer_data, a:buffer, {})
                            
    9              0.000038     if !empty(l:info)
    7              0.000027         let l:new_map = {}
                            
   14              0.000129         for [l:job_id, l:job_type] in items(l:info.jobs)
    7              0.000048             let l:job_id = str2nr(l:job_id)
                            
    7              0.000048             if a:job_type is# 'all' || a:job_type is# l:job_type
    7   0.002774   0.000094                 call ale#job#Stop(l:job_id)
    7              0.000012             else
                                            let l:new_map[l:job_id] = l:job_type
                                        endif
    7              0.000015         endfor
                            
    7              0.000207         let l:info.jobs = l:new_map
    7              0.000278     endif

FUNCTION  <SNR>45_on_cursor_moved()
Called 10 times
Total time:   0.000533
 Self time:   0.000372

count  total (s)   self (s)
   10              0.000087   if winnr() != s:active_winnr
                                call s:on_window_changed('CursorMoved')
                              endif
   10   0.000335   0.000174   call airline#update_tabline()

FUNCTION  <SNR>61_TriggerAbb()
Called 3 times
Total time:   0.000110
 Self time:   0.000110

count  total (s)   self (s)
    3              0.000066 	if v:version < 703 || ( v:version == 703 && !has('patch489') ) || pumvisible()
                            		return ''
                            	endif
    3              0.000015 	return "\<C-]>"

FUNCTION  ale#cursor#EchoCursorWarningWithDelay()
Called 10 times
Total time:   0.001769
 Self time:   0.001153

count  total (s)   self (s)
   10              0.000085     let l:buffer = bufnr('')
                            
   10              0.000043     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
                                endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
   10              0.000058     if mode(1) isnot# 'n'
                                    return
                                endif
                            
   10   0.000355   0.000129     call s:StopCursorTimer()
                            
   10              0.000115     let l:pos = getpos('.')[0:2]
                            
                                " Check the current buffer, line, and column number against the last
                                " recorded position. If the position has actually changed, *then*
                                " we should echo something. Otherwise we can end up doing processing
                                " the echo message far too frequently.
   10              0.000115     if l:pos != s:last_pos
   10   0.000534   0.000143         let l:delay = ale#Var(l:buffer, 'echo_delay')
                            
   10              0.000132         let s:last_pos = l:pos
   10              0.000125         let s:cursor_timer = timer_start(   l:delay,   function('ale#cursor#EchoCursorWarning'))
   10              0.000016     endif

FUNCTION  <SNR>108_exec_separator()
Called 168 times
Total time:   0.233513
 Self time:   0.014933

count  total (s)   self (s)
  168              0.000749   if pumvisible()
                                return
                              endif
  168              0.001400   let group = a:from.'_to_'.a:to.a:suffix
  168   0.057745   0.002290   let l:from = airline#themes#get_highlight(a:from.a:suffix)
  168   0.072616   0.002178   let l:to = airline#themes#get_highlight(a:to.a:suffix)
  168              0.000415   if a:inverse
   72              0.000633     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
   72              0.000108   else
   96              0.000763     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
   96              0.000125   endif
  168              0.001582   let a:dict[group] = colors
  168   0.095293   0.002608   call airline#highlighter#exec(group, colors)

FUNCTION  <SNR>154_ExitCallback()
Called 9 times
Total time:   0.017725
 Self time:   0.000575

count  total (s)   self (s)
    9              0.000078     if !has_key(s:buffer_data, a:buffer)
                                    return
                                endif
                            
    9              0.000065     let l:jobs = s:buffer_data[a:buffer].jobs
                            
    9              0.000057     if !has_key(l:jobs, a:data.job_id)
    7              0.000013         return
                                endif
                            
    2              0.000014     let l:job_type = remove(l:jobs, a:data.job_id)
                            
    2              0.000005     if g:ale_history_enabled
    2   0.000300   0.000033         call ale#history#SetExitCode(a:buffer, a:data.job_id, a:data.exit_code)
                            
                                    " Log the output of the command for ALEInfo if we should.
    2              0.000011         if g:ale_history_log_output && a:data.log_output is 1
    2   0.000303   0.000050             call ale#history#RememberOutput(   a:buffer,   a:data.job_id,   a:line_list[:])
    2              0.000003         endif
    2              0.000002     endif
                            
                                " If the callback starts any new jobs, use the same job type for them.
    2              0.000018     call setbufvar(a:buffer, 'ale_job_type', l:job_type)
    2   0.016713   0.000083     let l:value = a:Callback(a:buffer, a:line_list, {   'exit_code': a:data.exit_code,   'temporary_file': a:data.temporary_file,})
                            
    2              0.000012     let l:result = a:data.result
    2              0.000010     let l:result.value = l:value
                            
    2              0.000017     if get(l:result, 'result_callback', v:null) isnot v:null
                                    call call(l:result.result_callback, [l:value])
                                endif

FUNCTION  <SNR>173_GroupLoclistItems()
Called 20 times
Total time:   0.003383
 Self time:   0.003383

count  total (s)   self (s)
   20              0.000091     let l:grouped_items = []
   20              0.000066     let l:last_lnum = -1
                            
  107              0.000263     for l:obj in a:loclist
   87              0.000276         if l:obj.bufnr != a:buffer
                                        continue
                                    endif
                            
                                    " Create a new sub-List when we hit a new line.
   87              0.000255         if l:obj.lnum != l:last_lnum
   37              0.000180             call add(l:grouped_items, [])
   37              0.000047         endif
                            
   87              0.000482         call add(l:grouped_items[-1], l:obj)
   87              0.000307         let l:last_lnum = l:obj.lnum
   87              0.000151     endfor
                            
   20              0.000055     return l:grouped_items

FUNCTION  ale#sign#ReadSigns()
Called 20 times
Total time:   0.002277
 Self time:   0.002277

count  total (s)   self (s)
   20              0.000118     redir => l:output
   20              0.001475         silent execute 'sign place buffer=' . a:buffer
   20              0.000136     redir end
                            
   20              0.000496     return split(l:output, "\n")

FUNCTION  <SNR>171_syn_xmlish()
Called 2 times
Total time:   0.000097
 Self time:   0.000073

count  total (s)   self (s)
    2   0.000095   0.000071   return s:syn_attr_jsx(get(a:syns, -1))

FUNCTION  airline#extensions#ale#get_warning()
Called 102 times
Total time:   0.016768
 Self time:   0.001604

count  total (s)   self (s)
  102   0.016576   0.001412   return airline#extensions#ale#get('warning')

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
  700   5.547746             provider#python3#Call()
  179   3.407786             UltiSnips#TrackChange()
   85   2.086566   0.223469  <SNR>123_OnTextChangedInsertMode()
   84   1.534175   1.350511  <SNR>123_InvokeCompletion()
  315   0.489483             <SNR>123_Pyeval()
  110   0.461161   0.029790  airline#check_mode()
    8   0.421991   0.055229  airline#highlighter#highlight()
  102   0.269587   0.009545  airline#extensions#branch#get_head()
  102   0.253436   0.005604  airline#extensions#branch#head()
  710   0.234352   0.101790  airline#highlighter#get_highlight()
  168   0.233513   0.014933  <SNR>108_exec_separator()
  374   0.226791   0.061304  airline#highlighter#exec()
   98   0.215752   0.005998  <SNR>123_PollCompletion()
  102   0.214958   0.011109  <SNR>97_update_branch()
   85   0.197096   0.012428  <SNR>123_IdentifierFinishedOperations()
   29   0.194133   0.003525  <SNR>159_NeoVimCallback()
  102   0.192005   0.005672  <SNR>97_update_git_branch()
  102   0.185407   0.003522  FugitiveHead()
  102   0.180723   0.024646  fugitive#Head()
    9   0.173263   0.002615  <SNR>113_Lint()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
  700              5.547746  provider#python3#Call()
  179              3.407786  UltiSnips#TrackChange()
   84   1.534175   1.350511  <SNR>123_InvokeCompletion()
  315              0.489483  <SNR>123_Pyeval()
   85   2.086566   0.223469  <SNR>123_OnTextChangedInsertMode()
 1420              0.119261  <SNR>108_get_syn()
  204   0.156077   0.105771  fugitive#Find()
  710   0.234352   0.101790  airline#highlighter#get_highlight()
    7   0.084631   0.066024  <SNR>123_OnInsertLeave()
  374   0.226791   0.061304  airline#highlighter#exec()
  187              0.056029  <SNR>77_Highlight_Matching_Pair()
    8   0.421991   0.055229  airline#highlighter#highlight()
   85              0.037704  <SNR>123_InsideCommentOrString()
    9   0.037628   0.037512  ale#job#Start()
   72              0.034157  ale#path#FindNearestFile()
  252   0.033055   0.030074  <SNR>123_AllowedToCompleteInBuffer()
  102   0.032874   0.029854  <SNR>97_update_untracked()
  110   0.461161   0.029790  airline#check_mode()
   84              0.027710  ale#util#LocItemCompare()
  102   0.032896   0.026874  airline#extensions#whitespace#check()

