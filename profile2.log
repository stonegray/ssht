SCRIPT  /Volumes/User/.vim/bundle/ale/autoload/ale/fix.vim
Sourced 1 time
Total time:   0.002459
 Self time:   0.002421

count  total (s)   self (s)
    1   0.000078   0.000041 call ale#Set('fix_on_save_ignore', {})
                            
                            " Apply fixes queued up for buffers which may be hidden.
                            " Vim doesn't let you modify hidden buffers.
    1              0.000004 function! ale#fix#ApplyQueuedFixes(buffer) abort
                                let l:data = get(g:ale_fix_buffer_data, a:buffer, {'done': 0})
                                let l:has_bufline_api = exists('*deletebufline') && exists('*setbufline')
                            
                                if !l:data.done || (!l:has_bufline_api && a:buffer isnot bufnr(''))
                                    return
                                endif
                            
                                call remove(g:ale_fix_buffer_data, a:buffer)
                            
                                if l:data.changes_made
                                    " If the file is in DOS mode, we have to remove carriage returns from
                                    " the ends of lines before calling setline(), or we will see them
                                    " twice.
                                    let l:new_lines = getbufvar(a:buffer, '&fileformat') is# 'dos'
                                    \   ? map(copy(l:data.output), 'substitute(v:val, ''\r\+$'', '''', '''')')
                                    \   : l:data.output
                                    let l:first_line_to_remove = len(l:new_lines) + 1
                            
                                    " Use a Vim API for setting lines in other buffers, if available.
                                    if l:has_bufline_api
                                        call setbufline(a:buffer, 1, l:new_lines)
                                        call deletebufline(a:buffer, l:first_line_to_remove, '$')
                                    " Fall back on setting lines the old way, for the current buffer.
                                    else
                                        let l:old_line_length = len(l:data.lines_before)
                            
                                        if l:old_line_length >= l:first_line_to_remove
                                            let l:save = winsaveview()
                                            silent execute
                                            \   l:first_line_to_remove . ',' . l:old_line_length . 'd_'
                                            call winrestview(l:save)
                                        endif
                            
                                        call setline(1, l:new_lines)
                                    endif
                            
                                    if l:data.should_save
                                        if a:buffer is bufnr('')
                                            if empty(&buftype)
                                                noautocmd :w!
                                            else
                                                set nomodified
                                            endif
                                        else
                                            call writefile(l:new_lines, expand(a:buffer . ':p')) " no-custom-checks
                                            call setbufvar(a:buffer, '&modified', 0)
                                        endif
                                    endif
                                endif
                            
                                if l:data.should_save
                                    let l:should_lint = ale#Var(a:buffer, 'fix_on_save')
                                    \   && ale#Var(a:buffer, 'lint_on_save')
                                else
                                    let l:should_lint = l:data.changes_made
                                endif
                            
                                silent doautocmd <nomodeline> User ALEFixPost
                            
                                " If ALE linting is enabled, check for problems with the file again after
                                " fixing problems.
                                if g:ale_enabled
                                \&& l:should_lint
                                \&& !ale#events#QuitRecently(a:buffer)
                                    call ale#Queue(0, l:data.should_save ? 'lint_file' : '')
                                endif
                            endfunction
                            
    1              0.000006 function! ale#fix#ApplyFixes(buffer, output) abort
                                let l:data = g:ale_fix_buffer_data[a:buffer]
                                let l:data.output = a:output
                                let l:data.changes_made = l:data.lines_before != l:data.output
                                let l:data.done = 1
                            
                                call ale#command#RemoveManagedFiles(a:buffer)
                            
                                if !bufexists(a:buffer)
                                    " Remove the buffer data when it doesn't exist.
                                    call remove(g:ale_fix_buffer_data, a:buffer)
                                endif
                            
                                if l:data.changes_made && bufexists(a:buffer)
                                    let l:lines = getbufline(a:buffer, 1, '$')
                            
                                    if l:data.lines_before != l:lines
                                        call remove(g:ale_fix_buffer_data, a:buffer)
                                        execute 'echoerr ''The file was changed before fixing finished'''
                            
                                        return
                                    endif
                                endif
                            
                                " We can only change the lines of a buffer which is currently open,
                                " so try and apply the fixes to the current buffer.
                                call ale#fix#ApplyQueuedFixes(a:buffer)
                            endfunction
                            
    1              0.000009 function! s:HandleExit(job_info, buffer, job_output, data) abort
                                let l:buffer_info = get(g:ale_fix_buffer_data, a:buffer, {})
                            
                                if empty(l:buffer_info)
                                    return
                                endif
                            
                                if a:job_info.read_temporary_file
                                    let l:output = !empty(a:data.temporary_file)
                                    \   ?  readfile(a:data.temporary_file)
                                    \   : []
                                else
                                    let l:output = a:job_output
                                endif
                            
                                let l:ChainCallback = get(a:job_info, 'chain_with', v:null)
                                let l:ProcessWith = get(a:job_info, 'process_with', v:null)
                            
                                " Post-process the output with a function if we have one.
                                if l:ProcessWith isnot v:null
                                    let l:output = call(l:ProcessWith, [a:buffer, l:output])
                                endif
                            
                                " Use the output of the job for changing the file if it isn't empty,
                                " otherwise skip this job and use the input from before.
                                "
                                " We'll use the input from before for chained commands.
                                if l:ChainCallback is v:null && !empty(split(join(l:output)))
                                    let l:input = l:output
                                else
                                    let l:input = a:job_info.input
                                endif
                            
                                if l:ChainCallback isnot v:null && !get(g:, 'ale_ignore_2_4_warnings')
                                    execute 'echom ''chain_with is deprecated. Use `let g:ale_ignore_2_4_warnings = 1` to disable this message.'''
                                endif
                            
                                let l:next_index = l:ChainCallback is v:null
                                \   ? a:job_info.callback_index + 1
                                \   : a:job_info.callback_index
                            
                                call s:RunFixer({
                                \   'buffer': a:buffer,
                                \   'input': l:input,
                                \   'output': l:output,
                                \   'callback_list': a:job_info.callback_list,
                                \   'callback_index': l:next_index,
                                \   'chain_callback': l:ChainCallback,
                                \})
                            endfunction
                            
    1              0.000009 function! s:RunJob(result, options) abort
                                if ale#command#IsDeferred(a:result)
                                    let a:result.result_callback = {x -> s:RunJob(x, a:options)}
                            
                                    return
                                endif
                            
                                let l:buffer = a:options.buffer
                                let l:input = a:options.input
                            
                                if a:result is 0 || type(a:result) is v:t_list
                                    if type(a:result) is v:t_list
                                        let l:input = a:result
                                    endif
                            
                                    call s:RunFixer({
                                    \   'buffer': l:buffer,
                                    \   'input': l:input,
                                    \   'callback_index': a:options.callback_index + 1,
                                    \   'callback_list': a:options.callback_list,
                                    \})
                            
                                    return
                                endif
                            
                                let l:command = get(a:result, 'command', '')
                                let l:ChainWith = get(a:result, 'chain_with', v:null)
                            
                                if empty(l:command)
                                    " If the command is empty, skip to the next item, or call the
                                    " chain_with function.
                                    call s:RunFixer({
                                    \   'buffer': l:buffer,
                                    \   'input': l:input,
                                    \   'callback_index': a:options.callback_index + (l:ChainWith is v:null),
                                    \   'callback_list': a:options.callback_list,
                                    \   'chain_callback': l:ChainWith,
                                    \   'output': [],
                                    \})
                            
                                    return
                                endif
                            
                                let l:read_temporary_file = get(a:result, 'read_temporary_file', 0)
                                " Default to piping the buffer for the last fixer in the chain.
                                let l:read_buffer = get(a:result, 'read_buffer', l:ChainWith is v:null)
                                let l:output_stream = get(a:result, 'output_stream', 'stdout')
                            
                                if l:read_temporary_file
                                    let l:output_stream = 'none'
                                endif
                            
                                let l:Callback = function('s:HandleExit', [{
                                \   'input': l:input,
                                \   'chain_with': l:ChainWith,
                                \   'callback_index': a:options.callback_index,
                                \   'callback_list': a:options.callback_list,
                                \   'process_with': get(a:result, 'process_with', v:null),
                                \   'read_temporary_file': l:read_temporary_file,
                                \}])
                                let l:run_result = ale#command#Run(l:buffer, l:command, l:Callback, {
                                \   'output_stream': l:output_stream,
                                \   'executable': '',
                                \   'read_buffer': l:read_buffer,
                                \   'input': l:input,
                                \   'log_output': 0,
                                \})
                            
                                if empty(l:run_result)
                                    call s:RunFixer({
                                    \   'buffer': l:buffer,
                                    \   'input': l:input,
                                    \   'callback_index': a:options.callback_index + 1,
                                    \   'callback_list': a:options.callback_list,
                                    \})
                                endif
                            endfunction
                            
    1              0.000007 function! s:RunFixer(options) abort
                                let l:buffer = a:options.buffer
                                let l:input = a:options.input
                                let l:index = a:options.callback_index
                            
                                if len(a:options.callback_list) <= l:index
                                    call ale#fix#ApplyFixes(l:buffer, l:input)
                            
                                    return
                                endif
                            
                                let l:ChainCallback = get(a:options, 'chain_callback', v:null)
                            
                                let l:Function = l:ChainCallback isnot v:null
                                \   ? ale#util#GetFunction(l:ChainCallback)
                                \   : a:options.callback_list[l:index]
                            
                                " Record new jobs started as fixer jobs.
                                call setbufvar(l:buffer, 'ale_job_type', 'fixer')
                            
                                if l:ChainCallback isnot v:null
                                    " Chained commands accept (buffer, output, [input])
                                    let l:result = ale#util#FunctionArgCount(l:Function) == 2
                                    \   ? call(l:Function, [l:buffer, a:options.output])
                                    \   : call(l:Function, [l:buffer, a:options.output, copy(l:input)])
                                else
                                    " Regular fixer commands accept (buffer, [input])
                                    let l:result = ale#util#FunctionArgCount(l:Function) == 1
                                    \   ? call(l:Function, [l:buffer])
                                    \   : call(l:Function, [l:buffer, copy(l:input)])
                                endif
                            
                                call s:RunJob(l:result, {
                                \   'buffer': l:buffer,
                                \   'input': l:input,
                                \   'callback_list': a:options.callback_list,
                                \   'callback_index': l:index,
                                \})
                            endfunction
                            
    1              0.000007 function! s:AddSubCallbacks(full_list, callbacks) abort
                                if type(a:callbacks) is v:t_string
                                    call add(a:full_list, a:callbacks)
                                elseif type(a:callbacks) is v:t_list
                                    call extend(a:full_list, a:callbacks)
                                else
                                    return 0
                                endif
                            
                                return 1
                            endfunction
                            
    1              0.000005 function! s:IgnoreFixers(callback_list, filetype, config) abort
                                if type(a:config) is v:t_list
                                    let l:ignore_list = a:config
                                else
                                    let l:ignore_list = []
                            
                                    for l:part in split(a:filetype , '\.')
                                        call extend(l:ignore_list, get(a:config, l:part, []))
                                    endfor
                                endif
                            
                                call filter(a:callback_list, 'index(l:ignore_list, v:val) < 0')
                            endfunction
                            
    1              0.000005 function! s:GetCallbacks(buffer, fixing_flag, fixers) abort
                                if len(a:fixers)
                                    let l:callback_list = a:fixers
                                elseif type(get(b:, 'ale_fixers')) is v:t_list
                                    " Lists can be used for buffer-local variables only
                                    let l:callback_list = b:ale_fixers
                                else
                                    " buffer and global options can use dictionaries mapping filetypes to
                                    " callbacks to run.
                                    let l:fixers = ale#Var(a:buffer, 'fixers')
                                    let l:callback_list = []
                                    let l:matched = 0
                            
                                    for l:sub_type in split(&filetype, '\.')
                                        if s:AddSubCallbacks(l:callback_list, get(l:fixers, l:sub_type))
                                            let l:matched = 1
                                        endif
                                    endfor
                            
                                    " If we couldn't find fixers for a filetype, default to '*' fixers.
                                    if !l:matched
                                        call s:AddSubCallbacks(l:callback_list, get(l:fixers, '*'))
                                    endif
                                endif
                            
                                if a:fixing_flag is# 'save_file'
                                    let l:config = ale#Var(a:buffer, 'fix_on_save_ignore')
                            
                                    if !empty(l:config)
                                        call s:IgnoreFixers(l:callback_list, &filetype, l:config)
                                    endif
                                endif
                            
                                let l:corrected_list = []
                            
                                " Variables with capital characters are needed, or Vim will complain about
                                " funcref variables.
                                for l:Item in l:callback_list
                                    if type(l:Item) is v:t_string
                                        let l:Func = ale#fix#registry#GetFunc(l:Item)
                            
                                        if !empty(l:Func)
                                            let l:Item = l:Func
                                        endif
                                    endif
                            
                                    try
                                        call add(l:corrected_list, ale#util#GetFunction(l:Item))
                                    catch /E475/
                                        " Rethrow exceptions for failing to get a function so we can print
                                        " a friendly message about it.
                                        throw 'BADNAME ' . v:exception
                                    endtry
                                endfor
                            
                                return l:corrected_list
                            endfunction
                            
    1              0.000008 function! ale#fix#InitBufferData(buffer, fixing_flag) abort
                                " The 'done' flag tells the function for applying changes when fixing
                                " is complete.
                                let g:ale_fix_buffer_data[a:buffer] = {
                                \   'lines_before': getbufline(a:buffer, 1, '$'),
                                \   'done': 0,
                                \   'should_save': a:fixing_flag is# 'save_file',
                                \   'temporary_directory_list': [],
                                \}
                            endfunction
                            
                            " Accepts an optional argument for what to do when fixing.
                            "
                            " Returns 0 if no fixes can be applied, and 1 if fixing can be done.
    1              0.000005 function! ale#fix#Fix(buffer, fixing_flag, ...) abort
                                if a:fixing_flag isnot# '' && a:fixing_flag isnot# 'save_file'
                                    throw "fixing_flag must be either '' or 'save_file'"
                                endif
                            
                                try
                                    let l:callback_list = s:GetCallbacks(a:buffer, a:fixing_flag, a:000)
                                catch /E700\|BADNAME/
                                    let l:function_name = join(split(split(v:exception, ':')[3]))
                                    let l:echo_message = printf(
                                    \   'There is no fixer named `%s`. Check :ALEFixSuggest',
                                    \   l:function_name,
                                    \)
                                    execute 'echom l:echo_message'
                            
                                    return 0
                                endtry
                            
                                if empty(l:callback_list)
                                    if a:fixing_flag is# ''
                                        execute 'echom ''No fixers have been defined. Try :ALEFixSuggest'''
                                    endif
                            
                                    return 0
                                endif
                            
                                call ale#command#StopJobs(a:buffer, 'fixer')
                                " Clean up any files we might have left behind from a previous run.
                                call ale#command#RemoveManagedFiles(a:buffer)
                                call ale#fix#InitBufferData(a:buffer, a:fixing_flag)
                            
                                silent doautocmd <nomodeline> User ALEFixPre
                            
                                call s:RunFixer({
                                \   'buffer': a:buffer,
                                \   'input': g:ale_fix_buffer_data[a:buffer].lines_before,
                                \   'callback_index': 0,
                                \   'callback_list': l:callback_list,
                                \})
                            
                                return 1
                            endfunction
                            
                            " Set up an autocmd command to try and apply buffer fixes when available.
    1              0.000014 augroup ALEBufferFixGroup
    1              0.000291     autocmd!
    1              0.000031     autocmd BufEnter * call ale#fix#ApplyQueuedFixes(str2nr(expand('<abuf>')))

SCRIPT  /Volumes/User/.vim/bundle/ale/autoload/ale/fix/registry.vim
Sourced 1 time
Total time:   0.003606
 Self time:   0.002104

count  total (s)   self (s)
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: A registry of functions for fixing things.
                            
    1              0.001171 let s:default_registry = {
                            \   'add_blank_lines_for_python_control_statements': {
                            \       'function': 'ale#fixers#generic_python#AddLinesBeforeControlStatements',
                            \       'suggested_filetypes': ['python'],
                            \       'description': 'Add blank lines before control statements.',
                            \   },
                            \   'align_help_tags': {
                            \       'function': 'ale#fixers#help#AlignTags',
                            \       'suggested_filetypes': ['help'],
                            \       'description': 'Align help tags to the right margin',
                            \   },
                            \   'autopep8': {
                            \       'function': 'ale#fixers#autopep8#Fix',
                            \       'suggested_filetypes': ['python'],
                            \       'description': 'Fix PEP8 issues with autopep8.',
                            \   },
                            \   'bibclean': {
                            \       'function': 'ale#fixers#bibclean#Fix',
                            \       'suggested_filetypes': ['bib'],
                            \       'description': 'Format bib files using bibclean.',
                            \   },
                            \   'black': {
                            \       'function': 'ale#fixers#black#Fix',
                            \       'suggested_filetypes': ['python'],
                            \       'description': 'Fix PEP8 issues with black.',
                            \   },
                            \   'fecs': {
                            \       'function': 'ale#fixers#fecs#Fix',
                            \       'suggested_filetypes': ['javascript', 'css', 'html'],
                            \       'description': 'Apply fecs format to a file.',
                            \   },
                            \   'tidy': {
                            \       'function': 'ale#fixers#tidy#Fix',
                            \       'suggested_filetypes': ['html'],
                            \       'description': 'Fix HTML files with tidy.',
                            \   },
                            \   'prettier_standard': {
                            \       'function': 'ale#fixers#prettier_standard#Fix',
                            \       'suggested_filetypes': ['javascript'],
                            \       'description': 'Apply prettier-standard to a file.',
                            \       'aliases': ['prettier-standard'],
                            \   },
                            \   'elm-format': {
                            \       'function': 'ale#fixers#elm_format#Fix',
                            \       'suggested_filetypes': ['elm'],
                            \       'description': 'Apply elm-format to a file.',
                            \       'aliases': ['format'],
                            \   },
                            \   'eslint': {
                            \       'function': 'ale#fixers#eslint#Fix',
                            \       'suggested_filetypes': ['javascript', 'typescript'],
                            \       'description': 'Apply eslint --fix to a file.',
                            \   },
                            \   'mix_format': {
                            \       'function': 'ale#fixers#mix_format#Fix',
                            \       'suggested_filetypes': ['elixir'],
                            \       'description': 'Apply mix format to a file.',
                            \   },
                            \   'isort': {
                            \       'function': 'ale#fixers#isort#Fix',
                            \       'suggested_filetypes': ['python'],
                            \       'description': 'Sort Python imports with isort.',
                            \   },
                            \   'prettier': {
                            \       'function': 'ale#fixers#prettier#Fix',
                            \       'suggested_filetypes': ['javascript', 'typescript', 'css', 'less', 'scss', 'json', 'json5', 'graphql', 'markdown', 'vue', 'html', 'yaml'],
                            \       'description': 'Apply prettier to a file.',
                            \   },
                            \   'prettier_eslint': {
                            \       'function': 'ale#fixers#prettier_eslint#Fix',
                            \       'suggested_filetypes': ['javascript'],
                            \       'description': 'Apply prettier-eslint to a file.',
                            \       'aliases': ['prettier-eslint'],
                            \   },
                            \   'importjs': {
                            \       'function': 'ale#fixers#importjs#Fix',
                            \       'suggested_filetypes': ['javascript'],
                            \       'description': 'automatic imports for javascript',
                            \   },
                            \   'puppetlint': {
                            \       'function': 'ale#fixers#puppetlint#Fix',
                            \       'suggested_filetypes': ['puppet'],
                            \       'description': 'Run puppet-lint -f on a file.',
                            \   },
                            \   'remove_trailing_lines': {
                            \       'function': 'ale#fixers#generic#RemoveTrailingBlankLines',
                            \       'suggested_filetypes': [],
                            \       'description': 'Remove all blank lines at the end of a file.',
                            \   },
                            \   'trim_whitespace': {
                            \       'function': 'ale#fixers#generic#TrimWhitespace',
                            \       'suggested_filetypes': [],
                            \       'description': 'Remove all trailing whitespace characters at the end of every line.',
                            \   },
                            \   'yapf': {
                            \       'function': 'ale#fixers#yapf#Fix',
                            \       'suggested_filetypes': ['python'],
                            \       'description': 'Fix Python files with yapf.',
                            \   },
                            \   'rubocop': {
                            \       'function': 'ale#fixers#rubocop#Fix',
                            \       'suggested_filetypes': ['ruby'],
                            \       'description': 'Fix ruby files with rubocop --auto-correct.',
                            \   },
                            \   'rufo': {
                            \       'function': 'ale#fixers#rufo#Fix',
                            \       'suggested_filetypes': ['ruby'],
                            \       'description': 'Fix ruby files with rufo',
                            \   },
                            \   'scalafmt': {
                            \       'function': 'ale#fixers#scalafmt#Fix',
                            \       'suggested_filetypes': ['scala'],
                            \       'description': 'Fix Scala files using scalafmt',
                            \   },
                            \   'standard': {
                            \       'function': 'ale#fixers#standard#Fix',
                            \       'suggested_filetypes': ['javascript'],
                            \       'description': 'Fix JavaScript files using standard --fix',
                            \   },
                            \   'standardrb': {
                            \       'function': 'ale#fixers#standardrb#Fix',
                            \       'suggested_filetypes': ['ruby'],
                            \       'description': 'Fix ruby files with standardrb --fix',
                            \   },
                            \   'stylelint': {
                            \       'function': 'ale#fixers#stylelint#Fix',
                            \       'suggested_filetypes': ['css', 'sass', 'scss', 'sugarss', 'stylus'],
                            \       'description': 'Fix stylesheet files using stylelint --fix.',
                            \   },
                            \   'swiftformat': {
                            \       'function': 'ale#fixers#swiftformat#Fix',
                            \       'suggested_filetypes': ['swift'],
                            \       'description': 'Apply SwiftFormat to a file.',
                            \   },
                            \   'phpcbf': {
                            \       'function': 'ale#fixers#phpcbf#Fix',
                            \       'suggested_filetypes': ['php'],
                            \       'description': 'Fix PHP files with phpcbf.',
                            \   },
                            \   'php_cs_fixer': {
                            \       'function': 'ale#fixers#php_cs_fixer#Fix',
                            \       'suggested_filetypes': ['php'],
                            \       'description': 'Fix PHP files with php-cs-fixer.',
                            \   },
                            \   'clang-format': {
                            \       'function': 'ale#fixers#clangformat#Fix',
                            \       'suggested_filetypes': ['c', 'cpp', 'cuda'],
                            \       'description': 'Fix C/C++ and cuda files with clang-format.',
                            \   },
                            \   'cmakeformat': {
                            \       'function': 'ale#fixers#cmakeformat#Fix',
                            \       'suggested_filetypes': ['cmake'],
                            \       'description': 'Fix CMake files with cmake-format.',
                            \   },
                            \   'gofmt': {
                            \       'function': 'ale#fixers#gofmt#Fix',
                            \       'suggested_filetypes': ['go'],
                            \       'description': 'Fix Go files with go fmt.',
                            \   },
                            \   'goimports': {
                            \       'function': 'ale#fixers#goimports#Fix',
                            \       'suggested_filetypes': ['go'],
                            \       'description': 'Fix Go files imports with goimports.',
                            \   },
                            \   'gomod': {
                            \       'function': 'ale#fixers#gomod#Fix',
                            \       'suggested_filetypes': ['gomod'],
                            \       'description': 'Fix Go module files with go mod edit -fmt.',
                            \   },
                            \   'tslint': {
                            \       'function': 'ale#fixers#tslint#Fix',
                            \       'suggested_filetypes': ['typescript'],
                            \       'description': 'Fix typescript files with tslint --fix.',
                            \   },
                            \   'rustfmt': {
                            \       'function': 'ale#fixers#rustfmt#Fix',
                            \       'suggested_filetypes': ['rust'],
                            \       'description': 'Fix Rust files with Rustfmt.',
                            \   },
                            \   'textlint': {
                            \       'function': 'ale#fixers#textlint#Fix',
                            \       'suggested_filetypes': ['text','markdown','asciidoc','tex'],
                            \       'description': 'Fix text files with textlint --fix',
                            \   },
                            \   'hackfmt': {
                            \       'function': 'ale#fixers#hackfmt#Fix',
                            \       'suggested_filetypes': ['hack'],
                            \       'description': 'Fix Hack files with hackfmt.',
                            \   },
                            \   'floskell': {
                            \       'function': 'ale#fixers#floskell#Fix',
                            \       'suggested_filetypes': ['haskell'],
                            \       'description': 'Fix Haskell files with floskell.',
                            \   },
                            \   'hfmt': {
                            \       'function': 'ale#fixers#hfmt#Fix',
                            \       'suggested_filetypes': ['haskell'],
                            \       'description': 'Fix Haskell files with hfmt.',
                            \   },
                            \   'brittany': {
                            \       'function': 'ale#fixers#brittany#Fix',
                            \       'suggested_filetypes': ['haskell'],
                            \       'description': 'Fix Haskell files with brittany.',
                            \   },
                            \   'hlint': {
                            \       'function': 'ale#fixers#hlint#Fix',
                            \       'suggested_filetypes': ['haskell'],
                            \       'description': 'Refactor Haskell files with hlint.',
                            \   },
                            \   'stylish-haskell': {
                            \       'function': 'ale#fixers#stylish_haskell#Fix',
                            \       'suggested_filetypes': ['haskell'],
                            \       'description': 'Refactor Haskell files with stylish-haskell.',
                            \   },
                            \   'ocamlformat': {
                            \       'function': 'ale#fixers#ocamlformat#Fix',
                            \       'suggested_filetypes': ['ocaml'],
                            \       'description': 'Fix OCaml files with ocamlformat.',
                            \   },
                            \   'ocp-indent': {
                            \       'function': 'ale#fixers#ocp_indent#Fix',
                            \       'suggested_filetypes': ['ocaml'],
                            \       'description': 'Fix OCaml files with ocp-indent.',
                            \   },
                            \   'refmt': {
                            \       'function': 'ale#fixers#refmt#Fix',
                            \       'suggested_filetypes': ['reason'],
                            \       'description': 'Fix ReasonML files with refmt.',
                            \   },
                            \   'shfmt': {
                            \       'function': 'ale#fixers#shfmt#Fix',
                            \       'suggested_filetypes': ['sh'],
                            \       'description': 'Fix sh files with shfmt.',
                            \   },
                            \   'sqlfmt': {
                            \       'function': 'ale#fixers#sqlfmt#Fix',
                            \       'suggested_filetypes': ['sql'],
                            \       'description': 'Fix SQL files with sqlfmt.',
                            \   },
                            \   'google_java_format': {
                            \       'function': 'ale#fixers#google_java_format#Fix',
                            \       'suggested_filetypes': ['java'],
                            \       'description': 'Fix Java files with google-java-format.',
                            \   },
                            \   'fixjson': {
                            \       'function': 'ale#fixers#fixjson#Fix',
                            \       'suggested_filetypes': ['json'],
                            \       'description': 'Fix JSON files with fixjson.',
                            \   },
                            \   'jq': {
                            \       'function': 'ale#fixers#jq#Fix',
                            \       'suggested_filetypes': ['json'],
                            \       'description': 'Fix JSON files with jq.',
                            \   },
                            \   'perltidy': {
                            \       'function': 'ale#fixers#perltidy#Fix',
                            \       'suggested_filetypes': ['perl'],
                            \       'description': 'Fix Perl files with perltidy.',
                            \   },
                            \   'xo': {
                            \       'function': 'ale#fixers#xo#Fix',
                            \       'suggested_filetypes': ['javascript', 'typescript'],
                            \       'description': 'Fix JavaScript/TypeScript files using xo --fix.',
                            \   },
                            \   'qmlfmt': {
                            \       'function': 'ale#fixers#qmlfmt#Fix',
                            \       'suggested_filetypes': ['qml'],
                            \       'description': 'Fix QML files with qmlfmt.',
                            \   },
                            \   'dartfmt': {
                            \       'function': 'ale#fixers#dartfmt#Fix',
                            \       'suggested_filetypes': ['dart'],
                            \       'description': 'Fix Dart files with dartfmt.',
                            \   },
                            \   'xmllint': {
                            \       'function': 'ale#fixers#xmllint#Fix',
                            \       'suggested_filetypes': ['xml'],
                            \       'description': 'Fix XML files with xmllint.',
                            \   },
                            \   'uncrustify': {
                            \       'function': 'ale#fixers#uncrustify#Fix',
                            \       'suggested_filetypes': ['c', 'cpp', 'cs', 'objc', 'objcpp', 'd', 'java', 'p', 'vala' ],
                            \       'description': 'Fix C, C++, C#, ObjectiveC, ObjectiveC++, D, Java, Pawn, and VALA files with uncrustify.',
                            \   },
                            \   'terraform': {
                            \       'function': 'ale#fixers#terraform#Fix',
                            \       'suggested_filetypes': ['hcl', 'terraform'],
                            \       'description': 'Fix tf and hcl files with terraform fmt.',
                            \   },
                            \   'ktlint': {
                            \       'function': 'ale#fixers#ktlint#Fix',
                            \       'suggested_filetypes': ['kt'],
                            \       'description': 'Fix Kotlin files with ktlint.',
                            \   },
                            \   'styler': {
                            \       'function': 'ale#fixers#styler#Fix',
                            \       'suggested_filetypes': ['r', 'rmarkdown'],
                            \       'description': 'Fix R files with styler.',
                            \   },
                            \   'latexindent': {
                            \       'function': 'ale#fixers#latexindent#Fix',
                            \       'suggested_filetypes': ['tex'],
                            \       'description' : 'Indent code within environments, commands, after headings and within special code blocks.',
                            \   },
                            \   'pgformatter': {
                            \       'function': 'ale#fixers#pgformatter#Fix',
                            \       'suggested_filetypes': ['sql'],
                            \       'description': 'A PostgreSQL SQL syntax beautifier',
                            \   },
                            \   'reorder-python-imports': {
                            \       'function': 'ale#fixers#reorder_python_imports#Fix',
                            \       'suggested_filetypes': ['python'],
                            \       'description': 'Sort Python imports with reorder-python-imports.',
                            \   },
                            \}
                            
                            " Reset the function registry to the default entries.
    1              0.000011 function! ale#fix#registry#ResetToDefaults() abort
                                let s:entries = deepcopy(s:default_registry)
                                let s:aliases = {}
                            
                                " Set up aliases for fixers too.
                                for [l:key, l:entry] in items(s:entries)
                                    for l:alias in get(l:entry, 'aliases', [])
                                        let s:aliases[l:alias] = l:key
                                    endfor
                                endfor
                            endfunction
                            
                            " Set up entries now.
    1   0.001537   0.000035 call ale#fix#registry#ResetToDefaults()
                            
                            " Remove everything from the registry, useful for tests.
    1              0.000005 function! ale#fix#registry#Clear() abort
                                let s:entries = {}
                                let s:aliases = {}
                            endfunction
                            
                            " Add a function for fixing problems to the registry.
                            " (name, func, filetypes, desc, aliases)
    1              0.000010 function! ale#fix#registry#Add(name, func, filetypes, desc, ...) abort
                                " This command will throw from the sandbox.
                                let &l:equalprg=&l:equalprg
                            
                                if type(a:name) isnot v:t_string
                                    throw '''name'' must be a String'
                                endif
                            
                                if type(a:func) isnot v:t_string
                                    throw '''func'' must be a String'
                                endif
                            
                                if type(a:filetypes) isnot v:t_list
                                    throw '''filetypes'' must be a List'
                                endif
                            
                                for l:type in a:filetypes
                                    if type(l:type) isnot v:t_string
                                        throw 'Each entry of ''filetypes'' must be a String'
                                    endif
                                endfor
                            
                                if type(a:desc) isnot v:t_string
                                    throw '''desc'' must be a String'
                                endif
                            
                                let l:aliases = get(a:000, 0, [])
                            
                                if type(l:aliases) isnot v:t_list
                                \|| !empty(filter(copy(l:aliases), 'type(v:val) isnot v:t_string'))
                                    throw '''aliases'' must be a List of String values'
                                endif
                            
                                let s:entries[a:name] = {
                                \   'function': a:func,
                                \   'suggested_filetypes': a:filetypes,
                                \   'description': a:desc,
                                \}
                            
                                " Set up aliases for the fixer.
                                if !empty(l:aliases)
                                    let s:entries[a:name].aliases = l:aliases
                            
                                    for l:alias in l:aliases
                                        let s:aliases[l:alias] = a:name
                                    endfor
                                endif
                            endfunction
                            
                            " Get a function from the registry by its short name.
    1              0.000005 function! ale#fix#registry#GetFunc(name) abort
                                " Use the exact name, or an alias.
                                let l:resolved_name = !has_key(s:entries, a:name)
                                \   ? get(s:aliases, a:name, a:name)
                                \   : a:name
                            
                                return get(s:entries, l:resolved_name, {'function': ''}).function
                            endfunction
                            
    1              0.000007 function! s:ShouldSuggestForType(suggested_filetypes, type_list) abort
                                for l:type in a:type_list
                                    if index(a:suggested_filetypes, l:type) >= 0
                                        return 1
                                    endif
                                endfor
                            
                                return 0
                            endfunction
                            
    1              0.000005 function! s:IsGenericFixer(suggested_filetypes) abort
                                if empty(a:suggested_filetypes)
                                    return 1
                                endif
                            
                                return 0
                            endfunction
                            
    1              0.000005 function! s:FormatEntry(key, entry) abort
                                let l:aliases_str = ''
                            
                                " Show aliases in :ALEFixSuggest if they are there.
                                if !empty(get(a:entry, 'aliases', []))
                                    let l:aliases_str = ', ' . join(
                                    \   map(copy(a:entry.aliases), 'string(v:val)'),
                                    \   ','
                                    \)
                                endif
                            
                                return printf(
                                \   '%s%s - %s',
                                \   string(a:key),
                                \   l:aliases_str,
                                \   a:entry.description,
                                \)
                            endfunction
                            
                            " Get list of applicable fixers for filetype, including generic fixers
    1              0.000005 function! ale#fix#registry#GetApplicableFixers(filetype) abort
                                let l:type_list = split(a:filetype, '\.')
                                let l:fixer_name_list = []
                            
                                for l:key in sort(keys(s:entries))
                                    let l:suggested_filetypes = s:entries[l:key].suggested_filetypes
                            
                                    if s:IsGenericFixer(l:suggested_filetypes) || s:ShouldSuggestForType(l:suggested_filetypes, l:type_list)
                                        call add(l:fixer_name_list, l:key)
                                    endif
                                endfor
                            
                                return l:fixer_name_list
                            endfunction
                            
                            " Function that returns autocomplete candidates for ALEFix command
    1              0.000005 function! ale#fix#registry#CompleteFixers(ArgLead, CmdLine, CursorPos) abort
                                return filter(ale#fix#registry#GetApplicableFixers(&filetype), 'v:val =~? a:ArgLead')
                            endfunction
                            
    1              0.000005 function! ale#fix#registry#SuggestedFixers(filetype) abort
                                let l:type_list = split(a:filetype, '\.')
                                let l:filetype_fixer_list = []
                            
                                for l:key in sort(keys(s:entries))
                                    let l:suggested_filetypes = s:entries[l:key].suggested_filetypes
                            
                                    if s:ShouldSuggestForType(l:suggested_filetypes, l:type_list)
                                        call add(
                                        \   l:filetype_fixer_list,
                                        \   s:FormatEntry(l:key, s:entries[l:key]),
                                        \)
                                    endif
                                endfor
                            
                                let l:generic_fixer_list = []
                            
                                for l:key in sort(keys(s:entries))
                                    if s:IsGenericFixer(s:entries[l:key].suggested_filetypes)
                                        call add(
                                        \   l:generic_fixer_list,
                                        \   s:FormatEntry(l:key, s:entries[l:key]),
                                        \)
                                    endif
                                endfor
                            
                                return [l:filetype_fixer_list, l:generic_fixer_list]
                            endfunction
                            
                            " Suggest functions to use from the registry.
    1              0.000005 function! ale#fix#registry#Suggest(filetype) abort
                                let l:suggested = ale#fix#registry#SuggestedFixers(a:filetype)
                                let l:filetype_fixer_list = l:suggested[0]
                                let l:generic_fixer_list = l:suggested[1]
                            
                                let l:filetype_fixer_header = !empty(l:filetype_fixer_list)
                                \   ? ['Try the following fixers appropriate for the filetype:', '']
                                \   : []
                                let l:generic_fixer_header = !empty(l:generic_fixer_list)
                                \   ? ['Try the following generic fixers:', '']
                                \   : []
                            
                                let l:has_both_lists = !empty(l:filetype_fixer_list) && !empty(l:generic_fixer_list)
                            
                                let l:lines =
                                \   l:filetype_fixer_header
                                \   + l:filetype_fixer_list
                                \   + (l:has_both_lists ? [''] : [])
                                \   + l:generic_fixer_header
                                \   + l:generic_fixer_list
                            
                                if empty(l:lines)
                                    let l:lines = ['There is nothing in the registry to suggest.']
                                else
                                    let l:lines += ['', 'See :help ale-fix-configuration']
                                endif
                            
                                let l:lines += ['', 'Press q to close this window']
                            
                                new +set\ filetype=ale-fix-suggest
                                call setline(1, l:lines)
                                setlocal nomodified
                                setlocal nomodifiable
                            endfunction

SCRIPT  /Volumes/User/.vim/bundle/ale/autoload/ale/fixers/tslint.vim
Sourced 1 time
Total time:   0.010808
 Self time:   0.010808

count  total (s)   self (s)
                            " Author: carakan <carakan@gmail.com>
                            " Description: Fixing files with tslint.
                            
    1              0.000009 function! ale#fixers#tslint#Fix(buffer) abort
                                let l:executable = ale#handlers#tslint#GetExecutable(a:buffer)
                            
                                let l:tslint_config_path = ale#path#ResolveLocalPath(
                                \   a:buffer,
                                \   'tslint.json',
                                \   ale#Var(a:buffer, 'typescript_tslint_config_path')
                                \)
                                let l:tslint_config_option = !empty(l:tslint_config_path)
                                \   ? ' -c ' . ale#Escape(l:tslint_config_path)
                                \   : ''
                            
                                return {
                                \   'command': ale#node#Executable(a:buffer, l:executable)
                                \       . l:tslint_config_option
                                \       . ' --fix %t',
                                \   'read_temporary_file': 1,
                                \}
                            endfunction

SCRIPT  /Volumes/User/.vim/bundle/ale/autoload/ale/fixers/eslint.vim
Sourced 1 time
Total time:   0.000852
 Self time:   0.000852

count  total (s)   self (s)
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: Fixing files with eslint.
                            
    1              0.000010 function! ale#fixers#eslint#Fix(buffer) abort
                                let l:executable = ale#handlers#eslint#GetExecutable(a:buffer)
                                let l:command = ale#node#Executable(a:buffer, l:executable)
                                \   . ' --version'
                            
                                return ale#semver#RunWithVersionCheck(
                                \   a:buffer,
                                \   l:executable,
                                \   l:command,
                                \   function('ale#fixers#eslint#ApplyFixForVersion'),
                                \)
                            endfunction
                            
    1              0.000005 function! ale#fixers#eslint#ProcessFixDryRunOutput(buffer, output) abort
                                for l:item in ale#util#FuzzyJSONDecode(a:output, [])
                                    return split(get(l:item, 'output', ''), "\n")
                                endfor
                            
                                return []
                            endfunction
                            
    1              0.000004 function! ale#fixers#eslint#ProcessEslintDOutput(buffer, output) abort
                                " If the output is an error message, don't use it.
                                for l:line in a:output[:10]
                                    if l:line =~# '\v^Error:|^Could not connect'
                                        return []
                                    endif
                                endfor
                            
                                return a:output
                            endfunction
                            
    1              0.000004 function! ale#fixers#eslint#ApplyFixForVersion(buffer, version) abort
                                let l:executable = ale#handlers#eslint#GetExecutable(a:buffer)
                                let l:options = ale#Var(a:buffer, 'javascript_eslint_options')
                            
                                " Use the configuration file from the options, if configured.
                                if l:options =~# '\v(^| )-c|(^| )--config'
                                    let l:config = ''
                                    let l:has_config = 1
                                else
                                    let l:config = ale#handlers#eslint#FindConfig(a:buffer)
                                    let l:has_config = !empty(l:config)
                                endif
                            
                                if !l:has_config
                                    return 0
                                endif
                            
                                " Use --fix-to-stdout with eslint_d
                                if l:executable =~# 'eslint_d$' && ale#semver#GTE(a:version, [3, 19, 0])
                                    return {
                                    \   'command': ale#node#Executable(a:buffer, l:executable)
                                    \       . ale#Pad(l:options)
                                    \       . ' --stdin-filename %s --stdin --fix-to-stdout',
                                    \   'process_with': 'ale#fixers#eslint#ProcessEslintDOutput',
                                    \}
                                endif
                            
                                " 4.9.0 is the first version with --fix-dry-run
                                if ale#semver#GTE(a:version, [4, 9, 0])
                                    return {
                                    \   'command': ale#node#Executable(a:buffer, l:executable)
                                    \       . ale#Pad(l:options)
                                    \       . ' --stdin-filename %s --stdin --fix-dry-run --format=json',
                                    \   'process_with': 'ale#fixers#eslint#ProcessFixDryRunOutput',
                                    \}
                                endif
                            
                                return {
                                \   'command': ale#node#Executable(a:buffer, l:executable)
                                \       . ale#Pad(l:options)
                                \       . (!empty(l:config) ? ' -c ' . ale#Escape(l:config) : '')
                                \       . ' --fix %t',
                                \   'read_temporary_file': 1,
                                \}
                            endfunction

SCRIPT  /Volumes/User/.vim/bundle/ale/autoload/ale/semver.vim
Sourced 1 time
Total time:   0.000497
 Self time:   0.000497

count  total (s)   self (s)
    1              0.000013 let s:version_cache = {}
                            
                            " Reset the version cache used for parsing the version.
    1              0.000027 function! ale#semver#ResetVersionCache() abort
                                let s:version_cache = {}
                            endfunction
                            
    1              0.000005 function! ale#semver#ParseVersion(version_lines) abort
                                for l:line in a:version_lines
                                    let l:match = matchlist(l:line, '\v(\d+)\.(\d+)(\.(\d+))?')
                            
                                    if !empty(l:match)
                                        return [l:match[1] + 0, l:match[2] + 0, l:match[4] + 0]
                                    endif
                                endfor
                            
                                return []
                            endfunction
                            
                            " Given an executable name and some lines of output, which can be empty,
                            " parse the version from the lines of output, or return the cached version
                            " triple [major, minor, patch]
                            "
                            " If the version cannot be found, an empty List will be returned instead.
    1              0.000007 function! s:GetVersion(executable, version_lines) abort
                                let l:version = get(s:version_cache, a:executable, [])
                                let l:parsed_version = ale#semver#ParseVersion(a:version_lines)
                            
                                if !empty(l:parsed_version)
                                    let l:version = l:parsed_version
                                    let s:version_cache[a:executable] = l:version
                                endif
                            
                                return l:version
                            endfunction
                            
    1              0.000007 function! ale#semver#RunWithVersionCheck(buffer, executable, command, Callback) abort
                                if empty(a:executable)
                                    return ''
                                endif
                            
                                let l:cache = s:version_cache
                            
                                if has_key(s:version_cache, a:executable)
                                    return a:Callback(a:buffer, s:version_cache[a:executable])
                                endif
                            
                                return ale#command#Run(
                                \   a:buffer,
                                \   a:command,
                                \   {_, output -> a:Callback(a:buffer, s:GetVersion(a:executable, output))},
                                \   {'output_stream': 'both', 'executable': a:executable}
                                \)
                            endfunction
                            
                            " Given two triples of integers [major, minor, patch], compare the triples
                            " and return 1 if the LHS is greater than or equal to the RHS.
                            "
                            " Pairs of [major, minor] can also be used for either argument.
                            "
                            " 0 will be returned if the LHS is an empty List.
    1              0.000005 function! ale#semver#GTE(lhs, rhs) abort
                                if empty(a:lhs)
                                    return 0
                                endif
                            
                                if a:lhs[0] > a:rhs[0]
                                    return 1
                                elseif a:lhs[0] == a:rhs[0]
                                    if a:lhs[1] > a:rhs[1]
                                        return 1
                                    elseif a:lhs[1] == a:rhs[1]
                                        return get(a:lhs, 2) >= get(a:rhs, 2)
                                    endif
                                endif
                            
                                return 0
                            endfunction

FUNCTION  ale#util#GetLineCount()
Called 7 times
Total time:   0.000813
 Self time:   0.000813

count  total (s)   self (s)
    7              0.000804     return len(getbufline(a:buffer, 1, '$'))

FUNCTION  airline#extensions#quickfix#inactive_qf_window()
Called 4 times
Total time:   0.000085
 Self time:   0.000085

count  total (s)   self (s)
    4              0.000057   if getbufvar(a:2.bufnr, '&filetype') is# 'qf' && !empty(airline#util#getwinvar(a:2.winnr, 'quickfix_title', ''))
                                call setwinvar(a:2.winnr, 'airline_section_c', '[%{get(w:, "quickfix_title", "")}] %f %m')
                              endif

FUNCTION  airline#extensions#tabline#group_of_bufnr()
Called 3 times
Total time:   0.000133
 Self time:   0.000133

count  total (s)   self (s)
    3              0.000017   let cur = bufnr('%')
    3              0.000008   if cur == a:bufnr
    3              0.000023     if g:airline_detect_modified && getbufvar(a:bufnr, '&modified')
                                  let group = 'airline_tabmod'
                                else
    3              0.000008       let group = 'airline_tabsel'
    3              0.000003     endif
    3              0.000003   else
                                if g:airline_detect_modified && getbufvar(a:bufnr, '&modified')
                                  let group = 'airline_tabmod_unsel'
                                elseif index(a:tab_bufs, a:bufnr) > -1
                                  let group = 'airline_tab'
                                else
                                  let group = 'airline_tabhid'
                                endif
                              endif
    3              0.000006   return group

FUNCTION  3()
Called 1 time
Total time:   0.000108
 Self time:   0.000087

count  total (s)   self (s)
    1              0.000007     let l:prependWorkingDir = 0
                            
    1   0.000035   0.000014     if nerdtree#runningWindows()
                                    let l:prependWorkingDir = a:pathStr !~# '^.:\(\\\|\/\)\?' && a:pathStr !~# '^\(\\\\\|\/\/\)'
                                else
    1              0.000015         let l:prependWorkingDir = a:pathStr !~# '^/'
    1              0.000002     endif
                            
    1              0.000005     let l:result = a:pathStr
                            
    1              0.000003     if l:prependWorkingDir
                                    let l:result = getcwd()
                            
                                    if l:result[-1:] == s:Path.Slash()
                                        let l:result = l:result . a:pathStr
                                    else
                                        let l:result = l:result . s:Path.Slash() . a:pathStr
                                    endif
                                endif
                            
    1              0.000003     return l:result

FUNCTION  5()
Called 3 times
Total time:   0.000492
 Self time:   0.000348

count  total (s)   self (s)
    3   0.000160   0.000067     let self.cachedDisplayString = g:NERDTreeNodeDelimiter . self.getLastPathComponent(1)
                            
    3              0.000009     if self.isExecutable
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . '*'
                                endif
                            
    3              0.000037     let self._bookmarkNames = []
    3   0.000101   0.000051     for i in g:NERDTreeBookmark.Bookmarks()
                                    if i.path.equals(self)
                                        call add(self._bookmarkNames, i.name)
                                    endif
                                endfor
    3              0.000018     if !empty(self._bookmarkNames) && g:NERDTreeMarkBookmarks == 1
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' {' . join(self._bookmarkNames) . '}'
                                endif
                            
    3              0.000007     if self.isSymLink
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' -> ' . self.symLinkDest
                                endif
                            
    3              0.000007     if self.isReadOnly
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' ['.g:NERDTreeGlyphReadOnly.']'
                                endif

FUNCTION  ale#engine#HandleLoclist()
Called 7 times
Total time:   0.057991
 Self time:   0.001264

count  total (s)   self (s)
    7              0.000076     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
    7              0.000030     if empty(l:info)
                                    return
                                endif
                            
    7              0.000019     if !a:from_other_source
                                    " Remove this linter from the list of active linters.
                                    " This may have already been done when the job exits.
    7              0.000076         call filter(l:info.active_linter_list, 'v:val.name isnot# a:linter_name')
    7              0.000011     endif
                            
                                " Make some adjustments to the loclists to fix common problems, and also
                                " to set default values for loclist items.
    7   0.006178   0.000177     let l:linter_loclist = ale#engine#FixLocList(   a:buffer,   a:linter_name,   a:from_other_source,   a:loclist,)
                            
                                " Remove previous items for this linter.
    7              0.000138     call filter(l:info.loclist, 'v:val.linter_name isnot# a:linter_name')
                            
                                " We don't need to add items or sort the list when this list is empty.
    7              0.000033     if !empty(l:linter_loclist)
                                    " Add the new items.
    7              0.000044         call extend(l:info.loclist, l:linter_loclist)
                            
                                    " Sort the loclist again.
                                    " We need a sorted list so we can run a binary search against it
                                    " for efficient lookup of the messages in the cursor handler.
    7   0.001471   0.000240         call sort(l:info.loclist, 'ale#util#LocItemCompare')
    7              0.000009     endif
                            
    7   0.001893   0.000093     if ale#ShouldDoNothing(a:buffer)
                                    return
                                endif
                            
    7   0.047838   0.000144     call ale#engine#SetResults(a:buffer, l:info.loclist)

FUNCTION  ale#job#IsRunning()
Called 2 times
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
    2              0.000012     if has('nvim')
    2              0.000004         try
                                        " In NeoVim, if the job isn't running, jobpid() will throw.
    2              0.000011             call jobpid(a:job_id)
                            
    2              0.000004             return 1
                                    catch
                                    endtry
                                elseif has_key(s:job_map, a:job_id)
                                    let l:job = s:job_map[a:job_id].job
                            
                                    return job_status(l:job) is# 'run'
                                endif
                            
                                return 0

FUNCTION  ale#lsp#OnInit()
Called 2 times
Total time:   0.004160
 Self time:   0.000182

count  total (s)   self (s)
    2              0.000023     let l:conn = get(s:connections, a:conn_id, {})
                            
    2              0.000031     if empty(l:conn)
                                    return
                                endif
                            
    2              0.000009     if l:conn.initialized
    2   0.004047   0.000069         call a:Callback()
    2              0.000003     else
                                    call add(l:conn.init_queue, a:Callback)
                                endif

FUNCTION  airline#util#exec_funcrefs()
Called 10 times
Total time:   0.039249
 Self time:   0.001450

count  total (s)   self (s)
   54              0.000176     for Fn in a:list
   52   0.038675   0.000875       let code = call(Fn, a:000)
   52              0.000134       if code != 0
    8              0.000015         return code
                                  endif
   44              0.000053     endfor
    2              0.000004     return 0

FUNCTION  <SNR>171_UpdateCacheIfNecessary()
Called 1866 times
Total time:   0.031735
 Self time:   0.031735

count  total (s)   self (s)
                                " Cache is cold, so manually ask for an update.
 1866              0.013996     if !has_key(g:ale_buffer_info[a:buffer], 'count')
                                    call ale#statusline#Update(   a:buffer,   g:ale_buffer_info[a:buffer].loclist)
                                endif

FUNCTION  <SNR>162_set_clean_variables()
Called 1 time
Total time:   0.000181
 Self time:   0.000181

count  total (s)   self (s)
    1              0.000072   let var=getbufvar(fnameescape(a:file), 'buffer_vcs_config', {})
    1              0.000043   if has_key(var, a:vcs) && has_key(var[a:vcs], 'dirty') && type(getbufvar(fnameescape(a:file), 'buffer_vcs_config')) == type({})
    1              0.000007     let var[a:vcs].dirty=a:val
    1              0.000003     try
    1              0.000027       call setbufvar(fnameescape(a:file), 'buffer_vcs_config', var)
    1              0.000019       unlet! b:airline_head
    1              0.000002     catch
                                endtry
    1              0.000001   endif

FUNCTION  <SNR>148_HandleExit()
Called 1 time
Total time:   0.010770
 Self time:   0.000201

count  total (s)   self (s)
    1              0.000010     let l:buffer_info = get(g:ale_buffer_info, a:buffer)
                            
    1              0.000004     if empty(l:buffer_info)
                                    return
                                endif
                            
    1              0.000008     let l:linter = a:job_info.linter
    1              0.000004     let l:executable = a:job_info.executable
    1              0.000004     let l:next_chain_index = a:job_info.next_chain_index
                            
                                " Remove this job from the list.
    1   0.000041   0.000019     call ale#engine#MarkLinterInactive(l:buffer_info, l:linter.name)
                            
                                " Stop here if we land in the handle for a job completing if we're in
                                " a sandbox.
    1   0.000057   0.000014     if ale#util#InSandbox()
                                    return
                                endif
                            
    1              0.000014     if has('nvim') && !empty(a:output) && empty(a:output[-1])
                                    call remove(a:output, -1)
                                endif
                            
    1              0.000009     if l:next_chain_index < len(get(l:linter, 'command_chain', []))
                                    let [l:command, l:options] = ale#engine#ProcessChain(   a:buffer,   l:executable,   l:linter,   l:next_chain_index,   a:output,)
                            
                                    call s:RunJob(l:command, l:options)
                            
                                    return
                                endif
                            
    1              0.000002     try
    1   0.001772   0.000043         let l:loclist = ale#util#GetFunction(l:linter.callback)(a:buffer, a:output)
                                " Handle the function being unknown, or being deleted.
    1              0.000002     catch /E700/
                                    let l:loclist = []
                                endtry
                            
    1   0.008794   0.000020     call ale#engine#HandleLoclist(l:linter.name, a:buffer, l:loclist, 0)

FUNCTION  <SNR>42_is_file_buffer()
Called 2 times
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
    2              0.000022   return empty(getbufvar(a:bufnr, '&buftype'))

FUNCTION  ale#lsp#RegisterCallback()
Called 2 times
Total time:   0.000064
 Self time:   0.000064

count  total (s)   self (s)
    2              0.000017     let l:conn = get(s:connections, a:conn_id, {})
                            
    2              0.000007     if !empty(l:conn)
                                    " Add the callback to the List if it's not there already.
    2              0.000030         call uniq(sort(add(l:conn.callback_list, a:callback)))
    2              0.000003     endif

FUNCTION  <SNR>170_highlight_range()
Called 20 times
Total time:   0.000952
 Self time:   0.000663

count  total (s)   self (s)
                                " Set all of the positions, which are chunked into Lists which
                                " are as large as will be accepted by matchaddpos.
   20   0.000883   0.000593     call map(   ale#highlight#CreatePositions(       a:range.lnum,       a:range.col,       a:range.end_lnum,       a:range.end_col   ),   'matchaddpos(a:group, v:val)')

FUNCTION  ale#semver#GTE()
Called 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000003     if empty(a:lhs)
                                    return 0
                                endif
                            
    1              0.000002     if a:lhs[0] > a:rhs[0]
    1              0.000001         return 1
                                elseif a:lhs[0] == a:rhs[0]
                                    if a:lhs[1] > a:rhs[1]
                                        return 1
                                    elseif a:lhs[1] == a:rhs[1]
                                        return get(a:lhs, 2) >= get(a:rhs, 2)
                                    endif
                                endif
                            
                                return 0

FUNCTION  <SNR>42_winshell()
Called 2 times
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
    2              0.000031   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash

FUNCTION  <SNR>42_not_git_dir()
Called 2 times
Total time:   0.000568
 Self time:   0.000075

count  total (s)   self (s)
    2   0.000566   0.000072   return s:dir(a:bufnr) !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  ale#lsp_linter#StartLSP()
Called 2 times
Total time:   0.009134
 Self time:   0.000278

count  total (s)   self (s)
    2              0.000011     let l:command = ''
    2              0.000007     let l:address = ''
    2   0.001323   0.000058     let l:root = ale#lsp_linter#FindProjectRoot(a:buffer, a:linter)
                            
    2              0.000015     if empty(l:root) && a:linter.lsp isnot# 'tsserver'
                                    " If there's no project root, then we can't check files with LSP,
                                    " unless we are using tsserver, which doesn't use project roots.
                                    return 0
                                endif
                            
    2              0.000030     let l:options = {   'buffer': a:buffer,   'linter': a:linter,   'callback': a:Callback,   'root': l:root,}
                            
    2              0.000010     if a:linter.lsp is# 'socket'
                                    let l:address = ale#linter#GetAddress(a:buffer, a:linter)
                            
                                    return s:StartWithAddress(l:options, l:address)
                                endif
                            
    2   0.001255   0.000031     let l:executable = ale#linter#GetExecutable(a:buffer, a:linter)
                            
    2   0.006407   0.000040     return s:StartIfExecutable(l:options, l:executable)

FUNCTION  <SNR>93_reset_untracked_cache()
Called 1 time
Total time:   0.000351
 Self time:   0.000288

count  total (s)   self (s)
                              " shellcmdpost - whether function was called as a result of ShellCmdPost hook
    1              0.000007   if !g:airline#init#vim_async && !has('nvim')
                                if a:shellcmdpost
                                  " Clear cache only if there was no error or the script uses an
                                  " asynchronous interface. Otherwise, cache clearing would overwrite
                                  " v:shell_error with a system() call inside get_*_untracked.
                                  if v:shell_error
                                    return
                                  endif
                                endif
                              endif
                            
    1              0.000122   let file = expand("%:p")
    3              0.000023   for vcs in keys(s:vcs_config)
                                " Dump the value of the cache for the current file. Partially mitigates the
                                " issue of cache invalidation happening before a call to
                                " s:update_untracked()
    2   0.000104   0.000041     call airline#extensions#branch#update_untracked_config(file, vcs)
    2              0.000026     let s:vcs_config[vcs].untracked = {}
    2              0.000004   endfor

FUNCTION  ale#handlers#eslint#GetCommand()
Called 2 times
Total time:   0.002164
 Self time:   0.000108

count  total (s)   self (s)
    2   0.001945   0.000035     let l:executable = ale#handlers#eslint#GetExecutable(a:buffer)
                            
    2   0.000075   0.000029     let l:options = ale#Var(a:buffer, 'javascript_eslint_options')
                            
    2   0.000136   0.000038     return ale#node#Executable(a:buffer, l:executable)   . (!empty(l:options) ? ' ' . l:options : '')   . ' -f json --stdin --stdin-filename %s'

FUNCTION  <SNR>160_StopCursorTimer()
Called 4 times
Total time:   0.000069
 Self time:   0.000069

count  total (s)   self (s)
    4              0.000017     if s:cursor_timer != -1
    3              0.000016         call timer_stop(s:cursor_timer)
    3              0.000014         let s:cursor_timer = -1
    3              0.000004     endif

FUNCTION  <SNR>39_NERDTreeGetFileGitStatusKey()
Called 4 times
Total time:   0.000096
 Self time:   0.000096

count  total (s)   self (s)
    4              0.000023     if a:us ==# '?' && a:them ==# '?'
    1              0.000002         return 'Untracked'
                                elseif a:us ==# ' ' && a:them ==# 'M'
    2              0.000005         return 'Modified'
                                elseif a:us =~# '[MAC]'
                                    return 'Staged'
                                elseif a:us ==# 'R'
                                    return 'Renamed'
                                elseif a:us ==# 'U' || a:them ==# 'U' || a:us ==# 'A' && a:them ==# 'A' || a:us ==# 'D' && a:them ==# 'D'
                                    return 'Unmerged'
                                elseif a:them ==# 'D'
    1              0.000002         return 'Deleted'
                                elseif a:us ==# '!'
                                    return 'Ignored'
                                else
                                    return 'Unknown'
                                endif

FUNCTION  ale#linter#Get()
Called 2 times
Total time:   0.001529
 Self time:   0.000794

count  total (s)   self (s)
    2              0.000013     let l:possibly_duplicated_linters = []
                            
                                " Handle dot-separated filetypes.
    4              0.000044     for l:original_filetype in split(a:original_filetypes, '\.')
    2   0.000355   0.000055         let l:filetype = ale#linter#ResolveFiletype(l:original_filetype)
    2   0.000211   0.000048         let l:linter_names = s:GetLinterNames(l:original_filetype)
    2   0.000319   0.000047         let l:all_linters = ale#linter#GetAll(l:filetype)
    2              0.000009         let l:filetype_linters = []
                            
    2              0.000018         if type(l:linter_names) is v:t_string && l:linter_names is# 'all'
    2              0.000010             let l:filetype_linters = l:all_linters
    2              0.000010         elseif type(l:linter_names) is v:t_list
                                        " Select only the linters we or the user has specified.
                                        for l:linter in l:all_linters
                                            let l:name_list = [l:linter.name] + l:linter.aliases
                            
                                            for l:name in l:name_list
                                                if index(l:linter_names, l:name) >= 0
                                                    call add(l:filetype_linters, l:linter)
                                                    break
                                                endif
                                            endfor
                                        endfor
                                    endif
                            
    2              0.000017         call extend(l:possibly_duplicated_linters, l:filetype_linters)
    2              0.000004     endfor
                            
    2              0.000009     let l:name_list = []
    2              0.000007     let l:combined_linters = []
                            
                                " Make sure we override linters so we don't get two with the same name,
                                " like 'eslint' for both 'javascript' and 'typescript'
                                "
                                " Note that the reverse calls here modify the List variables.
   12              0.000036     for l:linter in reverse(l:possibly_duplicated_linters)
   10              0.000058         if index(l:name_list, l:linter.name) < 0
   10              0.000052             call add(l:name_list, l:linter.name)
   10              0.000044             call add(l:combined_linters, l:linter)
   10              0.000013         endif
   10              0.000011     endfor
                            
    2              0.000011     return reverse(l:combined_linters)

FUNCTION  ale#fixers#eslint#ApplyFixForVersion()
Called 1 time
Total time:   0.002615
 Self time:   0.000176

count  total (s)   self (s)
    1   0.001282   0.000018     let l:executable = ale#handlers#eslint#GetExecutable(a:buffer)
    1   0.000043   0.000014     let l:options = ale#Var(a:buffer, 'javascript_eslint_options')
                            
                                " Use the configuration file from the options, if configured.
    1              0.000019     if l:options =~# '\v(^| )-c|(^| )--config'
                                    let l:config = ''
                                    let l:has_config = 1
                                else
    1   0.001106   0.000028         let l:config = ale#handlers#eslint#FindConfig(a:buffer)
    1              0.000004         let l:has_config = !empty(l:config)
    1              0.000001     endif
                            
    1              0.000001     if !l:has_config
                                    return 0
                                endif
                            
                                " Use --fix-to-stdout with eslint_d
    1              0.000015     if l:executable =~# 'eslint_d$' && ale#semver#GTE(a:version, [3, 19, 0])
                                    return {   'command': ale#node#Executable(a:buffer, l:executable)       . ale#Pad(l:options)       . ' --stdin-filename %s --stdin --fix-to-stdout',   'process_with': 'ale#fixers#eslint#ProcessEslintDOutput',}
                                endif
                            
                                " 4.9.0 is the first version with --fix-dry-run
    1   0.000026   0.000016     if ale#semver#GTE(a:version, [4, 9, 0])
    1   0.000093   0.000036         return {   'command': ale#node#Executable(a:buffer, l:executable)       . ale#Pad(l:options)       . ' --stdin-filename %s --stdin --fix-dry-run --format=json',   'process_with': 'ale#fixers#eslint#ProcessFixDryRunOutput',}
                                endif
                            
                                return {   'command': ale#node#Executable(a:buffer, l:executable)       . ale#Pad(l:options)       . (!empty(l:config) ? ' -c ' . ale#Escape(l:config) : '')       . ' --fix %t',   'read_temporary_file': 1,}

FUNCTION  <SNR>148_RemoveProblemsForDisabledLinters()
Called 2 times
Total time:   0.000174
 Self time:   0.000174

count  total (s)   self (s)
                                " Figure out which linters are still enabled, and remove
                                " problems for linters which are no longer enabled.
                                " Problems from other sources will be kept.
    2              0.000008     let l:name_map = {}
                            
   12              0.000025     for l:linter in a:linters
   10              0.000046         let l:name_map[l:linter.name] = 1
   10              0.000013     endfor
                            
    2              0.000061     call filter(   get(g:ale_buffer_info[a:buffer], 'loclist', []),   'get(v:val, ''from_other_source'') || get(l:name_map, get(v:val, ''linter_name''))',)

FUNCTION  <SNR>74_Highlight_Matching_Pair()
Called 846 times
Total time:   0.171256
 Self time:   0.171256

count  total (s)   self (s)
                              " Remove any previous match.
  846              0.007405   if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
                              endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
  846              0.007167   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
  846              0.005470   let c_lnum = line('.')
  846              0.004387   let c_col = col('.')
  846              0.002447   let before = 0
                            
  846              0.005089   let text = getline(c_lnum)
  846              0.039705   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
  846              0.004633   if empty(matches)
                                let [c_before, c] = ['', '']
                              else
  846              0.007730     let [c_before, c] = matches[1:2]
  846              0.001334   endif
  846              0.025296   let plist = split(&matchpairs, '.\zs[:,]')
  846              0.006784   let i = index(plist, c)
  846              0.002406   if i < 0
                                " not found, in Insert mode try character before the cursor
  846              0.006763     if c_col > 1 && (mode() == 'i' || mode() == 'R')
  842              0.005074       let before = strlen(c_before)
  842              0.003344       let c = c_before
  842              0.004494       let i = index(plist, c)
  842              0.001261     endif
  846              0.001803     if i < 0
                                  " not found, nothing to do
  846              0.001479       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
                              else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial.
                                let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                try
                                  execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
                              endif
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  <SNR>130_SynSOL()
Called 1 time
Total time:   0.000250
 Self time:   0.000017

count  total (s)   self (s)
    1   0.000250   0.000017   return s:GetSyntaxNames(a:lnum, 1)

FUNCTION  <SNR>110_setup_path()
Called 2 times
Total time:   0.000191
 Self time:   0.000068

count  total (s)   self (s)
    2   0.000165   0.000043   let p = gitgutter#utility#repo_path(a:bufnr, 0)
                            
    2              0.000016   if type(p) == s:t_string && !empty(p)  " if path is known
    2              0.000003     return
                              endif
                            
                              return gitgutter#utility#set_repo_path(a:bufnr, a:continuation)

FUNCTION  <SNR>130_GetSyntaxNames()
Called 2 times
Total time:   0.000260
 Self time:   0.000260

count  total (s)   self (s)
    2              0.000258   return map(synstack(a:lnum, a:cnum), 'synIDattr(v:val, "name")')

FUNCTION  <SNR>129_PrevCodeLine()
Called 1 time
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
    1              0.000004   let l:n = prevnonblank(a:lnum)
    1              0.000002   while l:n
    1              0.000008 	if getline(l:n) =~ '^\s*\/[/*]' 
                            	  if (stridx(getline(l:n),'`') > 0 || getline(l:n-1)[-1:] == '\') && s:syn_at(l:n,1) =~? s:syng_str
                            		return l:n
                            	  endif
                            	  let l:n = prevnonblank(l:n-1)
                            	elseif getline(l:n) =~ '\([/*]\)\1\@![/*]' && s:syn_at(l:n,1) =~? s:syng_com
                            	  let l:n = s:save_pos('eval', 'cursor('.l:n.',1) + search(''\m\/\*'',"bW")')
                            	else
    1              0.000001 	  return l:n
                            	endif
                              endwhile

FUNCTION  <SNR>119_InvokeCompletion()
Called 421 times
Total time:   6.693328
 Self time:   6.141964

count  total (s)   self (s)
  421              6.127970   exec s:python_command "ycm_state.SendCompletionRequest(" . "vimsupport.GetBoolValue( 's:force_semantic' ) )"
                            
  421   0.563520   0.012156   call s:PollCompletion()

FUNCTION  GetJsxIndent()
Called 1 time
Total time:   0.002264
 Self time:   0.000028

count  total (s)   self (s)
    1   0.002263   0.000027   return jsx_pretty#indent#get(function('GetTypescriptIndent'))

FUNCTION  airline#check_mode()
Called 653 times
Total time:   0.555718
 Self time:   0.158599

count  total (s)   self (s)
  653              0.004967   if !has_key(s:contexts, a:winnr)
                                return ''
                              endif
  653              0.004420   let context = s:contexts[a:winnr]
                            
  653              0.004311   if get(w:, 'airline_active', 1)
  639              0.004027     let l:m = mode(1)
  639              0.002407     if l:m ==# "i"
  593              0.002752       let l:mode = ['insert']
  593              0.001687     elseif l:m[0] ==# "i"
                                  let l:mode = ['insert']
                                elseif l:m ==# "Rv"
                                  let l:mode =['replace']
                                elseif l:m[0] ==# "R"
                                  let l:mode = ['replace']
                                elseif l:m[0] =~# '\v(v|V||s|S|)'
    4              0.000020       let l:mode = ['visual']
    4              0.000009     elseif l:m ==# "t"
                                  let l:mode = ['terminal']
                                elseif l:m[0] ==# "c"
    3              0.000015       let l:mode = ['commandline']
    3              0.000007     elseif l:m ==# "no"   " does not work, most likely, Vim does not refresh the statusline in OP mode
                                  let l:mode = ['normal']
                                elseif l:m[0:1] ==# 'ni'
                                  let l:mode = ['normal']
                                  let l:m = 'ni'
                                else
   39              0.000148       let l:mode = ['normal']
   39              0.000048     endif
  639              0.005859     if exists("*VMInfos") && !empty(VMInfos())
                                  " Vim plugin Multiple Cursors https://github.com/mg979/vim-visual-multi
                                  let l:m = 'multi'
                                endif
  639              0.007952     if index(['Rv', 'no', 'ni', 'ix', 'ic', 'multi'], l:m) == -1
  639              0.003267       let l:m = l:m[0]
  639              0.000915     endif
  639              0.005980     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
  639              0.001039   else
   14              0.000051     let l:mode = ['inactive']
   14              0.000093     let w:airline_current_mode = get(g:airline_mode_map, '__')
   14              0.000017   endif
                            
  653              0.003813   if g:airline_detect_modified && &modified
  617              0.003912     call add(l:mode, 'modified')
  617              0.000892   endif
                            
  653              0.002603   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
                              endif
                            
  653              0.007943   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
                              endif
                            
  653              0.002282   if g:airline_detect_spell && &spell
                                call add(l:mode, 'spell')
                              endif
                            
  653              0.001805   if &readonly || ! &modifiable
   14              0.000073     call add(l:mode, 'readonly')
   14              0.000015   endif
                            
  653              0.006231   let mode_string = join(l:mode)
  653              0.005811   if get(w:, 'airline_lastmode', '') != mode_string
   12   0.008755   0.000173     call airline#highlighter#highlight_modified_inactive(context.bufnr)
   12   0.386633   0.000415     call airline#highlighter#highlight(l:mode, context.bufnr)
   12   0.002473   0.000154     call airline#util#doautocmd('AirlineModeChanged')
   12              0.000066     let w:airline_lastmode = mode_string
   12              0.000014   endif
                            
  653              0.001386   return ''

FUNCTION  <SNR>116_evaluate_tabline()
Called 5 times
Total time:   0.000754
 Self time:   0.000536

count  total (s)   self (s)
    5              0.000019   let tabline = a:tabline
    5   0.000331   0.000113   let tabline = substitute(tabline, '%{\([^}]\+\)}', '\=eval(submatch(1))', 'g')
    5              0.000110   let tabline = substitute(tabline, '%#[^#]\+#', '', 'g')
    5              0.000073   let tabline = substitute(tabline, '%(\([^)]\+\)%)', '\1', 'g')
    5              0.000048   let tabline = substitute(tabline, '%\d\+[TX]', '', 'g')
    5              0.000039   let tabline = substitute(tabline, '%=', '', 'g')
    5              0.000039   let tabline = substitute(tabline, '%\d*\*', '', 'g')
    5              0.000024   if has('tablineat')
    5              0.000039     let tabline = substitute(tabline, '%@[^@]\+@', '', 'g')
    5              0.000006   endif
    5              0.000009   return tabline

FUNCTION  ale#handlers#eslint#HandleJSON()
Called 1 time
Total time:   0.001716
 Self time:   0.000029

count  total (s)   self (s)
    1   0.001715   0.000028     return s:HandleESLintOutput(a:buffer, a:lines, 'json')

FUNCTION  <SNR>108_get_section()
Called 60 times
Total time:   0.005268
 Self time:   0.004112

count  total (s)   self (s)
   60              0.000335   if has_key(s:section_truncate_width, a:key)
   36   0.001104   0.000433     if airline#util#winwidth(a:winnr) < s:section_truncate_width[a:key]
    4              0.000007       return ''
                                endif
   32              0.000026   endif
   56              0.000217   let spc = g:airline_symbols.space
   56              0.000442   if !exists('g:airline_section_{a:key}')
                                return ''
                              endif
   56   0.001387   0.000902   let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
   56              0.000755   let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
   56              0.000400   return empty(text) ? '' : prefix.text.suffix

FUNCTION  <SNR>104_GetHiCmd()
Called 84 times
Total time:   0.012282
 Self time:   0.012282

count  total (s)   self (s)
                              " a:list needs to have 5 items!
   84              0.000186   let res = ''
   84              0.000152   let i = -1
  504              0.000718   while i < 4
  420              0.000700     let i += 1
  420              0.001642     let item = get(a:list, i, '')
  420              0.000899     if item is ''
  161              0.000243       continue
                                endif
  259              0.000315     if i == 0
   72              0.000284       let res .= ' guifg='.item
   72              0.000097     elseif i == 1
   35              0.000105       let res .= ' guibg='.item
   35              0.000036     elseif i == 2
   84              0.000336       let res .= ' ctermfg='.item
   84              0.000115     elseif i == 3
   47              0.000173       let res .= ' ctermbg='.item
   47              0.000057     elseif i == 4
   21              0.000130       let res .= printf(' gui=%s cterm=%s term=%s', item, item, item)
   21              0.000018     endif
  259              0.000242   endwhile
   84              0.000147   return res

FUNCTION  <SNR>164_write_buffer()
Called 2 times
Total time:   0.002533
 Self time:   0.002533

count  total (s)   self (s)
    2              0.000118   let bufcontents = getbufline(a:bufnr, 1, '$')
                            
    2              0.000016   if bufcontents == [''] && line2byte(1) == -1
                                " Special case: completely empty buffer.
                                " A nearly empty buffer of only a newline has line2byte(1) == 1.
                                call writefile([], a:file)
                                return
                              endif
                            
    2              0.000027   if getbufvar(a:bufnr, '&fileformat') ==# 'dos'
                                call map(bufcontents, 'v:val."\r"')
                              endif
                            
    2              0.000015   let fenc = getbufvar(a:bufnr, '&fileencoding')
    2              0.000009   if fenc !=# &encoding
                                call map(bufcontents, 'iconv(v:val, &encoding, "'.fenc.'")')
                              endif
                            
    2              0.000011   if getbufvar(a:bufnr, '&bomb')
                                let bufcontents[0]='﻿'.bufcontents[0]
                              endif
                            
    2              0.000826   call writefile(bufcontents, a:file)

FUNCTION  airline#util#append()
Called 4473 times
Total time:   0.103802
 Self time:   0.103802

count  total (s)   self (s)
 4473              0.024598   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
                              endif
 4473              0.032479   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
 4473              0.027249   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  ale#events#QuitRecently()
Called 2 times
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
    2              0.000017     let l:time = getbufvar(a:buffer, 'ale_quitting', 0)
                            
    2              0.000014     return l:time && ale#events#ClockMilliseconds() - l:time < 1000

FUNCTION  <SNR>42_unc_path()
Called 2 times
Total time:   0.000604
 Self time:   0.000232

count  total (s)   self (s)
    2   0.000603   0.000230   return s:abs_path(a:bufnr, 0) =~ '^\\\\'

FUNCTION  <SNR>101_map_keys()
Called 14 times
Total time:   0.004620
 Self time:   0.004620

count  total (s)   self (s)
   14              0.000115   let bidx_mode = get(g:, 'airline#extensions#tabline#buffer_idx_mode', 1)
   14              0.000036   if bidx_mode > 0
   14              0.000025     if bidx_mode == 1
  140              0.000374       for i in range(1, 9)
  126              0.002949         exe printf('noremap <silent> <Plug>AirlineSelectTab%d :call <SID>select_tab(%d)<CR>', i, i-1)
  126              0.000213       endfor
   14              0.000017     else
                                  for i in range(11, 99)
                                    exe printf('noremap <silent> <Plug>AirlineSelectTab%d :call <SID>select_tab(%d)<CR>', i, i-11)
                                  endfor
                                endif
   14              0.000226     noremap <silent> <Plug>AirlineSelectPrevTab :<C-u>call <SID>jump_to_tab(-v:count1)<CR>
   14              0.000257     noremap <silent> <Plug>AirlineSelectNextTab :<C-u>call <SID>jump_to_tab(v:count1)<CR>
                                " Enable this for debugging
                                " com! AirlineBufferList :echo map(copy(s:current_visible_buffers), {i,k -> k.": ".bufname(k)})
   14              0.000020   endif

FUNCTION  <SNR>119_OnInsertLeave()
Called 1 time
Total time:   0.007381
 Self time:   0.005376

count  total (s)   self (s)
    1   0.000168   0.000017   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
    1              0.000008   call timer_stop( s:pollers.completion.id )
    1              0.000012   let s:force_semantic = 0
    1              0.000014   let s:completion = s:default_completion
                            
    1   0.001888   0.000033   call s:OnFileReadyToParse()
    1              0.005250   exec s:python_command "ycm_state.OnInsertLeave()"
    1              0.000013   if g:ycm_autoclose_preview_window_after_completion || g:ycm_autoclose_preview_window_after_insertion
                                call s:ClosePreviewWindowIfNeeded()
                              endif

FUNCTION  ale#lsp#UpdateConfig()
Called 2 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    2              0.000018     let l:conn = get(s:connections, a:conn_id, {})
                            
    2              0.000010     if empty(l:conn) || a:config ==# l:conn.config " no-custom-checks
    2              0.000011         return 0
                                endif
                            
                                let l:conn.config = a:config
                                let l:message = ale#lsp#message#DidChangeConfiguration(a:buffer, a:config)
                            
                                call ale#lsp#Send(a:conn_id, l:message)
                            
                                return 1

FUNCTION  airline#extensions#branch#update_untracked_config()
Called 637 times
Total time:   0.018686
 Self time:   0.018686

count  total (s)   self (s)
  637              0.005535   if !has_key(s:vcs_config[a:vcs].untracked, a:file)
    1              0.000002     return
                              elseif s:vcs_config[a:vcs].untracked[a:file] != b:buffer_vcs_config[a:vcs].untracked
                                let b:buffer_vcs_config[a:vcs].untracked = s:vcs_config[a:vcs].untracked[a:file]
                                unlet! b:airline_head
                              endif

FUNCTION  ale#fixers#eslint#Fix()
Called 1 time
Total time:   0.006054
 Self time:   0.000407

count  total (s)   self (s)
    1   0.001057   0.000020     let l:executable = ale#handlers#eslint#GetExecutable(a:buffer)
    1   0.000083   0.000017     let l:command = ale#node#Executable(a:buffer, l:executable)   . ' --version'
                            
    1   0.004907   0.000363     return ale#semver#RunWithVersionCheck(   a:buffer,   l:executable,   l:command,   function('ale#fixers#eslint#ApplyFixForVersion'),)

FUNCTION  airline#themes#get_highlight()
Called 670 times
Total time:   0.203679
 Self time:   0.011017

count  total (s)   self (s)
  670   0.203227   0.010565   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  <SNR>107_get_accented_line()
Called 51 times
Total time:   0.005944
 Self time:   0.005944

count  total (s)   self (s)
   51              0.000204   if a:self._context.active
                                " active window
   39              0.000156     let contents = []
   39              0.000808     let content_parts = split(a:contents, '__accent')
   90              0.000339     for cpart in content_parts
   51              0.000990       let accent = matchstr(cpart, '_\zs[^#]*\ze')
   51              0.000314       call add(contents, cpart)
   51              0.000095     endfor
   39              0.000471     let line = join(contents, a:group)
   39              0.000569     let line = substitute(line, '__restore__', a:group, 'g')
   39              0.000062   else
                                " inactive window
   12              0.000323     let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
   12              0.000162     let line = substitute(line, '%#__restore__#', '', 'g')
   12              0.000018   endif
   51              0.000114   return line

FUNCTION  ale#highlight#RemoveHighlights()
Called 7 times
Total time:   0.001055
 Self time:   0.001055

count  total (s)   self (s)
   26              0.000208     for l:match in getmatches()
   19              0.000508         if l:match.group =~? '\v^ALE(Style)?(Error|Warning|Info)(Line)?$'
   19              0.000154             call matchdelete(l:match.id)
   19              0.000033         endif
   19              0.000041     endfor

FUNCTION  FugitiveWorkTree()
Called 1278 times
Total time:   0.150961
 Self time:   0.028540

count  total (s)   self (s)
 1278   0.149766   0.027345   return s:Tree(FugitiveGitDir(a:0 ? a:1 : -1))

FUNCTION  <SNR>168_UpdateLineNumbers()
Called 7 times
Total time:   0.001194
 Self time:   0.001194

count  total (s)   self (s)
    7              0.000041     let l:line_map = {}
    7              0.000030     let l:line_numbers_changed = 0
                            
   19              0.000087     for [l:line, l:sign_id, l:name] in a:current_sign_list
   12              0.000084         let l:line_map[l:sign_id] = l:line
   12              0.000021     endfor
                            
   27              0.000075     for l:item in a:loclist
   20              0.000072         if l:item.bufnr == a:buffer
   20              0.000209             let l:lnum = get(l:line_map, get(l:item, 'sign_id', 0), 0)
                            
   20              0.000077             if l:lnum && l:item.lnum != l:lnum
                                            let l:item.lnum = l:lnum
                                            let l:line_numbers_changed = 1
                                        endif
   20              0.000023         endif
   20              0.000023     endfor
                            
                                " When the line numbers change, sort the list again
    7              0.000020     if l:line_numbers_changed
                                    call sort(a:loclist, 'ale#util#LocItemCompare')
                                endif

FUNCTION  <SNR>44_on_cursor_moved()
Called 4 times
Total time:   0.000227
 Self time:   0.000158

count  total (s)   self (s)
    4              0.000045   if winnr() != s:active_winnr
                                call s:on_window_changed('CursorMoved')
                              endif
    4   0.000135   0.000066   call airline#update_tabline()

FUNCTION  <SNR>118_AutoReloadStatus()
Called 2 times
Total time:   0.001040
 Self time:   0.000112

count  total (s)   self (s)
    2   0.000100   0.000057   if s:CanAutoReloadStatus()
    2   0.000931   0.000046     return call('fugitive#ReloadStatus', a:000)
                              endif

FUNCTION  airline#extensions#fugitiveline#bufname()
Called 639 times
Total time:   0.144791
 Self time:   0.138812

count  total (s)   self (s)
  639              0.004639   if !exists('b:fugitive_name')
    3              0.000010     let b:fugitive_name = ''
    3              0.000005     try
    3              0.000035       if bufname('%') =~? '^fugitive:' && exists('*FugitiveReal')
                                    let b:fugitive_name = FugitiveReal(bufname('%'))
                                  elseif exists('b:git_dir') && exists('*fugitive#repo')
    3              0.000014         if get(b:, 'fugitive_type', '') is# 'blob'
                                      let b:fugitive_name = fugitive#repo().translate(FugitivePath(@%, ''))
                                    endif
    3              0.000010       elseif exists('b:git_dir') && !exists('*fugitive#repo')
                                    let buffer = fugitive#buffer()
                                    if buffer.type('blob')
                                      let b:fugitive_name = buffer.repo().translate(buffer.path('/'))
                                    endif
                                  endif
    3              0.000003     catch
                                endtry
    3              0.000002   endif
                            
  639   0.014045   0.008067   let fmod = s:ModifierFlags()
  639              0.003160   if empty(b:fugitive_name)
  639              0.087361     return fnamemodify(bufname('%'), fmod)
                              else
                                return fnamemodify(b:fugitive_name, fmod). " [git]"
                              endif

FUNCTION  GetStyledIndent()
Called 1 time
Total time:   0.002857
 Self time:   0.000203

count  total (s)   self (s)
    1   0.000306   0.000025   if s:IsStyledDefinition(v:lnum)
                                let l:baseIndent = 0
                            
                                " find last non-styled line
                                let l:cnum = v:lnum
                                while s:IsStyledDefinition(l:cnum)
                                  let l:cnum -= 1
                                endwhile
                            
                                " get indentation of the last non-styled line as base indentation
                                let l:baseIndent = indent(l:cnum)
                            
                                " incrementally build indentation based on current indentation
                                " - one shiftwidth for the styled definition region
                                " - one shiftwidth per open nested definition region
                                let l:styledIndent = &sw
                                let l:styledIndent += min([ s:CountOccurencesInSOL(v:lnum, 'styledNestedRegion'), s:CountOccurencesInEOL(v:lnum, 'styledNestedRegion', 0) ]) * &sw
                            
                                " decrease indentation by one shiftwidth, if the styled definition
                                " region ends on the current line
                                " - either directly via styled definition region, or
                                " - if the very last
                                if s:CountOccurencesInEOL(v:lnum, 'styledDefinition', 1) == 0
                                  let l:styledIndent -= &sw
                                endif
                            
                                " return the base indentation
                                " (for nested styles inside classes/objects/etc.) plus the actual
                                " indentation inside the styled definition region
                                return l:baseIndent + l:styledIndent
                              elseif len(b:js_ts_indent)
    1              0.000003     let l:result = 0
    1              0.000003     let l:offset = 0
                            
                                " increase indentation by one shiftwidth, if the last line ended on a
                                " styledXmlRegion and this line does not continue with it
                                " this is a fix for an incorrectly indented xml prop after a
                                " glamor-styled styledXmlRegion
    1   0.000140   0.000031     if s:CountOccurencesInEOL(v:lnum-1, 'styledXmlRegion', 0) == 1 && s:CountOccurencesInSOL(v:lnum, 'styledXmlRegion') == 0
                                  let l:offset = &sw
                                endif
                            
                                " make sure `GetStyledIndent` and `GetJsxIndent` don't infinitely
                                " recurse by incrementing a counter variable, before evaluating the
                                " stored indent expression
    1              0.000002     if s:is_recursion == 0
    1              0.000003       let s:is_recursion = 1
    1   0.002290   0.000025       let l:result = eval(b:js_ts_indent)
    1              0.000001     endif
                            
                                " `is_recursion` being 0 at this point indicates, that
                                " `eval(b:js_ts_indent)` did itself evaluate it's stored indentexpr
                                " and thus it can be assumed, that the current line should be
                                " indented as JS
    1              0.000003     if s:is_recursion == 0
                                  " use one of `GetJavascriptIndent` or `GetJsIndent` if existing
                                  " fallback to cindent, if not
                                  if exists('*GetJavascriptIndent')
                                    let l:result = GetJavascriptIndent()
                                  elseif exists('*GetJsIndent')
                                    let l:result = GetJsIndent()
                                  else
                                    let l:result = cindent(v:lnum)
                                  endif
                                endif
                            
                                " reset `is_recursion` counter and return the indentation value
    1              0.000003     let s:is_recursion = 0
    1              0.000003     return l:result + l:offset
                              endif
                            
                              " if all else fails indent according to C-syntax
                              return cindent(v:lnum)

FUNCTION  <SNR>129_Trim()
Called 2 times
Total time:   0.000299
 Self time:   0.000057

count  total (s)   self (s)
    2              0.000012   call cursor(a:ln+1,1)
    2   0.000272   0.000030   call s:previous_token()
    2              0.000013   return strpart(getline('.'),0,col('.'))

FUNCTION  <SNR>96_ws_refresh()
Called 1 time
Total time:   0.000047
 Self time:   0.000047

count  total (s)   self (s)
    1              0.000013   if get(b:, 'airline_ws_changedtick', 0) == b:changedtick
                                return
                              endif
    1              0.000012   unlet! b:airline_whitespace_check
    1              0.000007   if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh!'
                              endif
    1              0.000006   let b:airline_ws_changedtick = b:changedtick

FUNCTION  gitgutter#sign#update_signs()
Called 2 times
Total time:   0.006876
 Self time:   0.000277

count  total (s)   self (s)
    2   0.003820   0.000042   call s:find_current_signs(a:bufnr)
                            
    2              0.000037   let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
    2   0.000555   0.000044   let obsolete_signs = s:obsolete_gitgutter_signs_to_remove(a:bufnr, new_gitgutter_signs_line_numbers)
                            
    2              0.000015   let flicker_possible = s:remove_all_old_signs && !empty(a:modified_lines)
    2              0.000005   if flicker_possible
                                call s:add_dummy_sign(a:bufnr)
                              endif
                            
    2   0.001022   0.000039   call s:remove_signs(a:bufnr, obsolete_signs, s:remove_all_old_signs)
    2   0.001378   0.000052   call s:upsert_new_gitgutter_signs(a:bufnr, a:modified_lines)
                            
    2              0.000004   if flicker_possible
                                call gitgutter#sign#remove_dummy_sign(a:bufnr, 0)
                              endif

FUNCTION  <SNR>171_GetCounts()
Called 1244 times
Total time:   0.088569
 Self time:   0.045270

count  total (s)   self (s)
 1244   0.035508   0.013662     if !s:BufferCacheExists(a:buffer)
                                    return s:CreateCountDict()
                                endif
                            
 1244   0.035651   0.014198     call s:UpdateCacheIfNecessary(a:buffer)
                            
 1244              0.006335     return g:ale_buffer_info[a:buffer].count

FUNCTION  ale#node#Executable()
Called 5 times
Total time:   0.000261
 Self time:   0.000143

count  total (s)   self (s)
    5              0.000045     if has('win32') && a:executable =~? '\.js$'
                                    let l:node = ale#Var(a:buffer, 'windows_node_executable_path')
                            
                                    return ale#Escape(l:node) . ' ' . ale#Escape(a:executable)
                                endif
                            
    5   0.000161   0.000043     return ale#Escape(a:executable)

FUNCTION  ale#sign#GetSignName()
Called 13 times
Total time:   0.001966
 Self time:   0.001061

count  total (s)   self (s)
   13              0.000077     let l:priority = g:ale#util#style_warning_priority
                            
                                " Determine the highest priority item for the line.
   33              0.000104     for l:item in a:sublist
   20   0.001228   0.000323         let l:item_priority = ale#util#GetItemPriority(l:item)
                            
   20              0.000071         if l:item_priority > l:priority
   13              0.000047             let l:priority = l:item_priority
   13              0.000018         endif
   20              0.000026     endfor
                            
   13              0.000044     if l:priority is# g:ale#util#error_priority
   13              0.000033         return 'ALEErrorSign'
                                endif
                            
                                if l:priority is# g:ale#util#warning_priority
                                    return 'ALEWarningSign'
                                endif
                            
                                if l:priority is# g:ale#util#style_error_priority
                                    return 'ALEStyleErrorSign'
                                endif
                            
                                if l:priority is# g:ale#util#style_warning_priority
                                    return 'ALEStyleWarningSign'
                                endif
                            
                                if l:priority is# g:ale#util#info_priority
                                    return 'ALEInfoSign'
                                endif
                            
                                " Use the error sign for invalid severities.
                                return 'ALEErrorSign'

FUNCTION  <SNR>141_GetAliasedFiletype()
Called 2 times
Total time:   0.000225
 Self time:   0.000225

count  total (s)   self (s)
    2              0.000020     let l:buffer_aliases = get(b:, 'ale_linter_aliases', {})
                            
                                " b:ale_linter_aliases can be set to a List or String.
    2              0.000019     if type(l:buffer_aliases) is v:t_list|| type(l:buffer_aliases) is v:t_string
                                    return l:buffer_aliases
                                endif
                            
                                " Check for aliased filetypes first in a buffer variable,
                                " then the global variable,
                                " then in the default mapping,
                                " otherwise use the original filetype.
    8              0.000048     for l:dict in [   l:buffer_aliases,   g:ale_linter_aliases,   s:default_ale_linter_aliases,]
    6              0.000039         if has_key(l:dict, a:original_filetype)
                                        return l:dict[a:original_filetype]
                                    endif
    6              0.000012     endfor
                            
    2              0.000007     return a:original_filetype

FUNCTION  ale#list#SetLists()
Called 7 times
Total time:   0.004965
 Self time:   0.000425

count  total (s)   self (s)
    7              0.000123     if get(g:, 'ale_set_lists_synchronously') == 1|| getbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Update lists immediately if running a test synchronously, or if the
                                    " buffer was saved.
                                    "
                                    " The lists need to be updated immediately when saving a buffer so
                                    " that we can reliably close window automatically, if so configured.
    3   0.004441   0.000050         call s:SetListsImpl(-1, a:buffer, a:loclist)
    3              0.000004     else
    4   0.000270   0.000120         call ale#util#StartPartialTimer(   0,   function('s:SetListsImpl'),   [a:buffer, a:loclist],)
    4              0.000007     endif

FUNCTION  ale#fix#registry#ResetToDefaults()
Called 1 time
Total time:   0.001501
 Self time:   0.001501

count  total (s)   self (s)
    1              0.000236     let s:entries = deepcopy(s:default_registry)
    1              0.000046     let s:aliases = {}
                            
                                " Set up aliases for fixers too.
   63              0.000369     for [l:key, l:entry] in items(s:entries)
   65              0.000407         for l:alias in get(l:entry, 'aliases', [])
    3              0.000018             let s:aliases[l:alias] = l:key
    3              0.000005         endfor
   62              0.000078     endfor

FUNCTION  NERDTreeGetGitStatusPrefix()
Called 3 times
Total time:   0.065161
 Self time:   0.000722

count  total (s)   self (s)
    3              0.000026     if localtime() - s:GitStatusCacheTime > s:GitStatusCacheTimeExpiry
    1              0.000010         let s:GitStatusCacheTime = localtime()
    1   0.062632   0.000061         call g:NERDTreeGitStatusRefresh()
    1              0.000002     endif
    3   0.000855   0.000058     let l:pathStr = a:path.str()
    3   0.001015   0.000121     let l:cwd = b:NERDTree.root.path.str() . a:path.Slash()
    3   0.000104   0.000048     if nerdtree#runningWindows()
                                    let l:pathStr = a:path.WinToUnixPath(l:pathStr)
                                    let l:cwd = a:path.WinToUnixPath(l:cwd)
                                endif
    3              0.000069     let l:cwd = substitute(l:cwd, '\~', '\\~', 'g')
    3              0.000073     let l:pathStr = substitute(l:pathStr, l:cwd, '', '')
    3              0.000013     let l:statusKey = ''
    3              0.000010     if a:path.isDirectory
    2              0.000027         let l:statusKey = get(b:NERDTreeCachedGitDirtyDir, fnameescape(l:pathStr . '/'), '')
    2              0.000003     else
    1              0.000012         let l:statusKey = get(b:NERDTreeCachedGitFileStatus, fnameescape(l:pathStr), '')
    1              0.000002     endif
    3   0.000189   0.000068     return s:NERDTreeGetIndicator(l:statusKey)

FUNCTION  airline#extensions#tabline#buffers#get()
Called 14 times
Total time:   0.022317
 Self time:   0.001164

count  total (s)   self (s)
   14              0.000046   try
   14   0.004842   0.000221     call <sid>map_keys()
   14              0.000024   catch
                                " no-op
                              endtry
   14              0.000096   let cur = bufnr('%')
   14              0.000092   if cur == s:current_bufnr && &columns == s:column_width
   14              0.000121     if !g:airline_detect_modified || getbufvar(cur, '&modified') == s:current_modified
   13              0.000041       return s:current_tabline
                                endif
    1              0.000001   endif
                            
    1   0.000288   0.000048   let b = airline#extensions#tabline#new_builder()
    1              0.000009   let tab_bufs = tabpagebuflist(tabpagenr())
    1              0.000004   let show_buf_label_first = 0
                            
    1              0.000007   if get(g:, 'airline#extensions#tabline#buf_label_first', 0)
                                let show_buf_label_first = 1
                              endif
    1              0.000003   if show_buf_label_first
                                call airline#extensions#tabline#add_label(b, 'buffers', 0)
                              endif
                            
    1              0.000009   let b.tab_bufs = tabpagebuflist(tabpagenr())
                            
    1              0.000004   let b.overflow_group = 'airline_tabhid'
    1   0.000026   0.000014   let b.buffers = airline#extensions#tabline#buflist#list()
    1              0.000006   if get(g:, 'airline#extensions#tabline#current_first', 0)
                                if index(b.buffers, cur) > -1
                                  call remove(b.buffers, index(b.buffers, cur))
                                endif
                                let b.buffers = [cur] + b.buffers
                              endif
                            
    1              0.000004   function! b.get_group(i) dict
                                let bufnum = get(self.buffers, a:i, -1)
                                if bufnum == -1
                                  return ''
                                endif
                                let group = airline#extensions#tabline#group_of_bufnr(self.tab_bufs, bufnum)
                                if bufnum == bufnr('%')
                                  let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
                                endif
                                return group
                              endfunction
                            
    1              0.000008   if has("tablineat")
    1              0.000003     function! b.get_pretitle(i) dict
                                  let bufnum = get(self.buffers, a:i, -1)
                                  return '%'.bufnum.'@airline#extensions#tabline#buffers#clickbuf@'
                                endfunction
                            
    1              0.000003     function! b.get_posttitle(i) dict
                                  return '%X'
                                endfunction
    1              0.000002   endif
                            
    1              0.000003   function! b.get_title(i) dict
                                let bufnum = get(self.buffers, a:i, -1)
                                let group = self.get_group(a:i)
                                let pgroup = self.get_group(a:i - 1)
                                " always add a space when powerline_fonts are used
                                " or for the very first item
                                if get(g:, 'airline_powerline_fonts', 0) || a:i == 0
                                  let space = s:spc
                                else
                                  let space= (pgroup == group ? s:spc : '')
                                endif
                            
                                if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
                                  if len(s:number_map) > 0
                                    return space. s:get_number(a:i) . '%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)' . s:spc
                                  else
                                    return '['.(a:i+1).s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.']'
                                  endif
                                else
                                  return space.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.s:spc
                                endif
                              endfunction
                            
    1              0.000014   let current_buffer = max([index(b.buffers, cur), 0])
    1              0.000007   let last_buffer = len(b.buffers) - 1
    1   0.000109   0.000019   call b.insert_titles(current_buffer, 0, last_buffer)
                            
    1   0.000035   0.000014   call b.add_section('airline_tabfill', '')
    1   0.000021   0.000011   call b.split()
    1   0.000026   0.000016   call b.add_section('airline_tabfill', '')
    1              0.000003   if !show_buf_label_first
    1   0.000141   0.000028     call airline#extensions#tabline#add_label(b, 'buffers', 1)
    1              0.000001   endif
                            
    1   0.000051   0.000028   call airline#extensions#tabline#add_tab_label(b)
                            
    1              0.000009   let s:current_bufnr = cur
    1              0.000009   let s:column_width = &columns
    1   0.016039   0.000026   let s:current_tabline = b.build()
    1              0.000010   let s:current_visible_buffers = copy(b.buffers)
                              " Do not remove from s:current_visible_buffers, this breaks s:select_tab()
                              "if b._right_title <= last_buffer
                              "  call remove(s:current_visible_buffers, b._right_title, last_buffer)
                              "endif
                              "if b._left_title > 0
                              "  call remove(s:current_visible_buffers, 0, b._left_title)
                              "endif
    1              0.000002   return s:current_tabline

FUNCTION  <SNR>169_SetListsImpl()
Called 7 times
Total time:   0.009925
 Self time:   0.003552

count  total (s)   self (s)
    7              0.000956     let l:title = expand('#' . a:buffer . ':p')
                            
    7              0.000030     if g:ale_set_quickfix
                                    let l:quickfix_list = ale#list#GetCombinedList()
                            
                                    if has('nvim')
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list), ' ', l:title)
                                    else
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list))
                                        call setqflist([], 'r', {'title': l:title})
                                    endif
                                elseif g:ale_set_loclist
                                    " If windows support is off, win_findbuf() may not exist.
                                    " We'll set result in the current window, which might not be correct,
                                    " but it's better than nothing.
    7   0.000254   0.000121         let l:ids = s:WinFindBuf(a:buffer)
                            
   14              0.000052         for l:id in l:ids
    7              0.000051             if has('nvim')
    7   0.006196   0.000739                 call setloclist(l:id, s:FixList(a:buffer, a:loclist), ' ', l:title)
    7              0.000018             else
                                            call setloclist(l:id, s:FixList(a:buffer, a:loclist))
                                            call setloclist(l:id, [], 'r', {'title': l:title})
                                        endif
    7              0.000012         endfor
    7              0.000010     endif
                            
                                " Open a window to show the problems if we need to.
                                "
                                " We'll check if the current buffer's List is not empty here, so the
                                " window will only be opened if the current buffer has problems.
    7   0.000635   0.000136     if s:ShouldOpen(a:buffer) && !empty(a:loclist)
                                    let l:winnr = winnr()
                                    let l:mode = mode()
                                    let l:reset_visual_selection = l:mode is? 'v' || l:mode is# "\<c-v>"
                                    let l:reset_character_selection = l:mode is? 's' || l:mode is# "\<c-s>"
                            
                                    " open windows vertically instead of default horizontally
                                    let l:open_type = ''
                            
                                    if ale#Var(a:buffer, 'list_vertical') == 1
                                        let l:open_type = 'vert rightbelow '
                                    endif
                            
                                    if g:ale_set_quickfix
                                        if !ale#list#IsQuickfixOpen()
                                            silent! execute l:open_type . 'copen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                        endif
                                    elseif g:ale_set_loclist
                                        silent! execute l:open_type . 'lopen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                    endif
                            
                                    " If focus changed, restore it (jump to the last window).
                                    if l:winnr isnot# winnr()
                                        wincmd p
                                    endif
                            
                                    if l:reset_visual_selection || l:reset_character_selection
                                        " If we were in a selection mode before, select the last selection.
                                        normal! gv
                            
                                        if l:reset_character_selection
                                            " Switch back to Select mode, if we were in that.
                                            normal! "\<c-g>"
                                        endif
                                    endif
                                endif
                            
                                " If ALE isn't currently checking for more problems, close the window if
                                " needed now. This check happens inside of this timer function, so
                                " the window can be closed reliably.
    7   0.000274   0.000098     if !ale#engine#IsCheckingBuffer(a:buffer)
    1   0.000138   0.000029         call s:CloseWindowIfNeeded(a:buffer)
    1              0.000001     endif

FUNCTION  <SNR>118_PlatformSlash()
Called 1278 times
Total time:   0.020657
 Self time:   0.020657

count  total (s)   self (s)
 1278              0.008454   if exists('+shellslash') && !&shellslash
                                return tr(a:path, '/', '\')
                              else
 1278              0.003479     return a:path
                              endif

FUNCTION  airline#util#has_fugitive()
Called 643 times
Total time:   0.006154
 Self time:   0.006154

count  total (s)   self (s)
  643              0.005485   return exists('*fugitive#head') || exists('*FugitiveHead')

FUNCTION  <SNR>164_is_added()
Called 10 times
Total time:   0.000204
 Self time:   0.000204

count  total (s)   self (s)
   10              0.000196   return a:from_count == 0 && a:to_count > 0

FUNCTION  ale#fix#Fix()
Called 1 time
Total time:   0.026279
 Self time:   0.000357

count  total (s)   self (s)
    1              0.000011     if a:fixing_flag isnot# '' && a:fixing_flag isnot# 'save_file'
                                    throw "fixing_flag must be either '' or 'save_file'"
                                endif
                            
    1              0.000002     try
    1   0.004677   0.000036         let l:callback_list = s:GetCallbacks(a:buffer, a:fixing_flag, a:000)
    1              0.000002     catch /E700\|BADNAME/
                                    let l:function_name = join(split(split(v:exception, ':')[3]))
                                    let l:echo_message = printf(   'There is no fixer named `%s`. Check :ALEFixSuggest',   l:function_name,)
                                    execute 'echom l:echo_message'
                            
                                    return 0
                                endtry
                            
    1              0.000004     if empty(l:callback_list)
                                    if a:fixing_flag is# ''
                                        execute 'echom ''No fixers have been defined. Try :ALEFixSuggest'''
                                    endif
                            
                                    return 0
                                endif
                            
    1   0.000130   0.000022     call ale#command#StopJobs(a:buffer, 'fixer')
                                " Clean up any files we might have left behind from a previous run.
    1   0.000095   0.000033     call ale#command#RemoveManagedFiles(a:buffer)
    1   0.000102   0.000027     call ale#fix#InitBufferData(a:buffer, a:fixing_flag)
                            
    1   0.000186   0.000093     silent doautocmd <nomodeline> User ALEFixPre
                            
    1   0.021011   0.000067     call s:RunFixer({   'buffer': a:buffer,   'input': g:ale_fix_buffer_data[a:buffer].lines_before,   'callback_index': 0,   'callback_list': l:callback_list,})
                            
    1              0.000005     return 1

FUNCTION  ale#lsp#HandleMessage()
Called 8 times
Total time:   0.059816
 Self time:   0.001589

count  total (s)   self (s)
    8              0.000103     let l:conn = get(s:connections, a:conn_id, {})
                            
    8              0.000034     if empty(l:conn)
                                    return
                                endif
                            
    8              0.000045     if type(a:message) isnot v:t_string
                                    " Ignore messages that aren't strings.
                                    return
                                endif
                            
    8              0.000049     let l:conn.data .= a:message
                            
                                " Parse the objects now if we can, and keep the remaining text.
    8   0.004477   0.000227     let [l:conn.data, l:response_list] = ale#lsp#ReadMessageData(l:conn.data)
                            
                                " Look for initialize responses first.
    8              0.000030     if !l:conn.initialized
                                    for l:response in l:response_list
                                        call ale#lsp#HandleInitResponse(l:conn, l:response)
                                    endfor
                                endif
                            
                                " If the connection is marked as initialized, call the callbacks with the
                                " responses.
    8              0.000021     if l:conn.initialized
   20              0.000067         for l:response in l:response_list
                                        " Call all of the registered handlers with the response.
   24              0.000114             for l:Callback in l:conn.callback_list
   12   0.054332   0.000355                 call ale#util#GetFunction(l:Callback)(a:conn_id, l:response)
   12              0.000026             endfor
   12              0.000018         endfor
    8              0.000011     endif

FUNCTION  ale#highlight#UpdateHighlights()
Called 7 times
Total time:   0.004738
 Self time:   0.002730

count  total (s)   self (s)
    7              0.000097     let l:item_list = get(b:, 'ale_enabled', 1) && g:ale_enabled   ? get(b:, 'ale_highlight_items', [])   : []
                            
    7   0.001174   0.000119     call ale#highlight#RemoveHighlights()
                            
   27              0.000159     for l:item in l:item_list
   20              0.000084         if l:item.type is# 'W'
                                        if get(l:item, 'sub_type', '') is# 'style'
                                            let l:group = 'ALEStyleWarning'
                                        else
                                            let l:group = 'ALEWarning'
                                        endif
                                    elseif l:item.type is# 'I'
                                        let l:group = 'ALEInfo'
                                    elseif get(l:item, 'sub_type', '') is# 'style'
                                        let l:group = 'ALEStyleError'
                                    else
   20              0.000070             let l:group = 'ALEError'
   20              0.000028         endif
                            
   20              0.000360         let l:range = {   'lnum': l:item.lnum,   'col': l:item.col,   'end_lnum': get(l:item, 'end_lnum', l:item.lnum),   'end_col': get(l:item, 'end_col', l:item.col)}
                            
   20   0.001299   0.000347         call s:highlight_range(l:item.bufnr, l:range, l:group)
   20              0.000047     endfor
                            
                                " If highlights are enabled and signs are not enabled, we should still
                                " offer line highlights by adding a separate set of highlights.
    7              0.000024     if !g:ale_set_signs
                                    let l:available_groups = {   'ALEWarningLine': hlexists('ALEWarningLine'),   'ALEInfoLine': hlexists('ALEInfoLine'),   'ALEErrorLine': hlexists('ALEErrorLine'),}
                            
                                    for l:item in l:item_list
                                        if l:item.type is# 'W'
                                            let l:group = 'ALEWarningLine'
                                        elseif l:item.type is# 'I'
                                            let l:group = 'ALEInfoLine'
                                        else
                                            let l:group = 'ALEErrorLine'
                                        endif
                            
                                        if l:available_groups[l:group]
                                            call s:highlight_line(l:item.bufnr, l:item.lnum, l:group)
                                        endif
                                    endfor
                                endif

FUNCTION  <SNR>165_obsolete_gitgutter_signs_to_remove()
Called 2 times
Total time:   0.000511
 Self time:   0.000464

count  total (s)   self (s)
    2              0.000007   let signs_to_remove = []  " list of [<id (number)>, ...]
    2              0.000006   let remove_all_signs = 1
    2   0.000072   0.000024   let old_gitgutter_signs = gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')
   22              0.000058   for line_number in keys(old_gitgutter_signs)
   20              0.000112     if index(a:new_gitgutter_signs_line_numbers, str2nr(line_number)) == -1
    1              0.000008       call add(signs_to_remove, old_gitgutter_signs[line_number].id)
    1              0.000002     else
   19              0.000044       let remove_all_signs = 0
   19              0.000018     endif
   20              0.000018   endfor
    2              0.000026   let s:remove_all_old_signs = remove_all_signs
    2              0.000007   return signs_to_remove

FUNCTION  <SNR>172_HandleExit()
Called 2 times
Total time:   0.029628
 Self time:   0.001505

count  total (s)   self (s)
    2              0.000024     let l:buffer_info = get(g:ale_fix_buffer_data, a:buffer, {})
                            
    2              0.000010     if empty(l:buffer_info)
                                    return
                                endif
                            
    2              0.000006     if a:job_info.read_temporary_file
    1              0.000156         let l:output = !empty(a:data.temporary_file)   ?  readfile(a:data.temporary_file)   : []
    1              0.000003     else
    1              0.000004         let l:output = a:job_output
    1              0.000001     endif
                            
    2              0.000016     let l:ChainCallback = get(a:job_info, 'chain_with', v:null)
    2              0.000013     let l:ProcessWith = get(a:job_info, 'process_with', v:null)
                            
                                " Post-process the output with a function if we have one.
    2              0.000008     if l:ProcessWith isnot v:null
    1   0.000230   0.000045         let l:output = call(l:ProcessWith, [a:buffer, l:output])
    1              0.000002     endif
                            
                                " Use the output of the job for changing the file if it isn't empty,
                                " otherwise skip this job and use the input from before.
                                "
                                " We'll use the input from before for chained commands.
    2              0.000984     if l:ChainCallback is v:null && !empty(split(join(l:output)))
    1              0.000010         let l:input = l:output
    1              0.000002     else
    1              0.000005         let l:input = a:job_info.input
    1              0.000001     endif
                            
    2              0.000013     if l:ChainCallback isnot v:null && !get(g:, 'ale_ignore_2_4_warnings')
                                    execute 'echom ''chain_with is deprecated. Use `let g:ale_ignore_2_4_warnings = 1` to disable this message.'''
                                endif
                            
    2              0.000018     let l:next_index = l:ChainCallback is v:null   ? a:job_info.callback_index + 1   : a:job_info.callback_index
                            
    2   0.028019   0.000080     call s:RunFixer({   'buffer': a:buffer,   'input': l:input,   'output': l:output,   'callback_list': a:job_info.callback_list,   'callback_index': l:next_index,   'chain_callback': l:ChainCallback,})

FUNCTION  <SNR>130_CountOccurencesInEOL()
Called 1 time
Total time:   0.000109
 Self time:   0.000056

count  total (s)   self (s)
    1              0.000005   let l:occurence = 0
                            
                              " iterate through all items in the given line
    2   0.000077   0.000023   for item in s:SynEOL(a:lnum, a:offset)
                                " if the syntax-item equals the given str increment the counter
                                " `==?` is a case insensitive equal operation
    1              0.000005     if item == a:str
                                  let l:occurence += 1
                                endif
    1              0.000001   endfor
                            
                              " return the accumulated count of occurences
    1              0.000002   return l:occurence

FUNCTION  ale#job#HasOpenChannel()
Called 2 times
Total time:   0.000101
 Self time:   0.000055

count  total (s)   self (s)
    2   0.000083   0.000037     if ale#job#IsRunning(a:job_id)
    2              0.000010         if has('nvim')
                                        " TODO: Implement a check for NeoVim.
    2              0.000003             return 1
                                    endif
                            
                                    " Check if the Job's channel can be written to.
                                    return ch_status(s:job_map[a:job_id].job) is# 'open'
                                endif
                            
                                return 0

FUNCTION  ale#engine#MarkLinterInactive()
Called 7 times
Total time:   0.000141
 Self time:   0.000141

count  total (s)   self (s)
    7              0.000128     call filter(a:info.active_linter_list, 'v:val.name isnot# a:linter_name')

FUNCTION  ale#lsp#response#ReadTSServerDiagnostics()
Called 6 times
Total time:   0.001061
 Self time:   0.001061

count  total (s)   self (s)
    6              0.000028     let l:loclist = []
                            
   12              0.000048     for l:diagnostic in a:response.body.diagnostics
    6              0.000099         let l:loclist_item = {   'text': l:diagnostic.text,   'type': 'E',   'lnum': l:diagnostic.start.line,   'col': l:diagnostic.start.offset,   'end_lnum': l:diagnostic.end.line,   'end_col': l:diagnostic.end.offset - 1,}
                            
    6              0.000033         if has_key(l:diagnostic, 'code')
    6              0.000033             if type(l:diagnostic.code) == v:t_string
                                            let l:loclist_item.code = l:diagnostic.code
                                        elseif type(l:diagnostic.code) == v:t_number && l:diagnostic.code != -1
    6              0.000067                 let l:loclist_item.code = string(l:diagnostic.code)
    6              0.000031                 let l:loclist_item.nr = l:diagnostic.code
    6              0.000011             endif
    6              0.000015         endif
                            
    6              0.000042         if get(l:diagnostic, 'category') is# 'warning'
                                        let l:loclist_item.type = 'W'
                                    endif
                            
    6              0.000035         if get(l:diagnostic, 'category') is# 'suggestion'
                                        let l:loclist_item.type = 'I'
                                    endif
                            
    6              0.000041         call add(l:loclist, l:loclist_item)
    6              0.000012     endfor
                            
    6              0.000019     return l:loclist

FUNCTION  ale#lsp#Send()
Called 4 times
Total time:   0.001436
 Self time:   0.000330

count  total (s)   self (s)
    4              0.000047     let l:conn = get(s:connections, a:conn_id, {})
                            
    4              0.000016     if empty(l:conn)
                                    return 0
                                endif
                            
    4              0.000010     if !l:conn.initialized
                                    throw 'LSP server not initialized yet!'
                                endif
                            
    4   0.000832   0.000100     let [l:id, l:data] = ale#lsp#CreateMessageData(a:message)
    4   0.000467   0.000092     call s:SendMessageData(l:conn, l:data)
                            
    4              0.000013     return l:id == 0 ? -1 : l:id

FUNCTION  airline#parts#filetype()
Called 639 times
Total time:   0.024290
 Self time:   0.011096

count  total (s)   self (s)
  639   0.023622   0.010428   return (airline#util#winwidth() < 90 && strlen(&filetype) > 3) ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? '…' : '>') : &filetype

FUNCTION  airline#extensions#netrw#apply()
Called 4 times
Total time:   0.000177
 Self time:   0.000177

count  total (s)   self (s)
    4              0.000038   if &ft == 'netrw'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.'netrw'.spc)
                                if exists('*airline#extensions#branch#get_head')
                                  call a:1.add_section('airline_b', spc.'%{airline#extensions#branch#get_head()}'.spc)
                                endif
                                call a:1.add_section('airline_c', spc.'%f'.spc)
                                call a:1.split()
                                call a:1.add_section('airline_y', spc.'%{airline#extensions#netrw#sortstring()}'.spc)
                                return 1
                              endif

FUNCTION  <SNR>39_NERDTreeCacheDirtyDir()
Called 4 times
Total time:   0.000513
 Self time:   0.000390

count  total (s)   self (s)
                                " cache dirty dir
    4   0.000186   0.000062     let l:dirtyPath = s:NERDTreeTrimDoubleQuotes(a:pathStr)
    4              0.000040     if l:dirtyPath =~# '\.\./.*'
                                    return
                                endif
    4              0.000061     let l:dirtyPath = substitute(l:dirtyPath, '/[^/]*$', '/', '')
    5              0.000123     while l:dirtyPath =~# '.\+/.*' && has_key(b:NERDTreeCachedGitDirtyDir, fnameescape(l:dirtyPath)) == 0
    1              0.000010         let b:NERDTreeCachedGitDirtyDir[fnameescape(l:dirtyPath)] = 'Dirty'
    1              0.000016         let l:dirtyPath = substitute(l:dirtyPath, '/[^/]*/$', '/', '')
    1              0.000002     endwhile

FUNCTION  airline#parts#iminsert()
Called 639 times
Total time:   0.008549
 Self time:   0.008549

count  total (s)   self (s)
  639              0.003556   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
                              endif
  639              0.000976   return ''

FUNCTION  gitgutter#hunk#summary()
Called 647 times
Total time:   0.031884
 Self time:   0.011437

count  total (s)   self (s)
  647   0.031134   0.010688   return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  airline#extensions#term#apply()
Called 4 times
Total time:   0.000179
 Self time:   0.000179

count  total (s)   self (s)
    4              0.000040   if &buftype == 'terminal' || bufname('%')[0] == '!'
                                let spc = g:airline_symbols.space
                            
                                let name=get(g:airline_mode_map, 't', 't')
                                call a:1.add_section('airline_a', spc.name.spc)
                                call a:1.add_section('airline_b', '')
                                call a:1.add_section('airline_term', spc.s:termname())
                                call a:1.split()
                                call a:1.add_section('airline_y', '')
                                call a:1.add_section('airline_z', spc.airline#section#create_right(['linenr', 'maxlinenr']))
                                return 1
                              endif

FUNCTION  ale#handlers#tslint#GetExecutable()
Called 3 times
Total time:   0.002241
 Self time:   0.000066

count  total (s)   self (s)
    3   0.002231   0.000056     return ale#node#FindExecutable(a:buffer, 'typescript_tslint', [   'node_modules/.bin/tslint',])

FUNCTION  <SNR>130_SynEOL()
Called 1 time
Total time:   0.000054
 Self time:   0.000027

count  total (s)   self (s)
    1              0.000007   let l:lnum = prevnonblank(a:lnum)
    1              0.000007   let l:col = strlen(getline(l:lnum))
                            
    1   0.000037   0.000011   return s:GetSyntaxNames(l:lnum, l:col + a:offset)

FUNCTION  <SNR>129_GetPair()
Called 1 time
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    1              0.000020 	return searchpair('\m'.a:start,'','\m'.a:end,a:flags,a:skip,max([prevnonblank(v:lnum) - 2000,0] + a:000),a:time)

FUNCTION  <SNR>129_token()
Called 3 times
Total time:   0.000092
 Self time:   0.000053

count  total (s)   self (s)
    3   0.000090   0.000051   return s:looking_at() =~ '\k' ? expand('<cword>') : s:looking_at()

FUNCTION  gitgutter#process_buffer()
Called 2 times
Total time:   0.033828
 Self time:   0.000463

count  total (s)   self (s)
                              " NOTE a:bufnr is not necessarily the current buffer.
                            
    2   0.002381   0.000035   if gitgutter#utility#is_active(a:bufnr)
                            
    2   0.000148   0.000037     call s:setup_maps(a:bufnr)
                            
    2              0.000015     if has('patch-7.4.1559')
    2              0.000024       let l:Callback = function('gitgutter#process_buffer', [a:bufnr, a:force])
    2              0.000003     else
                                  let l:Callback = {'function': 'gitgutter#process_buffer', 'arguments': [a:bufnr, a:force]}
                                endif
    2   0.000223   0.000032     let how = s:setup_path(a:bufnr, l:Callback)
    2              0.000013     if [how] == ['async']  " avoid string-to-number conversion if how is a number
                                  return
                                endif
                            
    2              0.000013     if a:force || s:has_fresh_changes(a:bufnr)
                            
    2              0.000007       let diff = ''
    2              0.000005       try
    2   0.030830   0.000112         let diff = gitgutter#diff#run_diff(a:bufnr, 'index', 0)
    2              0.000008       catch /gitgutter not tracked/
                                    call gitgutter#debug#log('Not tracked: '.gitgutter#utility#file(a:bufnr))
                                  catch /gitgutter diff failed/
                                    call gitgutter#debug#log('Diff failed: '.gitgutter#utility#file(a:bufnr))
                                    call gitgutter#hunk#reset(a:bufnr)
                                  endtry
                            
    2              0.000011       if diff != 'async'
                                    call gitgutter#diff#handler(a:bufnr, diff)
                                  endif
                            
    2              0.000003     endif
    2              0.000002   endif

FUNCTION  <SNR>162_nvim_output_handler()
Called 5 times
Total time:   0.000121
 Self time:   0.000121

count  total (s)   self (s)
    5              0.000043     if a:event == 'stdout' || a:event == 'stderr'
    5              0.000056       let self.buf .=  join(a:data)
    5              0.000009     endif

FUNCTION  ale#lsp_linter#CheckWithLSP()
Called 2 times
Total time:   0.009204
 Self time:   0.000070

count  total (s)   self (s)
    2   0.009202   0.000068     return ale#lsp_linter#StartLSP(a:buffer, a:linter, function('s:CheckWithLSP'))

FUNCTION  ale#history#SetExitCode()
Called 4 times
Total time:   0.000447
 Self time:   0.000133

count  total (s)   self (s)
    4   0.000395   0.000081     let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                            
                                " If we find a match, then set the code and status.
    4              0.000021     let l:obj.exit_code = a:exit_code
    4              0.000016     let l:obj.status = 'finished'

FUNCTION  <SNR>141_GetLinterNames()
Called 2 times
Total time:   0.000163
 Self time:   0.000163

count  total (s)   self (s)
    2              0.000020     let l:buffer_ale_linters = get(b:, 'ale_linters', {})
                            
                                " b:ale_linters can be set to 'all'
    2              0.000007     if l:buffer_ale_linters is# 'all'
                                    return 'all'
                                endif
                            
                                " b:ale_linters can be set to a List.
    2              0.000010     if type(l:buffer_ale_linters) is v:t_list
                                    return l:buffer_ale_linters
                                endif
                            
                                " Try to get a buffer-local setting for the filetype
    2              0.000012     if has_key(l:buffer_ale_linters, a:original_filetype)
                                    return l:buffer_ale_linters[a:original_filetype]
                                endif
                            
                                " Try to get a global setting for the filetype
    2              0.000012     if has_key(g:ale_linters, a:original_filetype)
                                    return g:ale_linters[a:original_filetype]
                                endif
                            
                                " If the user has configured ALE to only enable linters explicitly, then
                                " don't enable any linters by default.
    2              0.000006     if g:ale_linters_explicit
                                    return []
                                endif
                            
                                " Try to get a default setting for the filetype
    2              0.000014     if has_key(s:default_ale_linters, a:original_filetype)
                                    return s:default_ale_linters[a:original_filetype]
                                endif
                            
    2              0.000004     return 'all'

FUNCTION  airline#highlighter#highlight()
Called 16 times
Total time:   0.606188
 Self time:   0.082376

count  total (s)   self (s)
   16              0.000076   let bufnr = a:0 ? a:1 : ''
   16              0.000113   let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
   16              0.000286   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
   16              0.000082   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
   16              0.000053   let airline_grouplist = []
   16              0.000202   let buffers_in_tabpage = sort(tabpagebuflist())
   16              0.000081   if exists("*uniq")
   16              0.000128     let buffers_in_tabpage = uniq(buffers_in_tabpage)
   16              0.000023   endif
                              " mapped might be something like ['normal', 'normal_modified']
                              " if a group is in both modes available, only define the second
                              " that is how this was done previously overwrite the previous definition
   42              0.000145   for mode in reverse(mapped)
   26              0.000326     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
   21              0.000144       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
  450              0.001809       for kvp in items(dict)
  429              0.001396         let mode_colors = kvp[1]
  429              0.001283         let name = kvp[0]
  429              0.001972         if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
                                      let name = 'airline_c'.bufnr
                                    endif
                                    " do not re-create highlighting for buffers that are no longer visible
                                    " in the current tabpage
  429              0.006143         if name =~# 'airline_c\d\+'
   40              0.000737           let bnr = matchstr(name, 'airline_c\zs\d\+') + 0
   40              0.000215           if bnr > 0 && index(buffers_in_tabpage, bnr) == -1
                                        continue
                                      endif
   40              0.000149         elseif (name =~# '_to_') || (name[0:10] is# 'airline_tab' && !empty(suffix))
                                      " group will be redefined below at exec_separator
                                      " or is not needed for tabline with '_inactive' suffix
                                      " since active flag is 1 for builder)
  240              0.000516           continue
                                    endif
  189   0.005139   0.002278         if s:group_not_done(airline_grouplist, name.suffix)
  143   0.066621   0.001948           call airline#highlighter#exec(name.suffix, mode_colors)
  143              0.000232         endif
                            
  567              0.001993         for accent in keys(s:accents)
  378              0.001781           if !has_key(p.accents, accent)
                                        continue
                                      endif
  378              0.002792           let colors = copy(mode_colors)
  378              0.001654           if p.accents[accent][0] != ''
  189              0.000839             let colors[0] = p.accents[accent][0]
  189              0.000206           endif
  378              0.001317           if p.accents[accent][2] != ''
  189              0.000722             let colors[2] = p.accents[accent][2]
  189              0.000193           endif
  378              0.001157           if len(colors) >= 5
  372              0.002392             let colors[4] = get(p.accents[accent], 4, '')
  372              0.000448           else
    6              0.000038             call add(colors, get(p.accents[accent], 4, ''))
    6              0.000006           endif
  378   0.011050   0.004945           if s:group_not_done(airline_grouplist, name.suffix.'_'.accent)
  286   0.137160   0.004816             call airline#highlighter#exec(name.suffix.'_'.accent, colors)
  286              0.000423           endif
  378              0.000528         endfor
  189              0.000229       endfor
                            
   21              0.000070       if empty(s:separators)
                                    " nothing to be done
                                    continue
                                  endif
                                  " TODO: optimize this
  315              0.001346       for sep in items(s:separators)
                                    " we cannot check, that the group already exists, else the separators
                                    " might not be correctly defined. But perhaps we can skip above groups
                                    " that match the '_to_' name, because they would be redefined here...
  294   0.322434   0.004605         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
  294              0.000467       endfor
   21              0.000018     endif
   26              0.000064   endfor

FUNCTION  <SNR>116_get_separator_change()
Called 2 times
Total time:   0.000580
 Self time:   0.000055

count  total (s)   self (s)
    2   0.000577   0.000053   return s:get_separator_change_with_end(a:new_group, a:old_group, a:end_group, a:end_group, a:sep_size, a:alt_sep_size)

FUNCTION  <SNR>153_FindHistoryItem()
Called 6 times
Total time:   0.000457
 Self time:   0.000351

count  total (s)   self (s)
                                " Search backwards to find a matching job ID. IDs might be recycled,
                                " so finding the last one should be good enough.
   18   0.000254   0.000148     for l:obj in reverse(ale#history#Get(a:buffer))
   18              0.000068         if l:obj.job_id == a:job_id
    6              0.000016             return l:obj
                                    endif
   12              0.000013     endfor
                            
                                return {}

FUNCTION  ale#job#ValidateArguments()
Called 5 times
Total time:   0.000057
 Self time:   0.000057

count  total (s)   self (s)
    5              0.000029     if a:options.mode isnot# 'nl' && a:options.mode isnot# 'raw'
                                    throw 'Invalid mode: ' . a:options.mode
                                endif

FUNCTION  <SNR>129_sw()
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000004 	return shiftwidth()

FUNCTION  <SNR>138_on_stdout_nvim()
Called 4 times
Total time:   0.000123
 Self time:   0.000123

count  total (s)   self (s)
    4              0.000027   if empty(self.stdoutbuffer)
    2              0.000009     let self.stdoutbuffer = a:data
    2              0.000003   else
    2              0.000046     let self.stdoutbuffer = self.stdoutbuffer[:-2] + [self.stdoutbuffer[-1] . a:data[0]] + a:data[1:]
    2              0.000004   endif

FUNCTION  provider#python3#Call()
Called 2439 times
Total time:   8.761339
 Self time:   8.761339

count  total (s)   self (s)
 2439              0.013068   if s:err != ''
                                return
                              endif
 2439              0.012640   if !exists('s:host')
                                let s:rpcrequest = function('rpcrequest')
                            
                                " Ensure that we can load the Python3 host before bootstrapping
                                try
                                  let s:host = remote#host#Require('legacy-python3-provider')
                                catch
                                  let s:err = v:exception
                                  echohl WarningMsg
                                  echomsg v:exception
                                  echohl None
                                  return
                                endtry
                              endif
 2439              8.653515   return call(s:rpcrequest, insert(insert(a:args, 'python_'.a:method), s:host))

FUNCTION  309()
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000002       return '%X'

FUNCTION  268()
Called 3 times
Total time:   0.066098
 Self time:   0.000306

count  total (s)   self (s)
    3   0.000205   0.000107     let event = g:NERDTreeEvent.New(a:nerdtree, a:path, a:event, a:params)
                            
    6   0.000188   0.000062     for listener in s:Notifier.GetListenersForEvent(a:event)
    3   0.065649   0.000082         call {listener}(event)
    3              0.000016     endfor

FUNCTION  airline#extensions#tabline#buflist#list()
Called 16 times
Total time:   0.000151
 Self time:   0.000151

count  total (s)   self (s)
   16              0.000093   if exists('s:current_buffer_list')
   16              0.000037     return s:current_buffer_list
                              endif
                            
                              let exclude_buffers = get(g:, 'airline#extensions#tabline#exclude_buffers', [])
                              let exclude_paths = get(g:, 'airline#extensions#tabline#excludes', [])
                              let exclude_preview = get(g:, 'airline#extensions#tabline#exclude_preview', 1)
                            
                              let list = (exists('g:did_bufmru') && g:did_bufmru) ? BufMRUList() : range(1, bufnr("$"))
                            
                              let buffers = []
                              " If this is too slow, we can switch to a different algorithm.
                              " Basically branch 535 already does it, but since it relies on
                              " BufAdd autocommand, I'd like to avoid this if possible.
                              for nr in list
                                if buflisted(nr)
                                  " Do not add to the bufferlist, if either
                                  " 1) bufnr is exclude_buffers list
                                  " 2) buffername matches one of exclude_paths patterns
                                  " 3) buffer is a quickfix buffer
                                  " 4) when excluding preview windows:
                                  "     'bufhidden' == wipe
                                  "     'buftype' == nofile
                                  " 5) ignore buffers matching airline#extensions#tabline#ignore_bufadd_pat
                            
                                  " check buffer numbers first
                                  if index(exclude_buffers, nr) >= 0
                                    continue
                                  " check paths second
                                  elseif !empty(exclude_paths) && s:ExcludePaths(nr, exclude_paths)
                                    continue
                                  " ignore buffers matching airline#extensions#tabline#ignore_bufadd_pat
                                  elseif airline#util#ignore_buf(bufname(nr))
                                    continue
                                  " check other types last
                                  elseif s:ExcludeOther(nr, exclude_preview)
                                    continue
                                  endif
                            
                                  call add(buffers, nr)
                                endif
                              endfor
                            
                              let s:current_buffer_list = buffers
                              return buffers

FUNCTION  <SNR>150_HandleESLintOutput()
Called 1 time
Total time:   0.001687
 Self time:   0.000225

count  total (s)   self (s)
    1   0.001050   0.000032     if s:CheckForBadConfig(a:buffer, a:lines)
                                    return [{   'lnum': 1,   'text': 'eslint configuration error (type :ALEDetail for more information)',   'detail': join(a:lines, "\n"),}]
                                endif
                            
    1              0.000006     if a:lines == ['Could not connect']
                                    return [{   'lnum': 1,   'text': 'Could not connect to eslint_d. Try updating eslint_d or killing it.',}]
                                endif
                            
    1              0.000004     if a:type is# 'json'
    1   0.000324   0.000040         let l:output = s:parseJSON(a:buffer, a:lines)
    1              0.000002     else
                                    let l:output = s:parseLines(a:buffer, a:lines)
                                endif
                            
    1   0.000151   0.000046     call filter(l:output, {idx, obj -> s:FilterResult(a:buffer, obj)})
                            
    1              0.000022     if expand('#' . a:buffer . ':t') =~? '\.tsx\?$'
    1   0.000092   0.000037         call s:AddHintsForTypeScriptParsingErrors(l:output)
    1              0.000002     endif
                            
    1              0.000003     return l:output

FUNCTION  <SNR>162_untracked_output()
Called 1 time
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
    1              0.000018   if a:buf =~? ('^'. a:dict.cfg['untracked_mark'])
                                let a:dict.cfg.untracked[a:dict.file] = get(g:, 'airline#extensions#branch#notexists', g:airline_symbols.notexists)
                              else
    1              0.000012     let a:dict.cfg.untracked[a:dict.file] = ''
    1              0.000002   endif

FUNCTION  airline#mode_changed()
Called 12 times
Total time:   0.000512
 Self time:   0.000378

count  total (s)   self (s)
                              " airline#visual_active
                              " Boolean: for when to get visual wordcount
                              " needed for the wordcount extension
   12              0.000224   let g:airline#visual_active = (mode() =~? '[vs]')
   12   0.000246   0.000112   call airline#update_tabline()

FUNCTION  15()
Called 21 times
Total time:   0.000403
 Self time:   0.000403

count  total (s)   self (s)
   21              0.000182     if self.cachedDisplayString ==# ""
                                    call self.cacheDisplayString()
                                endif
                            
   21              0.000055     return self.cachedDisplayString

FUNCTION  17()
Called 1 time
Total time:   0.000062
 Self time:   0.000046

count  total (s)   self (s)
    1   0.000028   0.000012     if nerdtree#runningWindows()
                                    if a:fullpath =~ '^\(\\\\\|\/\/\)'
                                        "For network shares, the 'drive' consists of the first two parts of the path, i.e. \\boxname\share
                                        let self.drive = substitute(a:fullpath, '^\(\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\).*', '\1', '')
                                        let self.drive = substitute(self.drive, '/', '\', "g")
                                    else
                                        let self.drive = substitute(a:fullpath, '\(^[a-zA-Z]:\).*', '\1', '')
                                    endif
                                else
    1              0.000006         let self.drive = ''
    1              0.000001     endif
                            

FUNCTION  ale#history#RememberOutput()
Called 2 times
Total time:   0.000185
 Self time:   0.000042

count  total (s)   self (s)
    2   0.000172   0.000029     let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                            
    2              0.000009     let l:obj.output = a:output

FUNCTION  gitgutter#utility#shellescape()
Called 8 times
Total time:   0.000375
 Self time:   0.000342

count  total (s)   self (s)
    8              0.000243   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
    6              0.000024     return a:arg
                              elseif s:winshell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
                              else
    2              0.000011     return shellescape(a:arg)
                              endif

FUNCTION  ale#ShouldDoNothing()
Called 13 times
Total time:   0.003189
 Self time:   0.002307

count  total (s)   self (s)
                                " The checks are split into separate if statements to make it possible to
                                " profile each check individually with Vim's profiling tools.
                                "
                                " Do nothing if ALE is disabled.
   13              0.000122     if !getbufvar(a:buffer, 'ale_enabled', get(g:, 'ale_enabled', 0))
                                    return 1
                                endif
                            
                                " Don't perform any checks when newer NeoVim versions are exiting.
   13              0.000083     if get(v:, 'exiting', v:null) isnot v:null
                                    return 1
                                endif
                            
   13              0.000109     let l:filetype = getbufvar(a:buffer, '&filetype')
                            
                                " Do nothing when there's no filetype.
   13              0.000043     if l:filetype is# ''
                                    return 1
                                endif
                            
                                " Do nothing for diff buffers.
   13              0.000070     if getbufvar(a:buffer, '&diff')
                                    return 1
                                endif
                            
                                " Do nothing for blacklisted files.
   13              0.000182     if index(get(g:, 'ale_filetype_blacklist', []), l:filetype) >= 0
                                    return 1
                                endif
                            
                                " Do nothing if running from command mode.
   13              0.000088     if s:getcmdwintype_exists && !empty(getcmdwintype())
                                    return 1
                                endif
                            
   13              0.000117     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
                                " Do nothing for directories.
   13              0.000043     if l:filename is# '.'
                                    return 1
                                endif
                            
                                " Don't start linting and so on when an operator is pending.
   13   0.000305   0.000188     if ale#util#Mode(1) is# 'no'
                                    return 1
                                endif
                            
                                " Do nothing if running in the sandbox.
   13   0.000640   0.000150     if ale#util#InSandbox()
                                    return 1
                                endif
                            
                                " Do nothing if the file is too large.
   13   0.000447   0.000172     if ale#FileTooLarge(a:buffer)
                                    return 1
                                endif
                            
                                " Do nothing from CtrlP buffers with CtrlP-funky.
   13              0.000192     if exists(':CtrlPFunky') is 2&& getbufvar(a:buffer, '&l:statusline') =~# 'CtrlPMode.*funky'
                                    return 1
                                endif
                            
   13              0.000018     return 0

FUNCTION  <SNR>129_looking_at()
Called 9 times
Total time:   0.000065
 Self time:   0.000065

count  total (s)   self (s)
    9              0.000059   return getline('.')[col('.')-1]

FUNCTION  310()
Called 1 time
Total time:   0.000209
 Self time:   0.000061

count  total (s)   self (s)
    1              0.000008     let bufnum = get(self.buffers, a:i, -1)
    1   0.000107   0.000011     let group = self.get_group(a:i)
    1   0.000061   0.000009     let pgroup = self.get_group(a:i - 1)
                                " always add a space when powerline_fonts are used
                                " or for the very first item
    1              0.000004     if get(g:, 'airline_powerline_fonts', 0) || a:i == 0
    1              0.000002       let space = s:spc
    1              0.000001     else
                                  let space= (pgroup == group ? s:spc : '')
                                endif
                            
    1              0.000003     if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
                                  if len(s:number_map) > 0
                                    return space. s:get_number(a:i) . '%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)' . s:spc
                                  else
                                    return '['.(a:i+1).s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.']'
                                  endif
                                else
    1              0.000005       return space.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.s:spc
                                endif

FUNCTION  airline#extensions#ale#get_error()
Called 639 times
Total time:   0.299534
 Self time:   0.010390

count  total (s)   self (s)
  639   0.298935   0.009791   return airline#extensions#ale#get('error')

FUNCTION  <SNR>171_BufferCacheExists()
Called 1866 times
Total time:   0.032393
 Self time:   0.032393

count  total (s)   self (s)
 1866              0.019634     if !exists('g:ale_buffer_info') || !has_key(g:ale_buffer_info, a:buffer)
                                    return 0
                                endif
                            
 1866              0.002650     return 1

FUNCTION  ale#linter#GetCommand()
Called 4 times
Total time:   0.002292
 Self time:   0.000129

count  total (s)   self (s)
    4              0.000058     let l:Command = has_key(a:linter, 'command_callback')   ? function(a:linter.command_callback)   : a:linter.command
                            
    4   0.002225   0.000061     return type(l:Command) is v:t_func   ? l:Command(a:buffer)   : l:Command

FUNCTION  <SNR>53_SetDefaultCompletionType()
Called 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000012   if exists('b:SuperTabDefaultCompletionType') && (!exists('b:complCommandLine') || !b:complCommandLine)
                                call SuperTabSetCompletionType(b:SuperTabDefaultCompletionType)
                              endif

FUNCTION  22()
Called 53 times
Total time:   0.001407
 Self time:   0.001407

count  total (s)   self (s)
   53              0.000380     if empty(self.pathSegments)
                                    return ''
                                endif
   53              0.000264     let toReturn = self.pathSegments[-1]
   53              0.000165     if a:dirSlash && self.isDirectory
    2              0.000010         let toReturn = toReturn . '/'
    2              0.000003     endif
   53              0.000116     return toReturn

FUNCTION  29()
Called 49 times
Total time:   0.011793
 Self time:   0.005579

count  total (s)   self (s)
                                "filter out the user specified paths to ignore
   49   0.000772   0.000550     if a:nerdtree.ui.isIgnoreFilterEnabled()
   98              0.000354         for i in g:NERDTreeIgnore
   49   0.005373   0.000570             if self._ignorePatternMatches(i)
                                            return 1
                                        endif
   49              0.000071         endfor
                            
   49   0.001434   0.000677         for callback in g:NERDTree.PathFilters()
                                        if {callback}({'path': self, 'nerdtree': a:nerdtree})
                                            return 1
                                        endif
                                    endfor
   49              0.000061     endif
                            
                                "dont show hidden files unless instructed to
   49   0.000829   0.000632     if !a:nerdtree.ui.getShowHidden() && self.isUnixHiddenFile()
                                    return 1
                                endif
                            
   49   0.000825   0.000591     if a:nerdtree.ui.getShowFiles() ==# 0 && self.isDirectory ==# 0
                                    return 1
                                endif
                            
   49              0.000108     return 0

FUNCTION  gitgutter#utility#cd_cmd()
Called 2 times
Total time:   0.001234
 Self time:   0.000096

count  total (s)   self (s)
    2   0.000701   0.000059   let cd = s:unc_path(a:bufnr) ? 'pushd' : (gitgutter#utility#windows() ? 'cd /d' : 'cd')
    2   0.000530   0.000034   return cd.' '.s:dir(a:bufnr).' && '.a:cmd

FUNCTION  <SNR>150_parseJSON()
Called 1 time
Total time:   0.000285
 Self time:   0.000285

count  total (s)   self (s)
    1              0.000003     try
    1              0.000062         let l:parsed = json_decode(a:lines[-1])
    1              0.000003     catch
                                    return []
                                endtry
                            
    1              0.000009     if type(l:parsed) != v:t_list || empty(l:parsed)
                                    return []
                                endif
                            
    1              0.000007     let l:errors = l:parsed[0]['messages']
                            
    1              0.000004     if empty(l:errors)
                                    return []
                                endif
                            
    1              0.000003     let l:output = []
                            
    2              0.000007     for l:error in l:errors
    1              0.000016         let l:obj = ({   'lnum': get(l:error, 'line', 0),   'text': get(l:error, 'message', ''),   'type': 'E',})
                            
    1              0.000006         if get(l:error, 'severity', 0) is# 1
                                        let l:obj.type = 'W'
                                    endif
                            
    1              0.000005         if has_key(l:error, 'ruleId')
    1              0.000005             let l:code = l:error['ruleId']
                            
                                        " Sometimes ESLint returns null here
    1              0.000005             if !empty(l:code)
                                            let l:obj.code = l:code
                                        endif
    1              0.000001         endif
                            
    1              0.000005         if has_key(l:error, 'column')
    1              0.000006             let l:obj.col = l:error['column']
    1              0.000002         endif
                            
    1              0.000006         if has_key(l:error, 'endColumn')
                                        let l:obj.end_col = l:error['endColumn'] - 1
                                    endif
                            
    1              0.000005         if has_key(l:error, 'endLine')
                                        let l:obj.end_lnum = l:error['endLine']
                                    endif
                            
    1              0.000006         call add(l:output, l:obj)
    1              0.000002     endfor
                            
    1              0.000003     return l:output

FUNCTION  airline#util#ignore_buf()
Called 639 times
Total time:   0.032848
 Self time:   0.032848

count  total (s)   self (s)
  639              0.009798   let pat = '\c\v'. get(g:, 'airline#ignore_bufadd_pat', ''). get(g:, 'airline#extensions#tabline#ignore_bufadd_pat',  'gundo|undotree|vimfiler|tagbar|nerd_tree|startify|!')
  639              0.021937   return match(a:name, pat) > -1

FUNCTION  115()
Called 13 times
Total time:   0.001054
 Self time:   0.000340

count  total (s)   self (s)
   13   0.001042   0.000328     return self.path.flagSet.renderToString() . self.path.displayString()

FUNCTION  117()
Called 3 times
Total time:   0.001623
 Self time:   0.000056

count  total (s)   self (s)
    3   0.001606   0.000039     if a:path.equals(self.path)
    1              0.000003         return self
                                endif
    2              0.000004     return {}

FUNCTION  119()
Called 52 times
Total time:   0.000226
 Self time:   0.000226

count  total (s)   self (s)
   52              0.000177     return self._nerdtree

FUNCTION  <SNR>172_RunJob()
Called 3 times
Total time:   0.012860
 Self time:   0.000430

count  total (s)   self (s)
    3   0.000082   0.000050     if ale#command#IsDeferred(a:result)
    1              0.000018         let a:result.result_callback = {x -> s:RunJob(x, a:options)}
                            
    1              0.000002         return
                                endif
                            
    2              0.000008     let l:buffer = a:options.buffer
    2              0.000006     let l:input = a:options.input
                            
    2              0.000009     if a:result is 0 || type(a:result) is v:t_list
                                    if type(a:result) is v:t_list
                                        let l:input = a:result
                                    endif
                            
                                    call s:RunFixer({   'buffer': l:buffer,   'input': l:input,   'callback_index': a:options.callback_index + 1,   'callback_list': a:options.callback_list,})
                            
                                    return
                                endif
                            
    2              0.000012     let l:command = get(a:result, 'command', '')
    2              0.000011     let l:ChainWith = get(a:result, 'chain_with', v:null)
                            
    2              0.000007     if empty(l:command)
                                    " If the command is empty, skip to the next item, or call the
                                    " chain_with function.
                                    call s:RunFixer({   'buffer': l:buffer,   'input': l:input,   'callback_index': a:options.callback_index + (l:ChainWith is v:null),   'callback_list': a:options.callback_list,   'chain_callback': l:ChainWith,   'output': [],})
                            
                                    return
                                endif
                            
    2              0.000012     let l:read_temporary_file = get(a:result, 'read_temporary_file', 0)
                                " Default to piping the buffer for the last fixer in the chain.
    2              0.000012     let l:read_buffer = get(a:result, 'read_buffer', l:ChainWith is v:null)
    2              0.000010     let l:output_stream = get(a:result, 'output_stream', 'stdout')
                            
    2              0.000005     if l:read_temporary_file
    1              0.000002         let l:output_stream = 'none'
    1              0.000001     endif
                            
    2              0.000037     let l:Callback = function('s:HandleExit', [{   'input': l:input,   'chain_with': l:ChainWith,   'callback_index': a:options.callback_index,   'callback_list': a:options.callback_list,   'process_with': get(a:result, 'process_with', v:null),   'read_temporary_file': l:read_temporary_file,}])
    2   0.012487   0.000089     let l:run_result = ale#command#Run(l:buffer, l:command, l:Callback, {   'output_stream': l:output_stream,   'executable': '',   'read_buffer': l:read_buffer,   'input': l:input,   'log_output': 0,})
                            
    2              0.000011     if empty(l:run_result)
                                    call s:RunFixer({   'buffer': l:buffer,   'input': l:input,   'callback_index': a:options.callback_index + 1,   'callback_list': a:options.callback_list,})
                                endif

FUNCTION  <SNR>107_get_transitioned_seperator()
Called 41 times
Total time:   0.056391
 Self time:   0.002887

count  total (s)   self (s)
   41              0.000141   let line = ''
   41              0.000357   if get(a:self._context, 'tabline', 0) && get(g:, 'airline#extensions#tabline#alt_sep', 0) && a:group ==# 'airline_tabsel' && a:side
                                call airline#highlighter#add_separator(a:prev_group, a:group, 0)
                                let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
                                let line .=  a:self._context.right_sep.'%#'.a:group.'#'
                              else
   41   0.054077   0.000574     call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
   41              0.000408     let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
   41              0.000316     let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
   41              0.000233     let line .= '%#'.a:group.'#'
   41              0.000055   endif
   41              0.000118   return line

FUNCTION  <SNR>148_RunIfExecutable()
Called 8 times
Total time:   0.016121
 Self time:   0.000982

count  total (s)   self (s)
    8   0.000202   0.000123     if ale#command#IsDeferred(a:executable)
                                    let a:executable.result_callback = {   executable -> s:RunIfExecutable(a:buffer, a:linter, executable)}
                            
                                    return 1
                                endif
                            
    8   0.001910   0.000133     if ale#engine#IsExecutable(a:buffer, a:executable)
                                    " Use different job types for file or linter jobs.
    2              0.000013         let l:job_type = a:linter.lint_file ? 'file_linter' : 'linter'
    2              0.000021         call setbufvar(a:buffer, 'ale_job_type', l:job_type)
                            
    2              0.000012         if has_key(a:linter, 'command_chain')
                                        let [l:command, l:options] = ale#engine#ProcessChain(   a:buffer,   a:executable,   a:linter,   0,   [])
                            
                                        return s:RunJob(l:command, l:options)
                                    endif
                            
    2   0.002278   0.000039         let l:command = ale#linter#GetCommand(a:buffer, a:linter)
    2              0.000029         let l:options = {   'executable': a:executable,   'buffer': a:buffer,   'linter': a:linter,   'output_stream': get(a:linter, 'output_stream', 'stdout'),   'next_chain_index': 1,   'read_buffer': a:linter.read_buffer,}
                            
    2   0.011153   0.000108         return s:RunJob(l:command, l:options)
                                endif
                            
    6              0.000012     return 0

FUNCTION  ale#engine#MarkLinterActive()
Called 4 times
Total time:   0.000193
 Self time:   0.000193

count  total (s)   self (s)
    4              0.000021     let l:found = 0
                            
    6              0.000031     for l:other_linter in a:info.active_linter_list
    2              0.000009         if l:other_linter.name is# a:linter.name
                                        let l:found = 1
                                        break
                                    endif
    2              0.000003     endfor
                            
    4              0.000009     if !l:found
    4              0.000024         call add(a:info.active_linter_list, a:linter)
    4              0.000010     endif

FUNCTION  ale#handlers#eslint#FindConfig()
Called 1 time
Total time:   0.001078
 Self time:   0.000543

count  total (s)   self (s)
    2   0.000500   0.000160     for l:path in ale#path#Upwards(expand('#' . a:buffer . ':p:h'))
   10              0.000025         for l:basename in [   '.eslintrc.js',   '.eslintrc.yaml',   '.eslintrc.yml',   '.eslintrc.json',   '.eslintrc',]
    9   0.000323   0.000128             let l:config = ale#path#Simplify(join([l:path, l:basename], s:sep))
                            
    9              0.000168             if filereadable(l:config)
    1              0.000003                 return l:config
                                        endif
    8              0.000009         endfor
    1              0.000001     endfor
                            
                                return ale#path#FindNearestFile(a:buffer, 'package.json')

FUNCTION  airline#util#doautocmd()
Called 14 times
Total time:   0.002968
 Self time:   0.001285

count  total (s)   self (s)
   14   0.002939   0.001256   exe printf("silent doautocmd %s User %s", s:nomodeline, a:event)

FUNCTION  307()
Called 3 times
Total time:   0.000250
 Self time:   0.000117

count  total (s)   self (s)
    3              0.000015     let bufnum = get(self.buffers, a:i, -1)
    3              0.000006     if bufnum == -1
                                  return ''
                                endif
    3   0.000180   0.000047     let group = airline#extensions#tabline#group_of_bufnr(self.tab_bufs, bufnum)
    3              0.000012     if bufnum == bufnr('%')
    3              0.000016       let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
    3              0.000004     endif
    3              0.000005     return group

FUNCTION  30()
Called 49 times
Total time:   0.004803
 Self time:   0.003508

count  total (s)   self (s)
   49              0.000213     let pat = a:pattern
   49              0.000455     if strpart(pat,len(pat)-7) == '[[dir]]'
                                    if !self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-7)
                                elseif strpart(pat,len(pat)-8) == '[[file]]'
                                    if self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-8)
                                endif
                            
   49   0.002438   0.001143     return self.getLastPathComponent(0) =~# pat

FUNCTION  34()
Called 11 times
Total time:   0.005912
 Self time:   0.000469

count  total (s)   self (s)
   11   0.000276   0.000108     if nerdtree#runningWindows()
                                    return self.str() ==? a:path.str()
                                else
   11   0.005546   0.000271         return self.str() ==# a:path.str()
                                endif

FUNCTION  35()
Called 1 time
Total time:   0.000993
 Self time:   0.000182

count  total (s)   self (s)
    1              0.000093     let l:newPath = copy(self)
                            
    1   0.000834   0.000044     call l:newPath.readInfoFromDisk(s:Path.AbsolutePathFor(a:pathStr))
                            
    1              0.000005     let l:newPath.cachedDisplayString = ''
    1   0.000052   0.000031     let l:newPath.flagSet = g:NERDTreeFlagSet.New()
                            
    1              0.000003     return l:newPath

FUNCTION  36()
Called 62 times
Total time:   0.002587
 Self time:   0.001581

count  total (s)   self (s)
                            
   62   0.001650   0.000644     if nerdtree#runningWindows()
                                    if exists('+shellslash') && &shellslash
                                        return '/'
                                    endif
                            
                                    return '\'
                                endif
                            
   62              0.000100     return '/'

FUNCTION  37()
Called 2 times
Total time:   0.000138
 Self time:   0.000138

count  total (s)   self (s)
    2              0.000074     let tmp = resolve(a:path)
    2              0.000061     return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp

FUNCTION  38()
Called 1 time
Total time:   0.000682
 Self time:   0.000410

count  total (s)   self (s)
    1   0.000081   0.000018     call self.extractDriveLetter(a:fullpath)
                            
    1   0.000053   0.000020     let fullpath = s:Path.WinToUnixPath(a:fullpath)
                            
    1              0.000025     if getftype(fullpath) ==# "fifo"
                                    throw "NERDTree.InvalidFiletypeError: Cant handle FIFO files: " . a:fullpath
                                endif
                            
    1              0.000049     let self.pathSegments = filter(split(fullpath, '/'), '!empty(v:val)')
                            
    1              0.000006     let self.isReadOnly = 0
    1              0.000020     if isdirectory(a:fullpath)
                                    let self.isDirectory = 1
                                elseif filereadable(a:fullpath)
    1              0.000005         let self.isDirectory = 0
    1              0.000052         let self.isReadOnly = filewritable(a:fullpath) ==# 0
    1              0.000003     else
                                    throw "NERDTree.InvalidArgumentsError: Invalid path = " . a:fullpath
                                endif
                            
    1              0.000004     let self.isExecutable = 0
    1              0.000003     if !self.isDirectory
    1              0.000023         let self.isExecutable = getfperm(a:fullpath) =~# 'x'
    1              0.000002     endif
                            
                                "grab the last part of the path (minus the trailing slash)
    1   0.000038   0.000019     let lastPathComponent = self.getLastPathComponent(0)
                            
                                "get the path to the new node with the parent dir fully resolved
    1   0.000088   0.000021     let hardPath = s:Path.Resolve(self.strTrunk()) . '/' . lastPathComponent
                            
                                "if  the last part of the path is a symlink then flag it as such
    1   0.000133   0.000042     let self.isSymLink = (s:Path.Resolve(hardPath) != hardPath)
    1              0.000004     if self.isSymLink
                                    let self.symLinkDest = s:Path.Resolve(fullpath)
                            
                                    "if the link is a dir then slap a / on the end of its dest
                                    if isdirectory(self.symLinkDest)
                            
                                        "we always wanna treat MS windows shortcuts as files for
                                        "simplicity
                                        if hardPath !~# '\.lnk$'
                            
                                            let self.symLinkDest = self.symLinkDest . '/'
                                        endif
                                    endif
                                endif

FUNCTION  <SNR>119_OnBlankLine()
Called 421 times
Total time:   0.333282
 Self time:   0.006250

count  total (s)   self (s)
  421   0.332769   0.005737   return s:Pyeval( 'not vim.current.line or vim.current.line.isspace()' )

FUNCTION  <SNR>39_NERDTreeGetIndicator()
Called 3 times
Total time:   0.000121
 Self time:   0.000121

count  total (s)   self (s)
    3              0.000024     if exists('g:NERDTreeIndicatorMapCustom')
                                    let l:indicator = get(g:NERDTreeIndicatorMapCustom, a:statusKey, '')
                                    if l:indicator !=# ''
                                        return l:indicator
                                    endif
                                endif
    3              0.000030     let l:indicator = get(s:NERDTreeIndicatorMap, a:statusKey, '')
    3              0.000011     if l:indicator !=# ''
    2              0.000005         return l:indicator
                                endif
    1              0.000001     return ''

FUNCTION  <SNR>129_OneScope()
Called 1 time
Total time:   0.000261
 Self time:   0.000077

count  total (s)   self (s)
    1   0.000158   0.000012   let pline = s:Trim(a:lnum)
    1              0.000003   let kw = 'else do'
    1              0.000008   if pline[-1:] == ')' && s:GetPair('(', ')', 'bW', s:skip_expr, 100) > 0
                            	call s:previous_token()
                            	let kw = 'for if let while with'
                            	if index(split('await each'),s:token()) + 1
                            	  call s:previous_token()
                            	  let kw = 'for'
                            	endif
                              endif
    1   0.000069   0.000031   return pline[-2:] == '=>' || index(split(kw),s:token()) + 1 && s:save_pos('s:previous_token') != '.'

FUNCTION  <SNR>119_DisableOnLargeFile()
Called 865 times
Total time:   0.009828
 Self time:   0.009828

count  total (s)   self (s)
  865              0.005704   if exists( 'b:ycm_largefile' )
  865              0.002653     return b:ycm_largefile
                              endif
                            
                              let threshold = g:ycm_disable_for_files_larger_than_kb * 1024
                              let b:ycm_largefile = threshold > 0 && getfsize( expand( a:buffer ) ) > threshold
                              if b:ycm_largefile
                                exec s:python_command "vimsupport.PostVimMessage(" . "'YouCompleteMe is disabled in this buffer; " . "the file exceeded the max size (see YCM options).' )"
                              endif
                              return b:ycm_largefile

FUNCTION  ale#util#Writefile()
Called 4 times
Total time:   0.001421
 Self time:   0.001421

count  total (s)   self (s)
    4              0.000052     let l:corrected_lines = getbufvar(a:buffer, '&fileformat') is# 'dos'   ? map(copy(a:lines), 'substitute(v:val, ''\r*$'', ''\r'', '''')')   : a:lines
                            
    4              0.001360     call writefile(l:corrected_lines, a:filename, 'S') " no-custom-checks

FUNCTION  gitgutter#async#available()
Called 2 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    2              0.000007   return s:available

FUNCTION  airline#builder#get_prev_group()
Called 64 times
Total time:   0.001620
 Self time:   0.001620

count  total (s)   self (s)
   64              0.000287   let x = a:i - 1
   72              0.000213   while x >= 0
   60              0.000287     let group = a:sections[x][0]
   60              0.000280     if group != '' && group != '|'
   52              0.000129       return group
                                endif
    8              0.000022     let x = x - 1
    8              0.000012   endwhile
   12              0.000021   return ''

FUNCTION  <SNR>166_prev_line()
Called 1 time
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    1              0.000006   let lnum = prevnonblank(a:lnum - 1)
    1              0.000019   return substitute(getline(lnum), '^\s*\|\s*$', '', 'g')

FUNCTION  <SNR>157_CreateTSServerMessageData()
Called 4 times
Total time:   0.000579
 Self time:   0.000579

count  total (s)   self (s)
    4              0.000023     let l:is_notification = a:message[0]
                            
    4              0.000050     let l:obj = {   'seq': v:null,   'type': 'request',   'command': a:message[1][3:],}
                            
    4              0.000013     if !l:is_notification
                                    let l:obj.seq = ale#lsp#GetNextMessageID()
                                endif
                            
    4              0.000019     if len(a:message) > 2
    4              0.000022         let l:obj.arguments = a:message[2]
    4              0.000006     endif
                            
    4              0.000324     let l:data = json_encode(l:obj) . "\n"
                            
    4              0.000035     return [l:is_notification ? 0 : l:obj.seq, l:data]

FUNCTION  40()
Called 3 times
Total time:   0.066772
 Self time:   0.000182

count  total (s)   self (s)
    3   0.066205   0.000107     call g:NERDTreePathNotifier.NotifyListeners('refreshFlags', self, a:nerdtree, {})
    3   0.000562   0.000071     call self.cacheDisplayString()

FUNCTION  42()
Called 60 times
Total time:   0.014192
 Self time:   0.007361

count  total (s)   self (s)
   60              0.000358     let options = a:0 ? a:1 : {}
   60              0.000185     let toReturn = ""
                            
   60              0.000324     if has_key(options, 'format')
    1              0.000005         let format = options['format']
    1              0.000006         if has_key(self, '_strFor' . format)
    1   0.000059   0.000026             exec 'let toReturn = self._strFor' . format . '()'
    1              0.000002         else
                                        throw 'NERDTree.UnknownFormatError: unknown format "'. format .'"'
                                    endif
    1              0.000001     else
   59   0.007095   0.000808         let toReturn = self._str()
   59              0.000102     endif
                            
   60   0.001220   0.000710     if nerdtree#has_opt(options, 'escape')
                                    let toReturn = shellescape(toReturn)
                                endif
                            
   60              0.000257     if has_key(options, 'truncateTo')
    1              0.000004         let limit = options['truncateTo']
    1              0.000006         if strdisplaywidth(toReturn) > limit-1
   14              0.000140             while strdisplaywidth(toReturn) > limit-1 && strchars(toReturn) > 0
   13              0.000172                 let toReturn = substitute(toReturn, '^.', '', '')
   13              0.000022             endwhile
    1              0.000016             if len(split(toReturn, '/')) > 1
    1              0.000023                 let toReturn = '</' . join(split(toReturn, '/')[1:], '/') . '/'
    1              0.000002             else
                                            let toReturn = '<' . toReturn
                                        endif
    1              0.000001         endif
    1              0.000001     endif
                            
   60              0.000164     return toReturn

FUNCTION  43()
Called 1 time
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
    1              0.000018     let toReturn = '/' . join(self.pathSegments, '/')
    1              0.000005     if self.isDirectory && toReturn != '/'
    1              0.000004         let toReturn  = toReturn . '/'
    1              0.000001     endif
    1              0.000003     return toReturn

FUNCTION  47()
Called 59 times
Total time:   0.006287
 Self time:   0.002981

count  total (s)   self (s)
   59   0.003251   0.000806     let l:separator = s:Path.Slash()
   59              0.000240     let l:leader = l:separator
                            
   59   0.001403   0.000542     if nerdtree#runningWindows()
                                    let l:leader = self.drive . l:separator
                                endif
                            
   59              0.000898     return l:leader . join(self.pathSegments, l:separator)

FUNCTION  48()
Called 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000019     return self.drive . '/' . join(self.pathSegments[0:-2], '/')

FUNCTION  ale#lsp_linter#GetOptions()
Called 2 times
Total time:   0.000093
 Self time:   0.000093

count  total (s)   self (s)
    2              0.000016     if has_key(a:linter, 'initialization_options_callback')
                                    return ale#util#GetFunction(a:linter.initialization_options_callback)(a:buffer)
                                endif
                            
    2              0.000011     if has_key(a:linter, 'initialization_options')
                                    let l:Options = a:linter.initialization_options
                            
                                    if type(l:Options) is v:t_func
                                        let l:Options = l:Options(a:buffer)
                                    endif
                            
                                    return l:Options
                                endif
                            
    2              0.000004     return {}

FUNCTION  ale#lsp#Register()
Called 2 times
Total time:   0.000104
 Self time:   0.000104

count  total (s)   self (s)
    2              0.000023     let l:conn_id = a:executable_or_address . ':' . a:project
                            
    2              0.000022     if !has_key(s:connections, l:conn_id)
                                    " is_tsserver: 1 if the connection is for tsserver.
                                    " data: The message data received so far.
                                    " root: The project root.
                                    " open_documents: A Dictionary mapping buffers to b:changedtick, keeping
                                    "   track of when documents were opened, and when we last changed them.
                                    " initialized: 0 if the connection is ready, 1 otherwise.
                                    " init_request_id: The ID for the init request.
                                    " init_options: Options to send to the server.
                                    " config: Configuration settings to send to the server.
                                    " callback_list: A list of callbacks for handling LSP responses.
                                    " capabilities_queue: The list of callbacks to call with capabilities.
                                    " capabilities: Features the server supports.
                                    let s:connections[l:conn_id] = {   'id': l:conn_id,   'is_tsserver': 0,   'data': '',   'root': a:project,   'open_documents': {},   'initialized': 0,   'init_request_id': 0,   'init_options': a:init_options,   'config': {},   'callback_list': [],   'init_queue': [],   'capabilities': {       'hover': 0,       'references': 0,       'completion': 0,       'completion_trigger_characters': [],       'definition': 0,       'typeDefinition': 0,       'symbol_search': 0,   },}
                                endif
                            
    2              0.000006     return l:conn_id

FUNCTION  131()
Called 1 time
Total time:   0.064174
 Self time:   0.000043

count  total (s)   self (s)
    1   0.064173   0.000042     call self.path.refreshFlags(self.getNerdtree())

FUNCTION  133()
Called 1 time
Total time:   0.020649
 Self time:   0.000026

count  total (s)   self (s)
    1   0.020647   0.000025     return self._renderToString(0, 0)

FUNCTION  134()
Called 22 times
Total time:   0.034525
 Self time:   0.030588

count  total (s)   self (s)
   22              0.000092     let output = ""
   22              0.000066     if a:drawText ==# 1
                            
   21              0.000141         let treeParts = repeat('  ', a:depth - 1)
                            
   21              0.000070         if !self.path.isDirectory
   13              0.000056             let treeParts = treeParts . '  '
   13              0.000019         endif
                            
   21   0.006135   0.000364         let line = treeParts . self.displayString()
                            
   21              0.000125         let output = output . line . "\n"
   21              0.000030     endif
                            
                                " if the node is an open dir, draw its children
   22              0.000088     if self.path.isDirectory ==# 1 && self.isOpen ==# 1
                            
    2   0.006047   0.000045         let childNodesToDraw = self.getVisibleChildren()
                            
    2   0.006144   0.000060         if self.isCascadable() && a:depth > 0
                            
                                        let output = output . childNodesToDraw[0]._renderToString(a:depth, 0)
                            
                                    elseif len(childNodesToDraw) > 0
   23              0.000100             for i in childNodesToDraw
   21              0.000300                 let output = output . i._renderToString(a:depth + 1, 1)
   21              0.000042             endfor
    2              0.000003         endif
    2              0.000002     endif
                            
   22              0.000063     return output

FUNCTION  airline#extensions#tabline#get_buffer_name()
Called 15 times
Total time:   0.004528
 Self time:   0.000563

count  total (s)   self (s)
   15   0.000342   0.000203   let buffers = a:0 ? a:1 : airline#extensions#tabline#buflist#list()
   15              0.000095   let formatter = get(g:, 'airline#extensions#tabline#formatter', 'default')
   15   0.004067   0.000241   return airline#extensions#tabline#formatters#{formatter}#format(a:nr, buffers)

FUNCTION  <lambda>16()
Called 1 time
Total time:   0.002788
 Self time:   0.000053

count  total (s)   self (s)
    1   0.002787   0.000052 return a:Callback(a:buffer, s:GetVersion(a:executable, output))

FUNCTION  <SNR>61_Compile()
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
                            
    1              0.000012     if !exists('b:livepreview_buf_data') || has_key(b:livepreview_buf_data, 'preview_running') == 0
    1              0.000003         return
                                endif
                            
                                " Change directory to handle properly sourced files with \input and bib
                                " TODO: get rid of lcd
                                execute 'lcd ' . b:livepreview_buf_data['root_dir']
                            
                                " Write the current buffer in a temporary file
                                silent exec 'write! ' . b:livepreview_buf_data['tmp_src_file']
                            
                                call s:RunInBackground(b:livepreview_buf_data['run_cmd'])
                            
                                lcd -

FUNCTION  50()
Called 1 time
Total time:   0.000033
 Self time:   0.000016

count  total (s)   self (s)
    1   0.000028   0.000011     if !nerdtree#runningWindows()
    1              0.000004         return a:pathstr
                                endif
                            
                                let toReturn = a:pathstr
                            
                                "remove the x:\ of the front
                                let toReturn = substitute(toReturn, '^.*:\(\\\|/\)\?', '/', "")
                            
                                "remove the \\ network share from the front
                                let toReturn = substitute(toReturn, '^\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\(\\\|\/\)\?', '/', "")
                            
                                "convert all \ chars to /
                                let toReturn = substitute(toReturn, '\', '/', "g")
                            
                                return toReturn

FUNCTION  ale#GetLocItemMessage()
Called 22 times
Total time:   0.003556
 Self time:   0.003556

count  total (s)   self (s)
   22              0.000110     let l:msg = a:format_string
   22              0.000100     let l:severity = g:ale_echo_msg_warning_str
   22              0.000159     let l:code = get(a:item, 'code', '')
   22              0.000140     let l:type = get(a:item, 'type', 'E')
   22              0.000154     let l:linter_name = get(a:item, 'linter_name', '')
   22              0.000170     let l:code_repl = !empty(l:code) ? '\=submatch(1) . l:code . submatch(2)' : ''
                            
   22              0.000077     if l:type is# 'E'
   22              0.000111         let l:severity = g:ale_echo_msg_error_str
   22              0.000054     elseif l:type is# 'I'
                                    let l:severity = g:ale_echo_msg_info_str
                                endif
                            
                                " Replace special markers with certain information.
                                " \=l:variable is used to avoid escaping issues.
   22              0.000374     let l:msg = substitute(l:msg, '\V%severity%', '\=l:severity', 'g')
   22              0.000304     let l:msg = substitute(l:msg, '\V%linter%', '\=l:linter_name', 'g')
   22              0.000944     let l:msg = substitute(l:msg, '\v\%([^\%]*)code([^\%]*)\%', l:code_repl, 'g')
                                " Replace %s with the text.
   22              0.000445     let l:msg = substitute(l:msg, '\V%s', '\=a:item.text', 'g')
                            
   22              0.000075     return l:msg

FUNCTION  <SNR>163_reset_summary()
Called 2 times
Total time:   0.000106
 Self time:   0.000027

count  total (s)   self (s)
    2   0.000105   0.000026   call gitgutter#utility#setbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  ale_linters#typescript#xo#GetExecutable()
Called 2 times
Total time:   0.001535
 Self time:   0.000038

count  total (s)   self (s)
    2   0.001533   0.000036     return ale#node#FindExecutable(a:buffer, 'typescript_xo', [   'node_modules/.bin/xo',])

FUNCTION  <SNR>164_process_modified_and_removed()
Called 2 times
Total time:   0.000081
 Self time:   0.000081

count  total (s)   self (s)
    2              0.000006   let offset = 0
    4              0.000011   while offset < a:to_count
    2              0.000007     let line_number = a:to_line + offset
    2              0.000012     call add(a:modifications, [line_number, 'modified'])
    2              0.000006     let offset += 1
    2              0.000003   endwhile
    2              0.000013   let a:modifications[-1] = [a:to_line + offset - 1, 'modified_removed']

FUNCTION  <SNR>138_on_exit_nvim()
Called 2 times
Total time:   0.012535
 Self time:   0.000091

count  total (s)   self (s)
    2              0.000010   if !a:exit_code
    2   0.012518   0.000074     call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
    2              0.000003   endif

FUNCTION  141()
Called 8 times
Total time:   0.004716
 Self time:   0.001007

count  total (s)   self (s)
    8              0.000033     let l:result = ''
                            
                                " Build a label that identifies this TreeDirNode.
    8              0.000026     let l:label = ''
    8   0.003226   0.000116     let l:cascade = self.getCascade()
   16              0.000056     for l:dirNode in l:cascade
    8   0.000340   0.000121         let l:next = l:dirNode.path.displayString()
    8              0.000107         let l:label .= l:label == '' ? l:next : substitute(l:next,'^.','','')
    8              0.000016     endfor
                            
                                " Select the appropriate open/closed status indicator symbol.
    8              0.000031     if l:cascade[-1].isOpen
    1              0.000005         let l:symbol = g:NERDTreeDirArrowCollapsible
    1              0.000002     else
    7              0.000032         let l:symbol = g:NERDTreeDirArrowExpandable
    7              0.000010     endif
                            
    8   0.000510   0.000129     let l:flags = l:cascade[-1].path.flagSet.renderToString()
                            
    8              0.000091     let l:result = l:symbol . ' ' . l:flags . l:label
    8              0.000023     return l:result

FUNCTION  142()
Called 8 times
Total time:   0.023003
 Self time:   0.003637

count  total (s)   self (s)
    8   0.004476   0.000130     if a:path.equals(self.path)
                                    return self
                                endif
    8   0.004001   0.000236     if stridx(a:path.str(), self.path.str(), 0) ==# -1
    6              0.000017         return {}
                                endif
                            
    2              0.000007     if self.path.isDirectory
   10              0.000107         for i in self.children
   10   0.001760   0.000137             let retVal = i.findNode(a:path)
   10              0.000039             if retVal != {}
    2              0.000005                 return retVal
                                        endif
    8              0.000012         endfor
                                endif
                                return {}

FUNCTION  <SNR>164_process_hunk()
Called 10 times
Total time:   0.003415
 Self time:   0.001315

count  total (s)   self (s)
   10              0.000035   let modifications = []
   10              0.000036   let from_line  = a:hunk[0]
   10              0.000031   let from_count = a:hunk[1]
   10              0.000028   let to_line    = a:hunk[2]
   10              0.000028   let to_count   = a:hunk[3]
                            
   10   0.000301   0.000097   if s:is_added(from_count, to_count)
    8   0.000580   0.000111     call s:process_added(modifications, from_count, to_count, to_line)
    8   0.001039   0.000095     call gitgutter#hunk#increment_lines_added(a:bufnr, to_count)
                            
    8              0.000039   elseif s:is_removed(from_count, to_count)
                                call s:process_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count)
                            
                              elseif s:is_modified(from_count, to_count)
                                call s:process_modified(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                            
                              elseif s:is_modified_and_added(from_count, to_count)
                                call s:process_modified_and_added(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_added(a:bufnr, to_count - from_count)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, from_count)
                            
                              elseif s:is_modified_and_removed(from_count, to_count)
    2   0.000112   0.000030     call s:process_modified_and_removed(modifications, from_count, to_count, to_line)
    2   0.000213   0.000026     call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
    2   0.000202   0.000026     call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count - to_count)
                            
    2              0.000002   endif
   10              0.000022   return modifications

FUNCTION  <lambda>19()
Called 1 time
Total time:   0.020425
 Self time:   0.000059

count  total (s)   self (s)
    1   0.020423   0.000057 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  ale#node#FindExecutable()
Called 13 times
Total time:   0.011281
 Self time:   0.001172

count  total (s)   self (s)
   13   0.000624   0.000221     if ale#Var(a:buffer, a:base_var_name . '_use_global')
                                    return ale#Var(a:buffer, a:base_var_name . '_executable')
                                endif
                            
   24              0.000104     for l:path in a:path_list
   19   0.009909   0.000354         let l:executable = ale#path#FindNearestFile(a:buffer, l:path)
                            
   19              0.000098         if !empty(l:executable)
    8              0.000022             return l:executable
                                    endif
   11              0.000016     endfor
                            
    5   0.000230   0.000080     return ale#Var(a:buffer, a:base_var_name . '_executable')

FUNCTION  <SNR>164_is_modified_and_added()
Called 2 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    2              0.000009   return a:from_count > 0 && a:to_count > 0 && a:from_count < a:to_count

FUNCTION  <lambda>18()
Called 1 time
Total time:   0.004976
 Self time:   0.000061

count  total (s)   self (s)
    1   0.004973   0.000058 return s:RunJob(x, a:options)

FUNCTION  ale#engine#InitBufferInfo()
Called 2 times
Total time:   0.000047
 Self time:   0.000047

count  total (s)   self (s)
    2              0.000016     if !has_key(g:ale_buffer_info, a:buffer)
                                    " active_linter_list will hold the list of active linter names
                                    " loclist holds the loclist items after all jobs have completed.
                                    let g:ale_buffer_info[a:buffer] = {   'active_linter_list': [],   'active_other_sources_list': [],   'loclist': [],}
                            
                                    return 1
                                endif
                            
    2              0.000003     return 0

FUNCTION  airline#extensions#tabline#new_builder()
Called 1 time
Total time:   0.000239
 Self time:   0.000110

count  total (s)   self (s)
    1              0.000025   let builder_context = { 'active'        : 1, 'tabline'       : 1, 'right_sep'     : get(g:, 'airline#extensions#tabline#right_sep'    , g:airline_right_sep), 'right_alt_sep' : get(g:, 'airline#extensions#tabline#right_alt_sep', g:airline_right_alt_sep), }
    1              0.000005   if get(g:, 'airline_powerline_fonts', 0)
                                let builder_context.left_sep     = get(g:, 'airline#extensions#tabline#left_sep'     , g:airline_left_sep)
                                let builder_context.left_alt_sep = get(g:, 'airline#extensions#tabline#left_alt_sep' , g:airline_left_alt_sep)
                              else
    1              0.000010     let builder_context.left_sep     = get(g:, 'airline#extensions#tabline#left_sep'     , ' ')
    1              0.000008     let builder_context.left_alt_sep = get(g:, 'airline#extensions#tabline#left_alt_sep' , '|')
    1              0.000002   endif
                            
    1   0.000174   0.000044   return airline#extensions#tabline#builder#new(builder_context)

FUNCTION  airline#extensions#tabline#add_label()
Called 1 time
Total time:   0.000113
 Self time:   0.000039

count  total (s)   self (s)
    1              0.000008   if get(g:, 'airline#extensions#tabline#show_tab_type', 1)
    1   0.000101   0.000027     call a:dict.add_section_spaced('airline_tablabel'. (a:right ? '_right' : ''), get(g:, 'airline#extensions#tabline#'.a:type.'_label', a:type))
    1              0.000002   endif

FUNCTION  <SNR>172_RunFixer()
Called 3 times
Total time:   0.048882
 Self time:   0.000485

count  total (s)   self (s)
    3              0.000019     let l:buffer = a:options.buffer
    3              0.000012     let l:input = a:options.input
    3              0.000012     let l:index = a:options.callback_index
                            
    3              0.000018     if len(a:options.callback_list) <= l:index
    1   0.019582   0.000029         call ale#fix#ApplyFixes(l:buffer, l:input)
                            
    1              0.000002         return
                                endif
                            
    2              0.000017     let l:ChainCallback = get(a:options, 'chain_callback', v:null)
                            
    2              0.000026     let l:Function = l:ChainCallback isnot v:null   ? ale#util#GetFunction(l:ChainCallback)   : a:options.callback_list[l:index]
                            
                                " Record new jobs started as fixer jobs.
    2              0.000019     call setbufvar(l:buffer, 'ale_job_type', 'fixer')
                            
    2              0.000007     if l:ChainCallback isnot v:null
                                    " Chained commands accept (buffer, output, [input])
                                    let l:result = ale#util#FunctionArgCount(l:Function) == 2   ? call(l:Function, [l:buffer, a:options.output])   : call(l:Function, [l:buffer, a:options.output, copy(l:input)])
                                else
                                    " Regular fixer commands accept (buffer, [input])
    2   0.021026   0.000127         let l:result = ale#util#FunctionArgCount(l:Function) == 1   ? call(l:Function, [l:buffer])   : call(l:Function, [l:buffer, copy(l:input)])
    2              0.000003     endif
                            
    2   0.008037   0.000092     call s:RunJob(l:result, {   'buffer': l:buffer,   'input': l:input,   'callback_list': a:options.callback_list,   'callback_index': l:index,})

FUNCTION  153()
Called 12 times
Total time:   0.014211
 Self time:   0.002208

count  total (s)   self (s)
   12              0.000054     let toReturn = []
   61              0.000247     for i in self.children
   49   0.013184   0.001180         if i.path.ignore(self.getNerdtree()) ==# 0
   49              0.000329             call add(toReturn, i)
   49              0.000076         endif
   49              0.000077     endfor
   12              0.000031     return toReturn

FUNCTION  155()
Called 10 times
Total time:   0.009043
 Self time:   0.000678

count  total (s)   self (s)
   10              0.000050     if g:NERDTreeCascadeSingleChildDir == 0
                                    return 0
                                endif
                            
   10              0.000031     if self.path.isSymLink
                                    return 0
                                endif
                            
   10   0.000310   0.000155     for i in g:NERDTreeBookmark.Bookmarks()
                                    if i.path.equals(self.path)
                                        return 0
                                    endif
                                endfor
                            
   10   0.008350   0.000140     let c = self.getVisibleChildren()
   10              0.000060     return len(c) == 1 && c[0].path.isDirectory

FUNCTION  <SNR>172_GetCallbacks()
Called 1 time
Total time:   0.004641
 Self time:   0.000765

count  total (s)   self (s)
    1              0.000007     if len(a:fixers)
                                    let l:callback_list = a:fixers
                                elseif type(get(b:, 'ale_fixers')) is v:t_list
                                    " Lists can be used for buffer-local variables only
                                    let l:callback_list = b:ale_fixers
                                else
                                    " buffer and global options can use dictionaries mapping filetypes to
                                    " callbacks to run.
    1   0.000051   0.000017         let l:fixers = ale#Var(a:buffer, 'fixers')
    1              0.000004         let l:callback_list = []
    1              0.000004         let l:matched = 0
                            
    2              0.000020         for l:sub_type in split(&filetype, '\.')
    1   0.000109   0.000046             if s:AddSubCallbacks(l:callback_list, get(l:fixers, l:sub_type))
    1              0.000005                 let l:matched = 1
    1              0.000002             endif
    1              0.000002         endfor
                            
                                    " If we couldn't find fixers for a filetype, default to '*' fixers.
    1              0.000003         if !l:matched
                                        call s:AddSubCallbacks(l:callback_list, get(l:fixers, '*'))
                                    endif
    1              0.000001     endif
                            
    1              0.000004     if a:fixing_flag is# 'save_file'
    1   0.000051   0.000018         let l:config = ale#Var(a:buffer, 'fix_on_save_ignore')
                            
    1              0.000005         if !empty(l:config)
                                        call s:IgnoreFixers(l:callback_list, &filetype, l:config)
                                    endif
    1              0.000001     endif
                            
    1              0.000004     let l:corrected_list = []
                            
                                " Variables with capital characters are needed, or Vim will complain about
                                " funcref variables.
    3              0.000011     for l:Item in l:callback_list
    2              0.000012         if type(l:Item) is v:t_string
    2   0.004103   0.000390             let l:Func = ale#fix#registry#GetFunc(l:Item)
                            
    2              0.000011             if !empty(l:Func)
    2              0.000008                 let l:Item = l:Func
    2              0.000003             endif
    2              0.000002         endif
                            
    2              0.000004         try
    2   0.000075   0.000041             call add(l:corrected_list, ale#util#GetFunction(l:Item))
    2              0.000005         catch /E475/
                                        " Rethrow exceptions for failing to get a function so we can print
                                        " a friendly message about it.
                                        throw 'BADNAME ' . v:exception
                                    endtry
    2              0.000003     endfor
                            
    1              0.000003     return l:corrected_list

FUNCTION  <SNR>169_WinFindBuf()
Called 7 times
Total time:   0.000133
 Self time:   0.000133

count  total (s)   self (s)
    7              0.000120     return exists('*win_findbuf') ? win_findbuf(str2nr(a:buffer)) : [0]

FUNCTION  airline#extensions#default#apply()
Called 8 times
Total time:   0.010821
 Self time:   0.000870

count  total (s)   self (s)
    8              0.000038   let winnr = a:context.winnr
    8              0.000027   let active = a:context.active
                            
    8   0.000174   0.000109   if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
    8   0.004610   0.000157     call s:build_sections(a:builder, a:context, s:layout[0])
    8              0.000011   else
                                let text = s:get_section(winnr, 'c')
                                if empty(text)
                                  let text = ' %f%m '
                                endif
                                call a:builder.add_section('airline_c'.(a:context.bufnr), text)
                              endif
                            
    8   0.000836   0.000172   call a:builder.split(s:get_section(winnr, 'gutter', '', ''))
                            
    8   0.000131   0.000078   if airline#util#getwinvar(winnr, 'airline_render_right', 1)
    4   0.004769   0.000054     call s:build_sections(a:builder, a:context, s:layout[1])
    4              0.000005   endif
                            
    8              0.000012   return 1

FUNCTION  ale#FileTooLarge()
Called 13 times
Total time:   0.000275
 Self time:   0.000275

count  total (s)   self (s)
   13              0.000153     let l:max = getbufvar(a:buffer, 'ale_maximum_file_size', get(g:, 'ale_maximum_file_size', 0))
                            
   13              0.000091     return l:max > 0 ? (line2byte(line('$') + 1) > l:max) : 0

FUNCTION  <SNR>162_on_exit_clean()
Called 1 time
Total time:   0.000269
 Self time:   0.000088

count  total (s)   self (s)
    1              0.000009   let buf=self.buf
    1   0.000226   0.000045   call s:set_clean_variables(self.file, self.vcs, !empty(buf))
    1              0.000017   if has_key(get(s:clean_jobs, self.vcs, {}), self.file)
    1              0.000013     call remove(s:clean_jobs[self.vcs], self.file)
    1              0.000001   endif

FUNCTION  <SNR>168_GroupLoclistItems()
Called 7 times
Total time:   0.001086
 Self time:   0.001086

count  total (s)   self (s)
    7              0.000037     let l:grouped_items = []
    7              0.000027     let l:last_lnum = -1
                            
   27              0.000082     for l:obj in a:loclist
   20              0.000072         if l:obj.bufnr != a:buffer
                                        continue
                                    endif
                            
                                    " Create a new sub-List when we hit a new line.
   20              0.000114         if l:obj.lnum != l:last_lnum
   13              0.000076             call add(l:grouped_items, [])
   13              0.000020         endif
                            
   20              0.000124         call add(l:grouped_items[-1], l:obj)
   20              0.000077         let l:last_lnum = l:obj.lnum
   20              0.000058     endfor
                            
    7              0.000021     return l:grouped_items

FUNCTION  <SNR>95_airline_ale_get_line_number()
Called 1244 times
Total time:   0.143325
 Self time:   0.030221

count  total (s)   self (s)
                              " Use the new ALE statusline API function if it is available.
 1244              0.008950   if exists("*ale#statusline#FirstProblem")
 1244   0.131375   0.018271     return s:new_airline_ale_get_line_number(a:cnt, a:type)
                              endif
                            
                              return s:legacy_airline_ale_get_line_number(a:cnt, a:type)

FUNCTION  ale#engine#IsCheckingBuffer()
Called 1294 times
Total time:   0.056412
 Self time:   0.056412

count  total (s)   self (s)
 1294              0.012489     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
 1294              0.016642     return !empty(get(l:info, 'active_linter_list', []))   || !empty(get(l:info, 'active_other_sources_list', []))

FUNCTION  NERDTreeRender()
Called 1 time
Total time:   0.022242
 Self time:   0.000024

count  total (s)   self (s)
    1   0.022241   0.000023     call nerdtree#renderView()

FUNCTION  166()
Called 2 times
Total time:   0.002701
 Self time:   0.000046

count  total (s)   self (s)
    2   0.002699   0.000044     call self.path.refreshFlags(self.getNerdtree())

FUNCTION  airline#highlighter#add_separator()
Called 41 times
Total time:   0.053504
 Self time:   0.001476

count  total (s)   self (s)
   41              0.000586   let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
   41   0.052866   0.000838   call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  <SNR>148_StopCurrentJobs()
Called 2 times
Total time:   0.000233
 Self time:   0.000102

count  total (s)   self (s)
    2              0.000018     let l:info = get(g:ale_buffer_info, a:buffer, {})
    2   0.000123   0.000033     call ale#command#StopJobs(a:buffer, 'linter')
                            
                                " Update the active linter list, clearing out anything not running.
    2              0.000005     if a:clear_lint_file_jobs
    1   0.000050   0.000009         call ale#command#StopJobs(a:buffer, 'file_linter')
    1              0.000005         let l:info.active_linter_list = []
    1              0.000001     else
                                    " Keep jobs for linting files when we're only linting buffers.
    1              0.000008         call filter(l:info.active_linter_list, 'get(v:val, ''lint_file'')')
    1              0.000002     endif

FUNCTION  FugitiveGitDir()
Called 1917 times
Total time:   0.092231
 Self time:   0.073620

count  total (s)   self (s)
 1917              0.008472   if !a:0 || a:1 ==# -1
  639              0.003846     return get(b:, 'git_dir', '')
                              elseif type(a:1) == type(0)
                                return getbufvar(a:1, 'git_dir')
                              elseif type(a:1) == type('')
 1278   0.052481   0.033870     return substitute(s:Slash(a:1), '/$', '', '')
                              else
                                return ''
                              endif

FUNCTION  airline#extensions#tagbar#inactive_apply()
Called 4 times
Total time:   0.000048
 Self time:   0.000048

count  total (s)   self (s)
    4              0.000032   if getwinvar(a:2.winnr, '&filetype') == 'tagbar'
                                return -1
                              endif

FUNCTION  <SNR>39_NERDTreeTrimDoubleQuotes()
Called 8 times
Total time:   0.000247
 Self time:   0.000247

count  total (s)   self (s)
    8              0.000117     let l:toReturn = substitute(a:pathStr, '^"', '', '')
    8              0.000087     let l:toReturn = substitute(l:toReturn, '"$', '', '')
    8              0.000027     return l:toReturn

FUNCTION  ale#lsp#MarkConnectionAsTsserver()
Called 2 times
Total time:   0.000113
 Self time:   0.000113

count  total (s)   self (s)
    2              0.000023     let l:conn = s:connections[a:conn_id]
    2              0.000009     let l:conn.is_tsserver = 1
    2              0.000007     let l:conn.initialized = 1
                                " Set capabilities which are supported by tsserver.
    2              0.000008     let l:conn.capabilities.hover = 1
    2              0.000007     let l:conn.capabilities.references = 1
    2              0.000006     let l:conn.capabilities.completion = 1
    2              0.000029     let l:conn.capabilities.completion_trigger_characters = ['.']
    2              0.000008     let l:conn.capabilities.definition = 1
    2              0.000006     let l:conn.capabilities.symbol_search = 1

FUNCTION  airline#extensions#ale#get()
Called 1278 times
Total time:   0.500999
 Self time:   0.179960

count  total (s)   self (s)
 1278              0.009725   if !exists(':ALELint')
                                return ''
                              endif
                            
 1278              0.009838   let error_symbol = get(g:, 'airline#extensions#ale#error_symbol', 'E:')
 1278              0.008767   let warning_symbol = get(g:, 'airline#extensions#ale#warning_symbol', 'W:')
 1278              0.008976   let checking_symbol = get(g:, 'airline#extensions#ale#checking_symbol', '...')
 1278              0.008613   let show_line_numbers = get(g:, 'airline#extensions#ale#show_line_numbers', 1)
                            
 1278              0.005762   let is_err = a:type ==# 'error'
                            
 1278   0.073700   0.017671   if ale#engine#IsCheckingBuffer(bufnr('')) == 1
   34              0.000213     return is_err ? '' : checking_symbol
                              endif
                            
 1244              0.006102   let symbol = is_err ? error_symbol : warning_symbol
                            
 1244   0.130623   0.016414   let counts = ale#statusline#Count(bufnr(''))
 1244              0.011751   if type(counts) == type({}) && has_key(counts, 'error')
                                " Use the current Dictionary format.
 1244              0.006218     let errors = counts.error + counts.style_error
 1244              0.006083     let num = is_err ? errors : counts.total - errors
 1244              0.001853   else
                                " Use the old List format.
                                let num = is_err ? counts[0] : counts[1]
                              endif
                            
 1244              0.003124   if show_line_numbers == 1
 1244   0.180098   0.029296     return s:airline_ale_count(num, symbol) . <sid>airline_ale_get_line_number(num, a:type)
                              else
                                return s:airline_ale_count(num, symbol)
                              endif

FUNCTION  85()
Called 13 times
Total time:   0.000206
 Self time:   0.000206

count  total (s)   self (s)
   13              0.000096     if !exists("g:NERDTreeBookmarks")
                                    let g:NERDTreeBookmarks = []
                                endif
   13              0.000036     return g:NERDTreeBookmarks

FUNCTION  airline#util#wrap()
Called 5765 times
Total time:   0.102868
 Self time:   0.077966

count  total (s)   self (s)
 5765   0.066526   0.041624   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
                              endif
 5765              0.012888   return a:text

FUNCTION  gitgutter#debug#log()
Called 4 times
Total time:   0.000306
 Self time:   0.000306

count  total (s)   self (s)
    4              0.000057   if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
                              endif

FUNCTION  ale#command#Run()
Called 5 times
Total time:   0.026330
 Self time:   0.002215

count  total (s)   self (s)
    5              0.000036     let l:options = get(a:000, 0, {})
                            
    5              0.000018     if len(a:000) > 1
                                    throw 'Too many arguments!'
                                endif
                            
    5              0.000029     let l:output_stream = get(l:options, 'output_stream', 'stdout')
    5              0.000013     let l:line_list = []
                            
    5   0.007864   0.000182     let [l:temporary_file, l:command, l:file_created] = ale#command#FormatCommand(   a:buffer,   get(l:options, 'executable', ''),   a:command,   get(l:options, 'read_buffer', 0),   get(l:options, 'input', v:null),)
    5   0.000894   0.000114     let l:command = ale#job#PrepareCommand(a:buffer, l:command)
    5              0.000123     let l:job_options = {   'exit_cb': {job_id, exit_code -> s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )},   'mode': 'nl',}
                            
    5              0.000019     if l:output_stream is# 'stdout'
    3              0.000030         let l:job_options.out_cb = function('s:GatherOutput', [l:line_list])
    3              0.000006     elseif l:output_stream is# 'stderr'
                                    let l:job_options.err_cb = function('s:GatherOutput', [l:line_list])
                                elseif l:output_stream is# 'both'
    1              0.000015         let l:job_options.out_cb = function('s:GatherOutput', [l:line_list])
    1              0.000012         let l:job_options.err_cb = function('s:GatherOutput', [l:line_list])
    1              0.000002     endif
                            
    5              0.000013     let l:status = 'failed'
                            
    5              0.000050     if get(g:, 'ale_run_synchronously') == 1
                                    if get(g:, 'ale_emulate_job_failure') == 1
                                        let l:job_id = 0
                                    else
                                        " Generate a fake job ID for tests.
                                        let s:fake_job_id = get(s:, 'fake_job_id', 0) + 1
                                        let l:job_id = s:fake_job_id
                                    endif
                                elseif has('win32')
                                    let l:job_id = ale#job#StartWithCmd(l:command, l:job_options)
                                else
    5   0.015119   0.000214         let l:job_id = ale#job#Start(l:command, l:job_options)
    5              0.000013     endif
                            
    5              0.000012     if l:job_id
    5              0.000032         let l:status = 'started'
    5              0.000064         let l:job_type = getbufvar(a:buffer, 'ale_job_type', 'all')
                            
    5   0.000252   0.000139         call ale#command#InitData(a:buffer)
    5              0.000062         let s:buffer_data[a:buffer].jobs[l:job_id] = l:job_type
    5              0.000008     endif
                            
    5              0.000015     if g:ale_history_enabled
    5   0.000778   0.000143         call ale#history#Add(a:buffer, l:status, l:job_id, l:command)
    5              0.000009     endif
                            
    5              0.000013     if !l:job_id
                                    return 0
                                endif
                            
                                " We'll return this Dictionary. A `result_callback` can be assigned to it
                                " later for capturing the result of a:Callback.
                                "
                                " The `_deferred_job_id` is used for both checking the type of object, and
                                " for checking the job ID and status.
                                "
                                " The original command here is used in tests.
    5              0.000079     let l:result = {   '_deferred_job_id': l:job_id,   'executable': get(l:options, 'executable', ''),   'command': a:command,}
                            
    5              0.000031     if get(g:, 'ale_run_synchronously') == 1 && l:job_id
                                    if !exists('g:ale_run_synchronously_callbacks')
                                        let g:ale_run_synchronously_callbacks = []
                                    endif
                            
                                    if get(g:, 'ale_run_synchronously_emulate_commands', 0)
                                        call add(   g:ale_run_synchronously_callbacks,   {exit_code, output -> [       extend(l:line_list, output),       l:job_options.exit_cb(l:job_id, exit_code),   ]})
                                    else
                                        " Run a command synchronously if this test option is set.
                                        call extend(l:line_list, systemlist(   type(l:command) is v:t_list       ? join(l:command[0:1]) . ' ' . ale#Escape(l:command[2])       : l:command))
                            
                                        " Don't capture output when the callbacks aren't set.
                                        if !has_key(l:job_options, 'out_cb')&& !has_key(l:job_options, 'err_cb')
                                            let l:line_list = []
                                        endif
                            
                                        call add(   g:ale_run_synchronously_callbacks,   {-> l:job_options.exit_cb(l:job_id, v:shell_error)})
                                    endif
                                endif
                            
    5              0.000027     return l:result

FUNCTION  <SNR>171_GetFirstProblems()
Called 622 times
Total time:   0.040693
 Self time:   0.019865

count  total (s)   self (s)
  622   0.016948   0.006401     if !s:BufferCacheExists(a:buffer)
                                    return {}
                                endif
                            
  622   0.017110   0.006828     call s:UpdateCacheIfNecessary(a:buffer)
                            
  622              0.003054     return g:ale_buffer_info[a:buffer].first_problems

FUNCTION  airline#extensions#keymap#status()
Called 639 times
Total time:   0.014849
 Self time:   0.014849

count  total (s)   self (s)
  639              0.007060   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
  639              0.006821     return printf('%s', (!empty(&keymap) ? (g:airline_symbols.keymap . ' '. &keymap) : ''))
                              else
                                return ''
                              endif

FUNCTION  ale#path#Simplify()
Called 10 times
Total time:   0.000241
 Self time:   0.000241

count  total (s)   self (s)
   10              0.000031     if has('unix')
   10              0.000085         let l:unix_path = substitute(a:path, '\\', '/', 'g')
                            
   10              0.000107         return substitute(simplify(l:unix_path), '^//\+', '/', 'g') " no-custom-checks
                                endif
                            
                                let l:win_path = substitute(a:path, '/', '\\', 'g')
                            
                                return substitute(simplify(l:win_path), '^\\\+', '\', 'g') " no-custom-checks

FUNCTION  <SNR>107_get_seperator()
Called 35 times
Total time:   0.072674
 Self time:   0.001209

count  total (s)   self (s)
   35   0.024087   0.000582   if airline#builder#should_change_group(a:prev_group, a:group)
   35   0.048534   0.000574     return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
                              else
                                return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif

FUNCTION  ale#command#IsDeferred()
Called 17 times
Total time:   0.000163
 Self time:   0.000163

count  total (s)   self (s)
   17              0.000148     return type(a:value) is v:t_dict && has_key(a:value, '_deferred_job_id')

FUNCTION  <SNR>94_ModifierFlags()
Called 639 times
Total time:   0.005978
 Self time:   0.005978

count  total (s)   self (s)
  639              0.005273   return (exists("+autochdir") && &autochdir) ? ':p' : ':.'

FUNCTION  <SNR>91_is_branch_empty()
Called 639 times
Total time:   0.009162
 Self time:   0.009162

count  total (s)   self (s)
  639              0.008524   return exists('*airline#extensions#branch#head') && empty(get(b:, 'airline_head', ''))

FUNCTION  <SNR>67_record()
Called 1 time
Total time:   0.000460
 Self time:   0.000086

count  total (s)   self (s)
    1              0.000006 	if s:locked | retu | en
    1              0.000006 	let bufnr = a:bufnr + 0
    1              0.000006 	let bufname = bufname(bufnr)
    1              0.000006 	if bufnr > 0 && !empty(bufname)
    1              0.000021 		cal filter(s:mrbs, 'v:val != bufnr')
    1              0.000006 		cal insert(s:mrbs, bufnr)
    1   0.000404   0.000029 		cal s:addtomrufs(bufname)
    1              0.000002 	en

FUNCTION  airline#extensions#tabline#get()
Called 14 times
Total time:   0.023441
 Self time:   0.001124

count  total (s)   self (s)
   14              0.000196   let show_buffers = get(g:, 'airline#extensions#tabline#show_buffers', 1)
   14              0.000085   let show_tabs = get(g:, 'airline#extensions#tabline#show_tabs', 1)
                            
   14              0.000068   let curtabcnt = tabpagenr('$')
   14              0.000052   if curtabcnt != s:current_tabcnt
                                let s:current_tabcnt = curtabcnt
                                call airline#extensions#tabline#tabs#invalidate()
                                call airline#extensions#tabline#buffers#invalidate()
                                call airline#extensions#tabline#ctrlspace#invalidate()
                              endif
                            
   14              0.000097   if !exists('#airline#BufAdd#*')
                                autocmd airline BufAdd * call <sid>update_tabline()
                              endif
   14              0.000026   if s:ctrlspace
                                return airline#extensions#tabline#ctrlspace#get()
                              elseif show_buffers && curtabcnt == 1 || !show_tabs
   14   0.022509   0.000192     return airline#extensions#tabline#buffers#get()
                              else
                                return airline#extensions#tabline#tabs#get()
                              endif

FUNCTION  <SNR>116_tabline_evaluated_length()
Called 5 times
Total time:   0.000919
 Self time:   0.000119

count  total (s)   self (s)
    5   0.000915   0.000115   return airline#util#strchars(s:evaluate_tabline(a:tabline))

FUNCTION  gitgutter#utility#extension()
Called 2 times
Total time:   0.000352
 Self time:   0.000036

count  total (s)   self (s)
    2   0.000350   0.000034   return fnamemodify(s:abs_path(a:bufnr, 0), ':e')

FUNCTION  <SNR>119_OnInsertChar()
Called 304 times
Total time:   0.057114
 Self time:   0.011868

count  total (s)   self (s)
  304   0.045477   0.004086   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
  304              0.002431   call timer_stop( s:pollers.completion.id )
  304   0.007432   0.003578   call s:CloseCompletionMenu()

FUNCTION  <SNR>129_save_pos()
Called 1 time
Total time:   0.000178
 Self time:   0.000025

count  total (s)   self (s)
    1              0.000006   let l:pos = getpos('.')[1:2]
    1   0.000166   0.000012   let ret = call(a:f,a:000)
    1              0.000004   call call('cursor',l:pos)
    1              0.000001   return ret

FUNCTION  airline#util#getwinvar()
Called 84 times
Total time:   0.000704
 Self time:   0.000704

count  total (s)   self (s)
   84              0.000633     return getwinvar(a:winnr, a:key, a:def)

FUNCTION  <SNR>119_Complete()
Called 586 times
Total time:   0.032442
 Self time:   0.024729

count  total (s)   self (s)
                              " Do not call user's completion function if the start column is after the
                              " current column or if there are no candidates. Close the completion menu
                              " instead. This avoids keeping the user in completion mode.
  586              0.006500   if s:completion.completion_start_column > s:completion.column || empty( s:completion.completions )
  586   0.015163   0.007450     call s:CloseCompletionMenu()
  586              0.000888   else
                                " <c-x><c-u> invokes the user's completion function (which we have set to
                                " youcompleteme#CompleteFunc), and <c-p> tells Vim to select the previous
                                " completion candidate. This is necessary because by default, Vim selects
                                " the first candidate when completion is invoked, and selecting a candidate
                                " automatically replaces the current text with it. Calling <c-p> forces Vim
                                " to deselect the first candidate and in turn preserve the user's current
                                " text until he explicitly chooses to replace it with a completion.
                                call s:SendKeys( "\<C-X>\<C-U>\<C-P>" )
                              endif

FUNCTION  ale#fixers#tslint#Fix()
Called 1 time
Total time:   0.001194
 Self time:   0.000056

count  total (s)   self (s)
    1   0.000559   0.000010     let l:executable = ale#handlers#tslint#GetExecutable(a:buffer)
                            
    1   0.000565   0.000024     let l:tslint_config_path = ale#path#ResolveLocalPath(   a:buffer,   'tslint.json',   ale#Var(a:buffer, 'typescript_tslint_config_path'))
    1              0.000006     let l:tslint_config_option = !empty(l:tslint_config_path)   ? ' -c ' . ale#Escape(l:tslint_config_path)   : ''
                            
    1   0.000061   0.000014     return {   'command': ale#node#Executable(a:buffer, l:executable)       . l:tslint_config_option       . ' --fix %t',   'read_temporary_file': 1,}

FUNCTION  <SNR>93_format_name()
Called 4 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    4              0.000012     return a:name

FUNCTION  <SNR>104_get_syn()
Called 3132 times
Total time:   0.188452
 Self time:   0.188452

count  total (s)   self (s)
 3132              0.016625   if !exists("g:airline_gui_mode")
                                let g:airline_gui_mode = airline#init#gui_mode()
                              endif
 3132              0.008562   let color = ''
 3132              0.028496   if hlexists(a:group)
 3000              0.043247     let color = synIDattr(synIDtrans(hlID(a:group)), a:what, g:airline_gui_mode)
 3000              0.004278   endif
 3132              0.013723   if empty(color) || color == -1
                                " should always exists
  136              0.003526     let color = synIDattr(synIDtrans(hlID('Normal')), a:what, g:airline_gui_mode)
                                " however, just in case
  136              0.000639     if empty(color) || color == -1
                                  let color = 'NONE'
                                endif
  136              0.000102   endif
 3132              0.005556   return color

FUNCTION  ale#statusline#Count()
Called 1244 times
Total time:   0.114209
 Self time:   0.025640

count  total (s)   self (s)
                                " The Dictionary is copied here before exposing it to other plugins.
 1244   0.111604   0.023035     return copy(s:GetCounts(a:buffer))

FUNCTION  <SNR>104_group_not_done()
Called 567 times
Total time:   0.008966
 Self time:   0.008966

count  total (s)   self (s)
  567              0.003745   if index(a:list, a:name) == -1
  429              0.002191     call add(a:list, a:name)
  429              0.000769     return 1
                              else
  138              0.000234     if &vbs
                                  echomsg printf("airline: group: %s already done, skipping", a:name)
                                endif
  138              0.000145     return 0
                              endif

FUNCTION  gitgutter#hunk#hunks()
Called 2 times
Total time:   0.000069
 Self time:   0.000023

count  total (s)   self (s)
    2   0.000068   0.000021   return gitgutter#utility#getbufvar(a:bufnr, 'hunks', [])

FUNCTION  <SNR>164_is_modified_and_removed()
Called 2 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    2              0.000008   return a:from_count > 0 && a:to_count > 0 && a:from_count > a:to_count

FUNCTION  <SNR>119_PollCompletion()
Called 578 times
Total time:   0.883091
 Self time:   0.037854

count  total (s)   self (s)
  578   0.607628   0.011454   if !s:Pyeval( 'ycm_state.CompletionRequestReady()' )
  413              0.013246     let s:pollers.completion.id = timer_start( s:pollers.completion.wait_milliseconds, function( 's:PollCompletion' ) )
  413              0.001150     return
                              endif
                            
  165   0.243851   0.004000   let s:completion = s:Pyeval( 'ycm_state.GetCompletionResponse()' )
  165   0.012511   0.003298   call s:Complete()

FUNCTION  <SNR>164_is_modified()
Called 2 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    2              0.000009   return a:from_count > 0 && a:to_count > 0 && a:from_count == a:to_count

FUNCTION  airline#themes#patch()
Called 2 times
Total time:   0.001910
 Self time:   0.001910

count  total (s)   self (s)
   26              0.000152   for mode in keys(a:palette)
   24              0.000080     if mode == 'accents'
    2              0.000005       continue
                                endif
   22              0.000208     if !has_key(a:palette[mode], 'airline_warning')
                                  let a:palette[mode]['airline_warning'] = [ '#000000', '#df5f00', 232, 166 ]
                                endif
   22              0.000128     if !has_key(a:palette[mode], 'airline_error')
                                  let a:palette[mode]['airline_error'] = [ '#000000', '#990000', 232, 160 ]
                                endif
   22              0.000180     if !has_key(a:palette[mode], 'airline_term')
                                  let a:palette[mode]['airline_term'] = [ '#9cffd3', '#202020', 85, 232]
                                endif
   22              0.000037   endfor
                            
    2              0.000019   let a:palette.accents = get(a:palette, 'accents', {})
    2              0.000085   let a:palette.accents.none = [ '', '', '', '', '' ]
    2              0.000085   let a:palette.accents.bold = [ '', '', '', '', 'bold' ]
    2              0.000019   let a:palette.accents.italic = [ '', '', '', '', 'italic' ]
                            
    2              0.000012   if !has_key(a:palette.accents, 'red')
                                let a:palette.accents.red = [ '#ff0000' , '' , 160 , '' ]
                              endif
    2              0.000065   if !has_key(a:palette.accents, 'green')
                                let a:palette.accents.green = [ '#008700' , '' , 22  , '' ]
                              endif
    2              0.000009   if !has_key(a:palette.accents, 'blue')
                                let a:palette.accents.blue = [ '#005fff' , '' , 27  , '' ]
                              endif
    2              0.000008   if !has_key(a:palette.accents, 'yellow')
                                let a:palette.accents.yellow = [ '#dfff00' , '' , 190 , '' ]
                              endif
    2              0.000009   if !has_key(a:palette.accents, 'orange')
                                let a:palette.accents.orange = [ '#df5f00' , '' , 166 , '' ]
                              endif
    2              0.000011   if !has_key(a:palette.accents, 'purple')
                                let a:palette.accents.purple = [ '#af00df' , '' , 128 , '' ]
                              endif

FUNCTION  <SNR>119_AllowedToCompleteInBuffer()
Called 865 times
Total time:   0.102144
 Self time:   0.092315

count  total (s)   self (s)
  865              0.010895   let buftype = getbufvar( a:buffer, '&buftype' )
                            
  865              0.005679   if has_key( s:buftype_blacklist, buftype )
                                return 0
                              endif
                            
  865              0.007061   let filetype = getbufvar( a:buffer, '&filetype' )
                            
  865   0.023905   0.014077   if empty( filetype ) || s:DisableOnLargeFile( a:buffer )
                                return 0
                              endif
                            
  865              0.013956   let whitelist_allows = type( g:ycm_filetype_whitelist ) != type( {} ) || has_key( g:ycm_filetype_whitelist, '*' ) || has_key( g:ycm_filetype_whitelist, filetype )
  865              0.011143   let blacklist_allows = type( g:ycm_filetype_blacklist ) != type( {} ) || !has_key( g:ycm_filetype_blacklist, filetype )
                            
  865              0.004133   let allowed = whitelist_allows && blacklist_allows
  865              0.001893   if allowed
  865              0.006288     let s:previous_allowed_buffer_number = bufnr( a:buffer )
  865              0.001304   endif
  865              0.002021   return allowed

FUNCTION  airline#extensions#hunks#get_raw_hunks()
Called 639 times
Total time:   0.103765
 Self time:   0.036242

count  total (s)   self (s)
  639              0.006928   if !exists('b:source_func') || get(b:, 'source_func', '') is# 's:get_hunks_empty'
                                if get(g:, 'loaded_signify') && sy#buffer_is_active()
                                  let b:source_func = 's:get_hunks_signify'
                                elseif exists('*GitGutterGetHunkSummary')
                                  let b:source_func = 's:get_hunks_gitgutter'
                                elseif exists('*changes#GetStats')
                                  let b:source_func = 's:get_hunks_changes'
                                elseif exists('*quickfixsigns#vcsdiff#GetHunkSummary')
                                  let b:source_func = 'quickfixsigns#vcsdiff#GetHunkSummary'
                                else
                                  let b:source_func = 's:get_hunks_empty'
                                endif
                              endif
  639   0.077132   0.009608   return {b:source_func}()

FUNCTION  airline#extensions#tabline#formatters#default#wrap_name()
Called 15 times
Total time:   0.000580
 Self time:   0.000580

count  total (s)   self (s)
   15              0.000108   let _ = s:buf_nr_show ? printf(s:buf_nr_format, a:bufnr) : ''
   15              0.000227   let _ .= substitute(a:buffer_name, '\\', '/', 'g')
                            
   15              0.000099   if getbufvar(a:bufnr, '&modified') == 1
   10              0.000039     let _ .= s:buf_modified_symbol
   10              0.000011   endif
   15              0.000031   return _

FUNCTION  airline#async#nvim_vcs_untracked()
Called 4 times
Total time:   0.004577
 Self time:   0.004453

count  total (s)   self (s)
    4              0.000058   let cmd = a:cfg.cmd . shellescape(a:file)
    4              0.000015   let id = -1
    4   0.000326   0.000202   let config = { 'buf': '', 'vcs': a:vcs, 'cfg': a:cfg, 'file': a:file, 'cwd': s:valid_dir(fnamemodify(a:file, ':p:h')) }
    4              0.000028   if has("nvim")
    4              0.000141     call extend(config, { 'on_stdout': function('s:nvim_output_handler'), 'on_exit': function('s:nvim_untracked_job_handler')})
    4              0.000032     if has_key(s:untracked_jobs, config.file)
                                  " still running
    3              0.000005       return
                                endif
    1              0.000002     try
    1              0.003803     let id = jobstart(cmd, config)
    1              0.000007     catch
                                  " catch-all, jobstart() failed, fall back to system()
                                  let id=-1
                                endtry
    1              0.000022     let s:untracked_jobs[a:file] = id
    1              0.000002   endif
                              " vim without job feature or nvim jobstart failed
    1              0.000004   if id < 1
                                let output=system(cmd)
                                call s:untracked_output(config, output)
                                call airline#extensions#branch#update_untracked_config(a:file, a:vcs)
                              endif

FUNCTION  <SNR>155_StartLSP()
Called 2 times
Total time:   0.005930
 Self time:   0.000497

count  total (s)   self (s)
    2              0.000011     let l:buffer = a:options.buffer
    2              0.000007     let l:linter = a:options.linter
    2              0.000009     let l:root = a:options.root
    2              0.000013     let l:Callback = a:options.callback
                            
    2   0.000148   0.000056     let l:init_options = ale#lsp_linter#GetOptions(l:buffer, l:linter)
                            
    2              0.000008     if l:linter.lsp is# 'socket'
                                    let l:conn_id = ale#lsp#Register(a:address, l:root, l:init_options)
                                    let l:ready = ale#lsp#ConnectToAddress(l:conn_id, a:address)
                                    let l:command = ''
                                else
    2   0.000151   0.000047         let l:conn_id = ale#lsp#Register(a:executable, l:root, l:init_options)
                            
                                    " tsserver behaves differently, so tell the LSP API that it is tsserver.
    2              0.000007         if l:linter.lsp is# 'tsserver'
    2   0.000153   0.000040             call ale#lsp#MarkConnectionAsTsserver(l:conn_id)
    2              0.000003         endif
                            
    2   0.000451   0.000048         let l:command = ale#command#FormatCommand(l:buffer, a:executable, a:command, 0, v:false)[1]
    2   0.000332   0.000035         let l:command = ale#job#PrepareCommand(l:buffer, l:command)
    2   0.000313   0.000050         let l:ready = ale#lsp#StartProgram(l:conn_id, a:executable, l:command)
    2              0.000003     endif
                            
    2              0.000003     if !l:ready
                                    if g:ale_history_enabled && !empty(a:command)
                                        call ale#history#Add(l:buffer, 'failed', l:conn_id, a:command)
                                    endif
                            
                                    return 0
                                endif
                            
    2              0.000021     let l:details = {   'buffer': l:buffer,   'connection_id': l:conn_id,   'command': l:command,   'project_root': l:root,}
                            
    2   0.004223   0.000063     call ale#lsp#OnInit(l:conn_id, {->   ale#lsp_linter#OnInit(l:linter, l:details, l:Callback)})
                            
    2              0.000003     return 1

FUNCTION  gitgutter#hunk#increment_lines_modified()
Called 2 times
Total time:   0.000187
 Self time:   0.000049

count  total (s)   self (s)
    2   0.000091   0.000020   let summary = gitgutter#hunk#summary(a:bufnr)
    2              0.000007   let summary[1] += a:count
    2   0.000087   0.000020   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  ale#Queue()
Called 2 times
Total time:   0.036456
 Self time:   0.000306

count  total (s)   self (s)
    2              0.000009     if a:0 > 2
                                    throw 'too many arguments!'
                                endif
                            
    2              0.000017     let l:buffer = get(a:000, 1, v:null)
                            
    2              0.000009     if l:buffer is v:null
    2              0.000012         let l:buffer = bufnr('')
    2              0.000003     endif
                            
    2              0.000011     if type(l:buffer) isnot v:t_number
                                    throw 'buffer_number must be a Number'
                                endif
                            
    2   0.000550   0.000032     if ale#ShouldDoNothing(l:buffer)
                                    return
                                endif
                            
                                " Default linting_flag to ''
    2              0.000018     let l:should_lint_file = get(a:000, 0) is# 'lint_file'
                            
    2              0.000007     if s:lint_timer != -1
                                    call timer_stop(s:lint_timer)
                                    let s:lint_timer = -1
                                endif
                            
    2              0.000005     if a:delay > 0
                                    let s:lint_timer = timer_start(   a:delay,   function('s:Lint', [l:buffer, l:should_lint_file]))
                                else
    2   0.035716   0.000083         call s:Lint(l:buffer, l:should_lint_file, 0)
    2              0.000005     endif

FUNCTION  gitgutter#hunk#increment_lines_added()
Called 8 times
Total time:   0.000944
 Self time:   0.000228

count  total (s)   self (s)
    8   0.000479   0.000085   let summary = gitgutter#hunk#summary(a:bufnr)
    8              0.000031   let summary[0] += a:count
    8   0.000423   0.000100   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  <SNR>93_update_hg_branch()
Called 639 times
Total time:   0.071473
 Self time:   0.066180

count  total (s)   self (s)
  639   0.011779   0.006486   if airline#util#has_lawrencium()
                                let cmd='LC_ALL=C hg qtop'
                                let stl=lawrencium#statusline()
                                let file=expand('%:p')
                                if !empty(stl) && get(b:, 'airline_do_mq_check', 1)
                                  if g:airline#init#vim_async
                                    noa call airline#async#get_mq_async(cmd, file)
                                  elseif has("nvim")
                                    noa call airline#async#nvim_get_mq_async(cmd, file)
                                  else
                                    " remove \n at the end of the command
                                    let output=system(cmd)[0:-2]
                                    noa call airline#async#mq_output(output, file)
                                  endif
                                endif
                                " do not do mq check anymore
                                let b:airline_do_mq_check = 0
                                if exists("b:mq") && !empty(b:mq)
                                  if stl is# 'default'
                                    " Shorten default a bit
                                    let stl='def'
                                  endif
                                  let stl.=' ['.b:mq.']'
                                endif
                                let s:vcs_config['mercurial'].branch = stl
                              else
  639              0.003620     let s:vcs_config['mercurial'].branch = ''
  639              0.000915   endif

FUNCTION  airline#highlighter#load_theme()
Called 2 times
Total time:   0.222478
 Self time:   0.000685

count  total (s)   self (s)
    2              0.000013   if pumvisible()
                                return
                              endif
    4              0.000227   for winnr in filter(range(1, winnr('$')), 'v:val != winnr()')
    2   0.001986   0.000163     call airline#highlighter#highlight_modified_inactive(winbufnr(winnr))
    2              0.000004   endfor
    2   0.091840   0.000095   call airline#highlighter#highlight(['inactive'])
    2              0.000025   if getbufvar( bufnr('%'), '&modified'  )
    1   0.076563   0.000053     call airline#highlighter#highlight(['normal', 'modified'])
    1              0.000002   else
    1   0.051769   0.000054     call airline#highlighter#highlight(['normal'])
    1              0.000002   endif

FUNCTION  <SNR>119_OnCursorMovedNormalMode()
Called 4 times
Total time:   0.007566
 Self time:   0.007124

count  total (s)   self (s)
    4   0.000501   0.000059   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
    4              0.007049   exec s:python_command "ycm_state.OnCursorMoved()"

FUNCTION  <SNR>109_Lint()
Called 2 times
Total time:   0.035632
 Self time:   0.000656

count  total (s)   self (s)
                                " Use the filetype from the buffer
    2              0.000021     let l:filetype = getbufvar(a:buffer, '&filetype')
    2   0.001605   0.000075     let l:linters = ale#linter#Get(l:filetype)
                            
                                " Apply ignore lists for linters only if needed.
    2   0.000095   0.000034     let l:ignore_config = ale#Var(a:buffer, 'linters_ignore')
    2   0.000083   0.000030     let l:disable_lsp = ale#Var(a:buffer, 'disable_lsp')
    2              0.000027     let l:linters = !empty(l:ignore_config) || l:disable_lsp   ? ale#engine#ignore#Exclude(l:filetype, l:linters, l:ignore_config, l:disable_lsp)   : l:linters
                            
                                " Tell other sources that they can start checking the buffer now.
    2              0.000023     let g:ale_want_results_buffer = a:buffer
    2   0.000244   0.000193     silent doautocmd <nomodeline> User ALEWantResults
    2              0.000009     unlet! g:ale_want_results_buffer
                            
                                " Don't set up buffer data and so on if there are no linters to run.
    2              0.000021     if !has_key(g:ale_buffer_info, a:buffer) && empty(l:linters)
                                    return
                                endif
                            
                                " Clear lint_file linters, or only run them if the file exists.
    2              0.000114     let l:lint_file = empty(l:linters)   || (a:should_lint_file && filereadable(expand('#' . a:buffer . ':p')))
                            
    2   0.033351   0.000069     call ale#engine#RunLinters(a:buffer, l:linters, l:lint_file)

FUNCTION  ale#semver#ParseVersion()
Called 1 time
Total time:   0.000059
 Self time:   0.000059

count  total (s)   self (s)
    1              0.000006     for l:line in a:version_lines
    1              0.000033         let l:match = matchlist(l:line, '\v(\d+)\.(\d+)(\.(\d+))?')
                            
    1              0.000005         if !empty(l:match)
    1              0.000009             return [l:match[1] + 0, l:match[2] + 0, l:match[4] + 0]
                                    endif
                                endfor
                            
                                return []

FUNCTION  ale#engine#IsExecutable()
Called 10 times
Total time:   0.001831
 Self time:   0.001242

count  total (s)   self (s)
   10              0.000062     if empty(a:executable)
                                    " Don't log the executable check if the executable string is empty.
                                    return 0
                                endif
                            
                                " Check for a cached executable() check.
   10              0.000107     let l:result = get(s:executable_cache_map, a:executable, v:null)
                            
   10              0.000037     if l:result isnot v:null
    4              0.000009         return l:result
                                endif
                            
                                " Check if the file is executable, and convert -1 to 1.
    6              0.000640     let l:result = executable(a:executable) isnot 0
                            
                                " Cache the executable check if we found it, or if the option to cache
                                " failing checks is on.
    6              0.000051     if l:result || get(g:, 'ale_cache_executable_check_failures', 0)
                                    let s:executable_cache_map[a:executable] = l:result
                                endif
                            
    6              0.000017     if g:ale_history_enabled
    6   0.000692   0.000103         call ale#history#Add(a:buffer, l:result, 'executable', a:executable)
    6              0.000012     endif
                            
    6              0.000018     return l:result

FUNCTION  airline#extensions#branch#get_head()
Called 639 times
Total time:   1.750205
 Self time:   0.050641

count  total (s)   self (s)
  639   1.665847   0.008450   let head = airline#extensions#branch#head()
  639   0.015770   0.010028   let winwidth = get(airline#parts#get('branch'), 'minwidth', 120)
  639              0.005691   let minwidth = empty(get(b:, 'airline_hunks', '')) ? 14 : 7
  639   0.045018   0.008593   let head = airline#util#shorten(head, winwidth, minwidth)
  639              0.006010   let symbol = get(g:, 'airline#extensions#branch#symbol', g:airline_symbols.branch)
  639              0.009973   return empty(head) ? get(g:, 'airline#extensions#branch#empty_message', '') : printf('%s%s', empty(symbol) ? '' : symbol.(g:airline_symbols.space), head)

FUNCTION  ale#Escape()
Called 14 times
Total time:   0.000345
 Self time:   0.000345

count  total (s)   self (s)
   14              0.000106     if fnamemodify(&shell, ':t') is? 'cmd.exe'
                                    " If the string contains spaces, it will be surrounded by quotes.
                                    " Otherwise, special characters will be escaped with carets (^).
                                    return substitute(   a:str =~# ' '       ?  '"' .  substitute(a:str, '"', '""', 'g') . '"'       : substitute(a:str, '\v([&|<>^])', '^\1', 'g'),   '%',   '%%',   'g',)
                                endif
                            
   14              0.000077     return shellescape (a:str)

FUNCTION  <SNR>118_Tree()
Called 1278 times
Total time:   0.169648
 Self time:   0.018687

count  total (s)   self (s)
 1278   0.168468   0.017506   return a:0 ? FugitiveWorkTree(a:1) : FugitiveWorkTree()

FUNCTION  airline#update_statusline_inactive()
Called 4 times
Total time:   0.027669
 Self time:   0.000561

count  total (s)   self (s)
    4   0.000080   0.000050   if airline#util#getwinvar(winnr(), 'airline_disabled', 0)
                                return
                              endif
    8              0.000027   for nr in a:range
    4   0.000080   0.000044     if airline#util#getwinvar(nr, 'airline_disabled', 0)
                                  continue
                                endif
    4              0.000029     call setwinvar(nr, 'airline_active', 0)
    4              0.000039     let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
    4              0.000022     if get(g:, 'airline_inactive_alt_sep', 0)
                                  call extend(context, { 'left_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_alt_sep }, 'keep')
                                endif
    4   0.027166   0.000125     call s:invoke_funcrefs(context, s:inactive_funcrefs)
    4              0.000012   endfor

FUNCTION  <SNR>93_display_git_branch()
Called 4 times
Total time:   0.000477
 Self time:   0.000294

count  total (s)   self (s)
    4              0.000022   let name = b:buffer_vcs_config['git'].branch
    4              0.000008   try
    4   0.000278   0.000094     let commit = matchstr(FugitiveParse()[0], '^\x\+')
                            
    4              0.000020     if has_key(s:names, commit)
                                  let name = get(s:names, commit)."(".name.")"
                                elseif !empty(commit)
                                  let ref = fugitive#repo().git_chomp('describe', '--all', '--exact-match', commit)
                                  if ref !~ "^fatal: no tag exactly matches"
                                    let name = s:format_name(substitute(ref, '\v\C^%(heads/|remotes/|tags/)=','',''))."(".name.")"
                                  else
                                    let name = matchstr(commit, '.\{'.s:sha1size.'}')."(".name.")"
                                  endif
                                endif
    4              0.000005   catch
                              endtry
                            
    4              0.000007   return name

FUNCTION  <SNR>154_NeoVimCallback()
Called 19 times
Total time:   0.114359
 Self time:   0.002743

count  total (s)   self (s)
   19              0.000328     let l:info = s:job_map[a:job]
                            
   19              0.000102     if a:event is# 'stdout'
   14   0.062231   0.000629         let l:info.out_cb_line = ale#util#JoinNeovimOutput(   a:job,   l:info.out_cb_line,   a:data,   l:info.mode,   ale#util#GetFunction(l:info.out_cb),)
   14              0.000043     elseif a:event is# 'stderr'
    1   0.000130   0.000037         let l:info.err_cb_line = ale#util#JoinNeovimOutput(   a:job,   l:info.err_cb_line,   a:data,   l:info.mode,   ale#util#GetFunction(l:info.err_cb),)
    1              0.000002     else
    4              0.000034         if has_key(l:info, 'out_cb') && !empty(l:info.out_cb_line)
                                        call ale#util#GetFunction(l:info.out_cb)(a:job, l:info.out_cb_line)
                                    endif
                            
    4              0.000026         if has_key(l:info, 'err_cb') && !empty(l:info.err_cb_line)
                                        call ale#util#GetFunction(l:info.err_cb)(a:job, l:info.err_cb_line)
                                    endif
                            
    4              0.000008         try
    4   0.050066   0.000145             call ale#util#GetFunction(l:info.exit_cb)(a:job, a:data)
    4              0.000012         finally
                                        " Automatically forget about the job after it's done.
    4              0.000037             if has_key(s:job_map, a:job)
    4              0.000032                 call remove(s:job_map, a:job)
    4              0.000007             endif
    4              0.000007         endtry
    4              0.000004     endif

FUNCTION  airline#async#vcs_untracked()
Called 4 times
Total time:   0.005083
 Self time:   0.000506

count  total (s)   self (s)
    4              0.000018   if g:airline#init#vim_async
                                " Vim 8 with async support
                                noa call airline#async#vim_vcs_untracked(a:config, a:file)
                              else
                                " nvim async or vim without job-feature
    4   0.004980   0.000403     noa call airline#async#nvim_vcs_untracked(a:config, a:file, a:vcs)
    4              0.000010   endif

FUNCTION  gitgutter#all()
Called 2 times
Total time:   0.034729
 Self time:   0.000901

count  total (s)   self (s)
    2              0.000017   let visible = tabpagebuflist()
                            
    8              0.000065   for bufnr in range(1, bufnr('$') + 1)
    6              0.000033     if buflisted(bufnr)
    2              0.000394       let file = expand('#'.bufnr.':p')
    2              0.000015       if !empty(file)
    2              0.000012         if index(visible, bufnr) != -1
    2   0.033933   0.000105           call gitgutter#process_buffer(bufnr, a:force)
    2              0.000012         elseif a:force
                                      call s:reset_tick(bufnr)
                                    endif
    2              0.000002       endif
    2              0.000017     endif
    6              0.000013   endfor

FUNCTION  <SNR>155_ShouldIgnore()
Called 6 times
Total time:   0.000641
 Self time:   0.000275

count  total (s)   self (s)
                                " Ignore all diagnostics if LSP integration is disabled.
    6   0.000282   0.000087     if ale#Var(a:buffer, 'disable_lsp')
                                    return 1
                                endif
                            
    6   0.000260   0.000090     let l:config = ale#Var(a:buffer, 'linters_ignore')
                            
                                " Don't load code for ignoring diagnostics if there's nothing to ignore.
    6              0.000027     if empty(l:config)
    6              0.000012         return 0
                                endif
                            
                                let l:filetype = getbufvar(a:buffer, '&filetype')
                                let l:ignore_list = ale#engine#ignore#GetList(l:filetype, l:config)
                            
                                return index(l:ignore_list, a:linter_name) >= 0

FUNCTION  <SNR>96_check_mixed_indent_file()
Called 1 time
Total time:   0.000186
 Self time:   0.000186

count  total (s)   self (s)
    1              0.000015   let c_like_langs = get(g:, 'airline#extensions#c_like_langs', [ 'arduino', 'c', 'cpp', 'cuda', 'go', 'javascript', 'ld', 'php' ])
    1              0.000011   if index(c_like_langs, &ft) > -1
                                " for C-like languages: allow /** */ comment style with one space before the '*'
                                let head_spc = '\v(^ +\*@!)'
                              else
    1              0.000004     let head_spc = '\v(^ +)'
    1              0.000001   endif
    1              0.000031   let indent_tabs = search('\v(^\t+)', 'nw')
    1              0.000099   let indent_spc  = search(head_spc, 'nw')
    1              0.000005   if indent_tabs > 0 && indent_spc > 0
    1              0.000011     return printf("%d:%d", indent_tabs, indent_spc)
                              else
                                return ''
                              endif

FUNCTION  airline#extensions#term#inactive_apply()
Called 4 times
Total time:   0.000093
 Self time:   0.000093

count  total (s)   self (s)
    4              0.000035   if getbufvar(a:2.bufnr, '&buftype') == 'terminal'
                                let spc = g:airline_symbols.space
                                call a:1.add_section('airline_a', spc.'TERMINAL'.spc)
                                call a:1.add_section('airline_b', spc.'%f')
                                return 1
                              endif

FUNCTION  airline#async#vcs_clean()
Called 4 times
Total time:   0.011533
 Self time:   0.000379

count  total (s)   self (s)
    4              0.000018   if g:airline#init#vim_async
                                " Vim 8 with async support
                                noa call airline#async#vim_vcs_clean(a:cmd, a:file, a:vcs)
                              elseif has("nvim")
                                " nvim async
    4   0.011364   0.000210     noa call airline#async#nvim_vcs_clean(a:cmd, a:file, a:vcs)
    4              0.000008   else
                                " Vim pre 8 using system()
                                call airline#async#vim7_vcs_clean(a:cmd, a:file, a:vcs)
                              endif

FUNCTION  ale#job#SendRaw()
Called 4 times
Total time:   0.000201
 Self time:   0.000201

count  total (s)   self (s)
    4              0.000026     if has('nvim')
    4              0.000095         call jobsend(a:job_id, a:string)
    4              0.000008     else
                                    let l:job = s:job_map[a:job_id].job
                            
                                    if ch_status(l:job) is# 'open'
                                        call ch_sendraw(job_getchannel(l:job), a:string)
                                    endif
                                endif

FUNCTION  ale#fix#ApplyFixes()
Called 1 time
Total time:   0.019553
 Self time:   0.000245

count  total (s)   self (s)
    1              0.000009     let l:data = g:ale_fix_buffer_data[a:buffer]
    1              0.000005     let l:data.output = a:output
    1              0.000069     let l:data.changes_made = l:data.lines_before != l:data.output
    1              0.000004     let l:data.done = 1
                            
    1   0.001668   0.000052     call ale#command#RemoveManagedFiles(a:buffer)
                            
    1              0.000010     if !bufexists(a:buffer)
                                    " Remove the buffer data when it doesn't exist.
                                    call remove(g:ale_fix_buffer_data, a:buffer)
                                endif
                            
    1              0.000006     if l:data.changes_made && bufexists(a:buffer)
                                    let l:lines = getbufline(a:buffer, 1, '$')
                            
                                    if l:data.lines_before != l:lines
                                        call remove(g:ale_fix_buffer_data, a:buffer)
                                        execute 'echoerr ''The file was changed before fixing finished'''
                            
                                        return
                                    endif
                                endif
                            
                                " We can only change the lines of a buffer which is currently open,
                                " so try and apply the fixes to the current buffer.
    1   0.017738   0.000046     call ale#fix#ApplyQueuedFixes(a:buffer)

FUNCTION  FugitiveHead()
Called 639 times
Total time:   1.220587
 Self time:   0.023445

count  total (s)   self (s)
  639   0.016132   0.008582   let dir = FugitiveGitDir(a:0 > 1 ? a:2 : -1)
  639              0.002753   if empty(dir)
                                return ''
                              endif
  639   1.198631   0.009039   return fugitive#Head(a:0 ? a:1 : 0, dir)

FUNCTION  ale#util#Tempname()
Called 4 times
Total time:   0.000144
 Self time:   0.000144

count  total (s)   self (s)
    4              0.000015     let l:clear_tempdir = 0
                            
    4              0.000027     if exists('$TMPDIR') && empty($TMPDIR)
                                    let l:clear_tempdir = 1
                                    let $TMPDIR = '/tmp'
                                endif
                            
    4              0.000006     try
    4              0.000024         let l:name = tempname() " no-custom-checks
    4              0.000007     finally
    4              0.000008         if l:clear_tempdir
                                        let $TMPDIR = ''
                                    endif
    4              0.000005     endtry
                            
    4              0.000008     return l:name

FUNCTION  <SNR>85_is_excluded_window()
Called 8 times
Total time:   0.000865
 Self time:   0.000865

count  total (s)   self (s)
    8              0.000050   for matchft in g:airline_exclude_filetypes
                                if matchft ==# &ft
                                  return 1
                                endif
                              endfor
                            
   32              0.000100   for matchw in g:airline_exclude_filenames
   24              0.000378     if matchstr(expand('%'), matchw) ==# matchw
                                  return 1
                                endif
   24              0.000026   endfor
                            
    8              0.000026   if g:airline_exclude_preview && &previewwindow
                                return 1
                              endif
                            
    8              0.000013   return 0

FUNCTION  <SNR>140_LoadArgCount()
Called 4 times
Total time:   0.000626
 Self time:   0.000626

count  total (s)   self (s)
    4              0.000027     let l:Function = a:function
                            
    4              0.000022     redir => l:output
    4              0.000242         silent! function Function
    4              0.000029     redir END
                            
    4              0.000030     if !exists('l:output')
                                    return 0
                                endif
                            
    4              0.000147     let l:match = matchstr(split(l:output, "\n")[0], '\v\([^)]+\)')[1:-2]
    4              0.000072     let l:arg_list = filter(split(l:match, ', '), 'v:val isnot# ''...''')
                            
    4              0.000017     return len(l:arg_list)

FUNCTION  <SNR>149_TemporaryFilename()
Called 4 times
Total time:   0.000319
 Self time:   0.000175

count  total (s)   self (s)
    4              0.000035     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
    4              0.000013     if empty(l:filename)
                                    " If the buffer's filename is empty, create a dummy filename.
                                    let l:ft = getbufvar(a:buffer, '&filetype')
                                    let l:filename = 'file' . ale#filetypes#GuessExtension(l:ft)
                                endif
                            
                                " Create a temporary filename, <temp_dir>/<original_basename>
                                " The file itself will not be created by this function.
    4   0.000214   0.000070     return ale#util#Tempname() . (has('win32') ? '\' : '/') . l:filename

FUNCTION  NERDTreeGitStatusRefreshListener()
Called 3 times
Total time:   0.065567
 Self time:   0.000246

count  total (s)   self (s)
    3              0.000022     if !exists('b:NOT_A_GIT_REPOSITORY')
                                    call g:NERDTreeGitStatusRefresh()
                                endif
    3              0.000014     let l:path = a:event.subject
    3   0.065229   0.000068     let l:flag = g:NERDTreeGetGitStatusPrefix(l:path)
    3   0.000109   0.000055     call l:path.flagSet.clearFlags('git')
    3              0.000013     if l:flag !=# ''
    2   0.000137   0.000032         call l:path.flagSet.addFlag('git', l:flag)
    2              0.000002     endif

FUNCTION  <SNR>119_OnDeleteChar()
Called 135 times
Total time:   0.024321
 Self time:   0.005368

count  total (s)   self (s)
  135   0.021135   0.002182   if !s:AllowedToCompleteInCurrentBuffer()
                                return a:key
                              endif
                            
  135              0.001015   call timer_stop( s:pollers.completion.id )
  135              0.000468   if pumvisible()
                                return "\<C-y>" . a:key
                              endif
  135              0.000300   return a:key

FUNCTION  <SNR>95_ale_refresh()
Called 4 times
Total time:   0.000076
 Self time:   0.000076

count  total (s)   self (s)
    4              0.000046   if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh!'
                              endif

FUNCTION  fugitive#CommonDir()
Called 1278 times
Total time:   0.068634
 Self time:   0.068634

count  total (s)   self (s)
 1278              0.006659   if empty(a:dir)
                                return ''
                              endif
 1278              0.007400   if !has_key(s:commondirs, a:dir)
                                if getfsize(a:dir . '/HEAD') < 10
                                  let s:commondirs[a:dir] = ''
                                elseif filereadable(a:dir . '/commondir')
                                  let dir = get(readfile(a:dir . '/commondir', 1), 0, '')
                                  if dir =~# '^/\|^\a:/'
                                    let s:commondirs[a:dir] = dir
                                  else
                                    let s:commondirs[a:dir] = simplify(a:dir . '/' . dir)
                                  endif
                                else
                                  let s:commondirs[a:dir] = a:dir
                                endif
                              endif
 1278              0.005929   return s:commondirs[a:dir]

FUNCTION  airline#builder#get_next_group()
Called 1 time
Total time:   0.000049
 Self time:   0.000049

count  total (s)   self (s)
    1              0.000006   let x = a:i + 1
    1              0.000005   let l = len(a:sections)
    2              0.000006   while x < l
    2              0.000010     let group = a:sections[x][0]
    2              0.000008     if group != '' && group != '|'
    1              0.000003       return group
                                endif
    1              0.000003     let x = x + 1
    1              0.000002   endwhile
                              return ''

FUNCTION  <SNR>169_CloseWindowIfNeeded()
Called 1 time
Total time:   0.000109
 Self time:   0.000028

count  total (s)   self (s)
    1   0.000105   0.000025     if ale#Var(a:buffer, 'keep_list_window_open') || !s:ShouldOpen(a:buffer)
    1              0.000002         return
                                endif
                            
                                try
                                    " Only close windows if the quickfix list or loclist is completely empty,
                                    " including errors set through other means.
                                    if g:ale_set_quickfix
                                        if empty(getqflist())
                                            cclose
                                        endif
                                    else
                                        let l:win_ids = s:WinFindBuf(a:buffer)
                            
                                        for l:win_id in l:win_ids
                                            if g:ale_set_loclist && empty(getloclist(l:win_id))
                                                lclose
                                            endif
                                        endfor
                                    endif
                                " Ignore 'Cannot close last window' errors.
                                catch /E444/
                                endtry

FUNCTION  <SNR>93_update_branch()
Called 639 times
Total time:   1.402005
 Self time:   0.068019

count  total (s)   self (s)
 1917              0.009858   for vcs in keys(s:vcs_config)
 1278   1.357232   0.023246     call {s:vcs_config[vcs].update_branch}()
 1278              0.010803     if b:buffer_vcs_config[vcs].branch != s:vcs_config[vcs].branch
                                  let b:buffer_vcs_config[vcs].branch = s:vcs_config[vcs].branch
                                  unlet! b:airline_head
                                endif
 1278              0.001930   endfor

FUNCTION  airline#parts#ffenc()
Called 639 times
Total time:   0.030212
 Self time:   0.030212

count  total (s)   self (s)
  639              0.005699   let expected = get(g:, 'airline#parts#ffenc#skip_expected_string', '')
  639              0.003076   let bomb     = &l:bomb ? '[BOM]' : ''
  639              0.008572   let ff       = strlen(&ff) ? '['.&ff.']' : ''
  639              0.005453   if expected is# &fenc.bomb.ff
                                return ''
                              else
  639              0.004037     return &fenc.bomb.ff
                              endif

FUNCTION  ale#Var()
Called 87 times
Total time:   0.002718
 Self time:   0.002718

count  total (s)   self (s)
   87              0.000611     let l:full_name = 'ale_' . a:variable_name
   87              0.001060     let l:vars = getbufvar(str2nr(a:buffer), '', {})
                            
   87              0.000814     return get(l:vars, l:full_name, g:[l:full_name])

FUNCTION  <SNR>44_airline_refresh()
Called 2 times
Total time:   0.358228
 Self time:   0.000336

count  total (s)   self (s)
                              " a:1, fast refresh, do not reload the theme
    2              0.000025   let fast=!empty(get(a:000, 0, 0))
    2              0.000039   if !exists("#airline")
                                " disabled
                                return
                              endif
    2   0.000685   0.000035   call airline#util#doautocmd('AirlineBeforeRefresh')
    2   0.001573   0.000079   call airline#highlighter#reset_hlcache()
    2              0.000012   if !fast
    2   0.302569   0.000047     call airline#load_theme()
    2              0.000004   endif
    2   0.053234   0.000032   call airline#update_statusline()
    2   0.000059   0.000034   call airline#update_tabline()

FUNCTION  <SNR>42_dir()
Called 4 times
Total time:   0.000990
 Self time:   0.000124

count  total (s)   self (s)
    4   0.000986   0.000120   return gitgutter#utility#shellescape(fnamemodify(s:abs_path(a:bufnr, 0), ':h'))

FUNCTION  tagbar#currenttag()
Called 29 times
Total time:   0.002140
 Self time:   0.001882

count  total (s)   self (s)
                                " Indicate that the statusline functionality is being used. This prevents
                                " the CloseWindow() function from removing the autocommands.
   29              0.000134     let s:statusline_in_use = 1
                            
   29              0.000073     if a:0 > 0
                                    " also test for non-zero value for backwards compatibility
   29              0.000418         let longsig   = a:1 =~# 's' || (type(a:1) == type(0) && a:1 != 0)
   29              0.000201         let fullpath  = a:1 =~# 'f'
   29              0.000184         let prototype = a:1 =~# 'p'
   29              0.000045     else
                                    let longsig   = 0
                                    let fullpath  = 0
                                    let prototype = 0
                                endif
                            
   29   0.000619   0.000361     if !s:Init(1)
   29              0.000077         return a:default
                                endif
                            
                                let tag = s:GetNearbyTag(0, 1)
                            
                                if !empty(tag)
                                    if prototype
                                        return tag.getPrototype(1)
                                    else
                                        return printf(a:fmt, tag.str(longsig, fullpath))
                                    endif
                                else
                                    return a:default
                                endif

FUNCTION  gitgutter#diff#parse_hunk()
Called 10 times
Total time:   0.000581
 Self time:   0.000581

count  total (s)   self (s)
   10              0.000255   let matches = matchlist(a:line, s:hunk_re)
   10              0.000041   if len(matches) > 0
   10              0.000050     let from_line  = str2nr(matches[1])
   10              0.000068     let from_count = (matches[2] == '') ? 1 : str2nr(matches[2])
   10              0.000044     let to_line    = str2nr(matches[3])
   10              0.000056     let to_count   = (matches[4] == '') ? 1 : str2nr(matches[4])
   10              0.000043     return [from_line, from_count, to_line, to_count]
                              else
                                return []
                              end

FUNCTION  <SNR>119_PollFileParseResponse()
Called 1 time
Total time:   0.001806
 Self time:   0.000730

count  total (s)   self (s)
    1   0.000516   0.000018   if !s:Pyeval( "ycm_state.FileParseRequestReady()" )
                                let s:pollers.file_parse_response.id = timer_start( s:pollers.file_parse_response.wait_milliseconds, function( 's:PollFileParseResponse' ) )
                                return
                              endif
                            
    1              0.000656   exec s:python_command "ycm_state.HandleFileParseRequest()"
    1   0.000599   0.000021   if s:Pyeval( "ycm_state.ShouldResendFileParseRequest()" )
                                call s:OnFileReadyToParse( 1 )
                              endif

FUNCTION  ale#util#FunctionArgCount()
Called 2 times
Total time:   0.013651
 Self time:   0.001019

count  total (s)   self (s)
    2   0.000072   0.000034     let l:Function = ale#util#GetFunction(a:function)
    2   0.000338   0.000052     let l:count = s:LoadArgCount(l:Function)
                            
                                " If we failed to get the count, forcibly load the autoload file, if the
                                " function is an autoload function. autoload functions aren't normally
                                " defined until they are called.
    2              0.000006     if l:count == 0
    2              0.000093         let l:function_name = matchlist(string(l:Function), 'function([''"]\(.\+\)[''"])')[1]
                            
    2              0.000018         if l:function_name =~# '#'
    2   0.012708   0.000741             execute 'runtime autoload/' . join(split(l:function_name, '#')[:-2], '/') . '.vim'
    2   0.000390   0.000050             let l:count = s:LoadArgCount(l:Function)
    2              0.000003         endif
    2              0.000001     endif
                            
    2              0.000003     return l:count

FUNCTION  airline#util#winwidth()
Called 6656 times
Total time:   0.135472
 Self time:   0.135472

count  total (s)   self (s)
 6656              0.043141   let nr = get(a:000, 0, 0)
 6656              0.033467   if get(g:, 'airline_statusline_ontop', 0)
                                return &columns
                              else
 6656              0.024880     return winwidth(nr)
                              endif

FUNCTION  <SNR>119_AllowedToCompleteInCurrentBuffer()
Called 865 times
Total time:   0.115938
 Self time:   0.013794

count  total (s)   self (s)
  865   0.115073   0.012929   return s:AllowedToCompleteInBuffer( '%' )

FUNCTION  airline#update_tabline()
Called 18 times
Total time:   0.000229
 Self time:   0.000229

count  total (s)   self (s)
   18              0.000114   if get(g:, 'airline_statusline_ontop', 0)
                                call airline#extensions#tabline#redraw()
                              endif

FUNCTION  ale#handlers#tsserver#GetProjectRoot()
Called 2 times
Total time:   0.001014
 Self time:   0.000078

count  total (s)   self (s)
    2   0.000979   0.000042     let l:tsconfig_file = ale#path#FindNearestFile(a:buffer, 'tsconfig.json')
                            
    2              0.000027     return !empty(l:tsconfig_file) ? fnamemodify(l:tsconfig_file, ':h') : ''

FUNCTION  airline#parts#get()
Called 1278 times
Total time:   0.011226
 Self time:   0.011226

count  total (s)   self (s)
 1278              0.009883   return get(s:parts, a:key, {})

FUNCTION  airline#load_theme()
Called 2 times
Total time:   0.302522
 Self time:   0.000705

count  total (s)   self (s)
    2              0.000032   let g:airline_theme = get(g:, 'airline_theme', 'dark')
    2              0.000248   if exists('*airline#themes#{g:airline_theme}#refresh')
                                call airline#themes#{g:airline_theme}#refresh()
                              endif
                            
    2              0.000026   let palette = g:airline#themes#{g:airline_theme}#palette
    2   0.001956   0.000046   call airline#themes#patch(palette)
                            
    2              0.000012   if exists('g:airline_theme_patch_func')
                                let Fn = function(g:airline_theme_patch_func)
                                call Fn(palette)
                              endif
                            
    2   0.222592   0.000114   call airline#highlighter#load_theme()
    2   0.024463   0.000051   call airline#extensions#load_theme()
    2   0.053073   0.000055   call airline#update_statusline()

FUNCTION  airline#parts#paste()
Called 639 times
Total time:   0.004447
 Self time:   0.004447

count  total (s)   self (s)
  639              0.003904   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  <SNR>104_exec_separator()
Called 335 times
Total time:   0.369857
 Self time:   0.023727

count  total (s)   self (s)
  335              0.001111   if pumvisible()
                                return
                              endif
  335              0.001992   let group = a:from.'_to_'.a:to.a:suffix
  335   0.117179   0.003781   let l:from = airline#themes#get_highlight(a:from.a:suffix)
  335   0.093907   0.003626   let l:to = airline#themes#get_highlight(a:to.a:suffix)
  335              0.000666   if a:inverse
  143              0.000945     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
  143              0.000180   else
  192              0.001364     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
  192              0.000212   endif
  335              0.002312   let a:dict[group] = colors
  335   0.146753   0.004302   call airline#highlighter#exec(group, colors)

FUNCTION  airline#update_statusline()
Called 4 times
Total time:   0.106219
 Self time:   0.000559

count  total (s)   self (s)
    4   0.000102   0.000068   if airline#util#getwinvar(winnr(), 'airline_disabled', 0)
                                return
                              endif
    4              0.000064   let range = filter(range(1, winnr('$')), 'v:val != winnr()')
                              " create inactive statusline
    4   0.027741   0.000072   call airline#update_statusline_inactive(range)
                            
    4              0.000016   unlet! w:airline_render_left w:airline_render_right
    4              0.000089   exe 'unlet! ' 'w:airline_section_'. join(s:sections, ' w:airline_section_')
                            
                              " Now create the active statusline
    4              0.000013   let w:airline_active = 1
    4              0.000044   let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
    4   0.078109   0.000153   call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)

FUNCTION  <SNR>164_process_added()
Called 8 times
Total time:   0.000469
 Self time:   0.000469

count  total (s)   self (s)
    8              0.000031   let offset = 0
   26              0.000073   while offset < a:to_count
   18              0.000067     let line_number = a:to_line + offset
   18              0.000110     call add(a:modifications, [line_number, 'added'])
   18              0.000052     let offset += 1
   18              0.000027   endwhile

FUNCTION  <SNR>119_InsideCommentOrString()
Called 421 times
Total time:   0.196602
 Self time:   0.196602

count  total (s)   self (s)
                              " Has to be col('.') -1 because col('.') doesn't exist at this point. We are
                              " in insert mode when this func is called.
  421              0.184626   let syntax_group = synIDattr( synIDtrans( synID( line( '.' ), col( '.' ) - 1, 1 ) ), 'name')
                            
  421              0.003298   if stridx(syntax_group, 'Comment') > -1
                                return 1
                              endif
                            
  421              0.001996   if stridx(syntax_group, 'String') > -1
                                return 2
                              endif
                            
  421              0.000718   return 0

FUNCTION  airline#update_statusline_focuslost()
Called 2 times
Total time:   0.000070
 Self time:   0.000070

count  total (s)   self (s)
    2              0.000021   if get(g:, 'airline_focuslost_inactive', 0)
                                let bufnr=bufnr('%')
                                call airline#highlighter#highlight_modified_inactive(bufnr)
                                call airline#highlighter#highlight(['inactive'], bufnr)
                                call airline#update_statusline_inactive(range(1, winnr('$')))
                              endif

FUNCTION  gitgutter#diff#handler()
Called 2 times
Total time:   0.012444
 Self time:   0.000376

count  total (s)   self (s)
    2   0.000215   0.000050   call gitgutter#debug#log(a:diff)
                            
    2              0.000026   if !bufexists(a:bufnr)
                                return
                              endif
                            
    2   0.001253   0.000056   call gitgutter#hunk#set_hunks(a:bufnr, gitgutter#diff#parse_diff(a:diff))
    2   0.003773   0.000051   let modified_lines = gitgutter#diff#process_hunks(a:bufnr, gitgutter#hunk#hunks(a:bufnr))
                            
    2              0.000011   let signs_count = len(modified_lines)
    2              0.000007   if signs_count > g:gitgutter_max_signs
                                call gitgutter#utility#warn_once(a:bufnr, printf( 'exceeded maximum number of signs (%d > %d, configured by g:gitgutter_max_signs).', signs_count, g:gitgutter_max_signs), 'max_signs')
                                call gitgutter#sign#clear_signs(a:bufnr)
                            
                              else
    2              0.000007     if g:gitgutter_signs || g:gitgutter_highlight_lines
    2   0.006923   0.000047       call gitgutter#sign#update_signs(a:bufnr, modified_lines)
    2              0.000002     endif
    2              0.000002   endif
                            
    2   0.000136   0.000027   call s:save_last_seen_change(a:bufnr)
    2              0.000022   if exists('#User#GitGutter')
                                let g:gitgutter_hook_context = {'bufnr': a:bufnr}
                                execute 'doautocmd' s:nomodeline 'User GitGutter'
                                unlet g:gitgutter_hook_context
                              endif

FUNCTION  ale#semver#RunWithVersionCheck()
Called 1 time
Total time:   0.003983
 Self time:   0.000097

count  total (s)   self (s)
    1              0.000010     if empty(a:executable)
                                    return ''
                                endif
                            
    1              0.000005     let l:cache = s:version_cache
                            
    1              0.000007     if has_key(s:version_cache, a:executable)
                                    return a:Callback(a:buffer, s:version_cache[a:executable])
                                endif
                            
    1   0.003942   0.000055     return ale#command#Run(   a:buffer,   a:command,   {_, output -> a:Callback(a:buffer, s:GetVersion(a:executable, output))},   {'output_stream': 'both', 'executable': a:executable})

FUNCTION  <SNR>119_OnFileReadyToParse()
Called 1 time
Total time:   0.001854
 Self time:   0.000815

count  total (s)   self (s)
                              " Accepts an optional parameter that is either 0 or 1. If 1, send a
                              " FileReadyToParse event notification, whether the buffer has changed or not;
                              " effectively forcing a parse of the buffer. Default is 0.
    1              0.000006   let force_parsing = a:0 > 0 && a:1
                            
                              " We only want to send a new FileReadyToParse event notification if the buffer
                              " has changed since the last time we sent one, or if forced.
    1   0.001053   0.000014   if force_parsing || s:Pyeval( "ycm_state.NeedsReparse()" )
    1              0.000741     exec s:python_command "ycm_state.OnFileReadyToParse()"
                            
    1              0.000011     call timer_stop( s:pollers.file_parse_response.id )
    1              0.000030     let s:pollers.file_parse_response.id = timer_start( s:pollers.file_parse_response.wait_milliseconds, function( 's:PollFileParseResponse' ) )
    1              0.000003   endif

FUNCTION  ale#util#BinarySearch()
Called 4 times
Total time:   0.000794
 Self time:   0.000794

count  total (s)   self (s)
    4              0.000015     let l:min = 0
    4              0.000023     let l:max = len(a:loclist) - 1
                            
   11              0.000020     while 1
   11              0.000029         if l:max < l:min
    3              0.000005             return -1
                                    endif
                            
    8              0.000032         let l:mid = (l:min + l:max) / 2
    8              0.000038         let l:item = a:loclist[l:mid]
                            
                                    " Binary search for equal buffers, equal lines, then near columns.
    8              0.000026         if l:item.bufnr < a:buffer
                                        let l:min = l:mid + 1
                                    elseif l:item.bufnr > a:buffer
                                        let l:max = l:mid - 1
                                    elseif l:item.lnum < a:line
    7              0.000019             let l:min = l:mid + 1
    7              0.000016         elseif l:item.lnum > a:line
                                        let l:max = l:mid - 1
                                    else
                                        " This part is a small sequential search.
    1              0.000004             let l:index = l:mid
                            
                                        " Search backwards to find the first problem on the line.
    1              0.000008             while l:index > 0&& a:loclist[l:index - 1].bufnr == a:buffer&& a:loclist[l:index - 1].lnum == a:line
                                            let l:index -= 1
                                        endwhile
                            
                                        " Find the last problem on or before this column.
    1              0.000007             while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col <= a:column
                                            let l:index += 1
                                        endwhile
                            
                                        " Scan forwards to find the last item on the column for the item
                                        " we found, which will have the most serious problem.
    1              0.000006             let l:item_column = a:loclist[l:index].col
                            
    1              0.000008             while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col == l:item_column
                                            let l:index += 1
                                        endwhile
                            
    1              0.000003             return l:index
                                    endif
    7              0.000009     endwhile

FUNCTION  <SNR>155_StartIfExecutable()
Called 2 times
Total time:   0.006367
 Self time:   0.000176

count  total (s)   self (s)
    2   0.000047   0.000026     if ale#command#IsDeferred(a:executable)
                                    let a:executable.result_callback = {   executable -> s:StartIfExecutable(a:options, executable)}
                            
                                    return 1
                                endif
                            
    2   0.000085   0.000031     if !ale#engine#IsExecutable(a:options.buffer, a:executable)
                                    return 0
                                endif
                            
    2   0.000085   0.000031     let l:command = ale#linter#GetCommand(a:options.buffer, a:options.linter)
                            
    2   0.006109   0.000047     return s:StartWithCommand(a:options, a:executable, l:command)

FUNCTION  ale#events#SaveEvent()
Called 1 time
Total time:   0.034676
 Self time:   0.005574

count  total (s)   self (s)
    1   0.000061   0.000023     let l:should_lint = ale#Var(a:buffer, 'enabled') && g:ale_lint_on_save
                            
    1              0.000003     if l:should_lint
    1              0.000008         call setbufvar(a:buffer, 'ale_save_event_fired', 1)
    1              0.000002     endif
                            
    1   0.000088   0.000039     if ale#Var(a:buffer, 'fix_on_save') && !ale#events#QuitRecently(a:buffer)
    1   0.034488   0.005472         let l:will_fix = ale#fix#Fix(a:buffer, 'save_file')
    1              0.000006         let l:should_lint = l:should_lint && !l:will_fix
    1              0.000002     endif
                            
    1              0.000005     if l:should_lint && !ale#events#QuitRecently(a:buffer)
                                    call ale#Queue(0, 'lint_file', a:buffer)
                                endif

FUNCTION  ale#fix#InitBufferData()
Called 1 time
Total time:   0.000074
 Self time:   0.000074

count  total (s)   self (s)
                                " The 'done' flag tells the function for applying changes when fixing
                                " is complete.
    1              0.000070     let g:ale_fix_buffer_data[a:buffer] = {   'lines_before': getbufline(a:buffer, 1, '$'),   'done': 0,   'should_save': a:fixing_flag is# 'save_file',   'temporary_directory_list': [],}

FUNCTION  airline#parts#readonly()
Called 653 times
Total time:   0.058997
 Self time:   0.026149

count  total (s)   self (s)
                              " only consider regular buffers (e.g. ones that represent actual files,
                              " but not special ones like e.g. NERDTree)
  653   0.045289   0.012442   if !empty(&buftype) || airline#util#ignore_buf(bufname('%'))
   14              0.000024     return ''
                              endif
  639              0.003880   if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
                              else
  639              0.002182     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  fugitive#Head()
Called 639 times
Total time:   1.189592
 Self time:   0.155708

count  total (s)   self (s)
  639              0.005111   let dir = a:0 > 1 ? a:2 : s:Dir()
  639   0.545882   0.053392   if empty(dir) || !filereadable(fugitive#Find('.git/HEAD', dir))
                                return ''
                              endif
  639   0.603182   0.061788   let head = readfile(fugitive#Find('.git/HEAD', dir))[0]
  639              0.009530   if head =~# '^ref: '
  639              0.020769     return substitute(head, '\C^ref: \%(refs/\%(heads/\|remotes/\|tags/\)\=\)\=', '', '')
                              elseif head =~# '^\x\{40\}$'
                                let len = a:0 ? a:1 : 0
                                return len < 0 ? head : len ? head[0:len-1] : ''
                              else
                                return ''
                              endif

FUNCTION  ale#engine#FixLocList()
Called 7 times
Total time:   0.006001
 Self time:   0.004960

count  total (s)   self (s)
    7              0.000034     let l:bufnr_map = {}
    7              0.000027     let l:new_loclist = []
                            
                                " Some errors have line numbers beyond the end of the file,
                                " so we need to adjust them so they set the error at the last line
                                " of the file instead.
    7   0.000946   0.000133     let l:last_line_number = ale#util#GetLineCount(a:buffer)
                            
   19              0.000076     for l:old_item in a:loclist
                                    " Copy the loclist item with some default values and corrections.
                                    "
                                    " line and column numbers will be converted to numbers.
                                    " The buffer will default to the buffer being checked.
                                    " The vcol setting will default to 0, a byte index.
                                    " The error type will default to 'E' for errors.
                                    " The error number will default to -1.
                                    "
                                    " The line number and text are the only required keys.
                                    "
                                    " The linter_name will be set on the errors so it can be used in
                                    " output, filtering, etc..
   12              0.000423         let l:item = {   'bufnr': a:buffer,   'text': l:old_item.text,   'lnum': str2nr(l:old_item.lnum),   'col': str2nr(get(l:old_item, 'col', 0)),   'vcol': 0,   'type': get(l:old_item, 'type', 'E'),   'nr': get(l:old_item, 'nr', -1),   'linter_name': a:linter_name,}
                            
   12              0.000042         if a:from_other_source
                                        let l:item.from_other_source = 1
                                    endif
                            
   12              0.000060         if has_key(l:old_item, 'code')
   11              0.000090             let l:item.code = l:old_item.code
   11              0.000018         endif
                            
   12              0.000097         if has_key(l:old_item, 'filename')&& !ale#path#IsTempName(l:old_item.filename)
                                        " Use the filename given.
                                        " Temporary files are assumed to be for this buffer,
                                        " and the filename is not included then, because it looks bad
                                        " in the loclist window.
                                        let l:filename = l:old_item.filename
                                        let l:item.filename = l:filename
                            
                                        if has_key(l:old_item, 'bufnr')
                                            " If a buffer number is also given, include that too.
                                            " If Vim detects that he buffer number is valid, it will
                                            " be used instead of the filename.
                                            let l:item.bufnr = l:old_item.bufnr
                                        elseif has_key(l:bufnr_map, l:filename)
                                            " Get the buffer number from the map, which can be faster.
                                            let l:item.bufnr = l:bufnr_map[l:filename]
                                        else
                                            " Look up the buffer number.
                                            let l:item.bufnr = bufnr(l:filename)
                                            let l:bufnr_map[l:filename] = l:item.bufnr
                                        endif
                                    elseif has_key(l:old_item, 'bufnr')
                                        let l:item.bufnr = l:old_item.bufnr
                                    endif
                            
   12              0.000053         if has_key(l:old_item, 'detail')
                                        let l:item.detail = l:old_item.detail
                                    endif
                            
                                    " Pass on a end_col key if set, used for highlights.
   12              0.000055         if has_key(l:old_item, 'end_col')
   11              0.000094             let l:item.end_col = str2nr(l:old_item.end_col)
   11              0.000018         endif
                            
   12              0.000084         if has_key(l:old_item, 'end_lnum')
   11              0.000084             let l:item.end_lnum = str2nr(l:old_item.end_lnum)
   11              0.000017         endif
                            
   12              0.000052         if has_key(l:old_item, 'sub_type')
                                        let l:item.sub_type = l:old_item.sub_type
                                    endif
                            
   12              0.000035         if l:item.lnum < 1
                                        " When errors appear before line 1, put them at line 1.
                                        let l:item.lnum = 1
                                    elseif l:item.bufnr == a:buffer && l:item.lnum > l:last_line_number
                                        " When errors go beyond the end of the file, put them at the end.
                                        " This is only done for the current buffer.
                                        let l:item.lnum = l:last_line_number
                                    elseif get(l:old_item, 'vcol', 0)
                                        " Convert virtual column positions to byte positions.
                                        " The positions will be off if the buffer has changed recently.
                                        let l:line = getbufline(a:buffer, l:item.lnum)[0]
                            
                                        let l:item.col = ale#util#Col(l:line, l:item.col)
                            
                                        if has_key(l:item, 'end_col')
                                            let l:end_line = get(l:item, 'end_lnum', l:line) != l:line   ? getbufline(a:buffer, l:item.end_lnum)[0]   : l:line
                            
                                            let l:item.end_col = ale#util#Col(l:end_line, l:item.end_col)
                                        endif
                                    endif
                            
   12              0.000075         call add(l:new_loclist, l:item)
   12              0.000029     endfor
                            
    7   0.000388   0.000160     let l:type_map = get(ale#Var(a:buffer, 'type_map'), a:linter_name, {})
                            
    7              0.000032     if !empty(l:type_map)
                                    call s:RemapItemTypes(l:type_map, l:new_loclist)
                                endif
                            
    7              0.000020     return l:new_loclist

FUNCTION  GetTypescriptIndent()
Called 1 time
Total time:   0.001284
 Self time:   0.000516

count  total (s)   self (s)
    1              0.000007   let b:js_cache = get(b:,'js_cache',[0,0,0])
                              " Get the current line.
    1              0.000005   call cursor(v:lnum,1)
    1              0.000004   let l:line = getline('.')
                              " use synstack as it validates syn state and works in an empty line
    1              0.000120   let s:stack = synstack(v:lnum,1)
    1              0.000005   let syns = synIDattr(get(s:stack,-1),'name')
                            
                              " start with strings,comments,etc.
    1              0.000007   if syns =~? s:syng_com
                            	if l:line =~ '^\s*\*'
                            	  return cindent(v:lnum)
                            	elseif l:line !~ '^\s*\/[/*]'
                            	  return -1
                            	endif
                              elseif syns =~? s:syng_str && l:line !~ '^[''"]'
                            	if b:js_cache[0] == v:lnum - 1 && s:Balanced(v:lnum-1)
                            	  let b:js_cache[0] = v:lnum
                            	endif
                            	return -1
                              endif
    1   0.000062   0.000018   let l:lnum = s:PrevCodeLine(v:lnum - 1)
    1              0.000001   if !l:lnum
                            	return
                              endif
                            
    1              0.000008   let l:line = substitute(l:line,'^\s*','','')
    1              0.000003   if l:line[:1] == '/*'
                            	let l:line = substitute(l:line,'^\%(\/\*.\{-}\*\/\s*\)*','','')
                              endif
    1              0.000004   if l:line =~ '^\/[/*]'
                            	let l:line = ''
                              endif
                            
                              " the containing paren, bracket, or curly. Many hacks for performance
    1              0.000006   let idx = index([']',')','}'],l:line[0])
    1              0.000006   if b:js_cache[0] >= l:lnum && b:js_cache[0] < v:lnum && (b:js_cache[0] > l:lnum || s:Balanced(l:lnum))
                            	call call('cursor',b:js_cache[1:])
                              else
    1   0.000049   0.000035 	let [s:looksyn, s:free, top] = [v:lnum - 1, 1, (!indent(l:lnum) && s:syn_at(l:lnum,1) !~? s:syng_str) * l:lnum]
    1              0.000002 	if idx + 1
                            	  call s:GetPair(['\[','(','{'][idx],'])}'[idx],'bW','s:skip_func()',2000,top)
                            	elseif getline(v:lnum) !~ '^\S' && syns =~? 'block'
                            	  call s:GetPair('{','}','bW','s:skip_func()',2000,top)
                            	else
    1   0.000171   0.000017 	  call s:alternatePair(top)
    1              0.000001 	endif
    1              0.000001   endif
                            
    1              0.000013   let b:js_cache = [v:lnum] + (line('.') == v:lnum ? [0,0] : getpos('.')[1:2])
    1              0.000004   let num = b:js_cache[1]
                            
    1   0.000026   0.000021   let [s:W, isOp, bL, switch_offset] = [s:sw(),0,0,0]
    1              0.000005   if !num || s:IsBlock()
    1              0.000004 	let ilnum = line('.')
    1   0.000196   0.000018 	let pline = s:save_pos('s:Trim',l:lnum)
    1              0.000005 	if num && s:looking_at() == ')' && s:GetPair('(', ')', 'bW', s:skip_expr, 100) > 0
                            	  let num = ilnum == num ? line('.') : num
                            	  if idx < 0 && s:previous_token() ==# 'switch' && s:previous_token() != '.'
                            		if &cino !~ ':'
                            		  let switch_offset = s:W
                            		else
                            		  let cinc = matchlist(&cino,'.*:\zs\(-\)\=\(\d*\)\(\.\d\+\)\=\(s\)\=\C')
                            		  let switch_offset = max([cinc[0] is '' ? 0 : (cinc[1].1) * ((strlen(cinc[2].cinc[3]) ? str2nr(cinc[2].str2nr(cinc[3][1])) : 10) * (cinc[4] is '' ? 1 : s:W)) / 10, -indent(num)])
                            		endif
                            		if pline[-1:] != '.' && l:line =~# '^\%(default\|case\)\>'
                            		  return indent(num) + switch_offset
                            		endif
                            	  endif
                            	endif
    1              0.000006 	if idx < 0 && pline !~ '[{;]$'
    1              0.000006 	  if pline =~# ':\@<!:$'
                            		call cursor(l:lnum,strlen(pline))
                            		let isOp = s:tern_col(b:js_cache[1:2]) * s:W
                            	  else
    1   0.000080   0.000042 		let isOp = (l:line =~# s:opfirst || s:continues(l:lnum,pline)) * s:W
    1              0.000002 	  endif
    1   0.000357   0.000022 	  let bL = s:iscontOne(l:lnum,b:js_cache[1],isOp)
    1              0.000003 	  let bL -= (bL && l:line[0] == '{') * s:W
    1              0.000001 	endif
    1              0.000001   endif
                            
                              " main return
    1              0.000003   if idx + 1 || l:line[:1] == '|}'
                            	return indent(num)
                              elseif num
                            	return indent(num) + s:W + switch_offset + bL + isOp
                              endif
    1              0.000001   return bL + isOp

FUNCTION  ale#util#GetItemPriority()
Called 20 times
Total time:   0.000905
 Self time:   0.000905

count  total (s)   self (s)
   20              0.000101     if a:item.type is# 'I'
                                    return g:ale#util#info_priority
                                endif
                            
   20              0.000110     if a:item.type is# 'W'
                                    if get(a:item, 'sub_type', '') is# 'style'
                                        return g:ale#util#style_warning_priority
                                    endif
                            
                                    return g:ale#util#warning_priority
                                endif
                            
   20              0.000124     if get(a:item, 'sub_type', '') is# 'style'
                                    return g:ale#util#style_error_priority
                                endif
                            
   20              0.000056     return g:ale#util#error_priority

FUNCTION  ale#cursor#TruncatedEcho()
Called 1 time
Total time:   0.000402
 Self time:   0.000383

count  total (s)   self (s)
    1              0.000005     let l:message = a:original_message
                                " Change tabs to spaces.
    1              0.000011     let l:message = substitute(l:message, "\t", ' ', 'g')
                                " Remove any newlines in the message.
    1              0.000009     let l:message = substitute(l:message, "\n", '', 'g')
                            
                                " We need to remember the setting for shortmess and reset it again.
    1              0.000005     let l:shortmess_options = &l:shortmess
                            
    1              0.000002     try
    1              0.000006         let l:cursor_position = getpos('.')
                            
                                    " The message is truncated and saved to the history.
    1   0.000028   0.000019         silent! setlocal shortmess+=T
                            
    1              0.000002         try
    1              0.000255             exec "norm! :echomsg l:message\n"
    1              0.000003         catch /^Vim\%((\a\+)\)\=:E523/
                                        " Fallback into manual truncate (#1987)
                                        let l:winwidth = winwidth(0)
                            
                                        if l:winwidth < strdisplaywidth(l:message)
                                            " Truncate message longer than window width with trailing '...'
                                            let l:message = l:message[:l:winwidth - 4] . '...'
                                        endif
                            
                                        exec 'echomsg l:message'
                                    endtry
                            
                                    " Reset the cursor position if we moved off the end of the line.
                                    " Using :norm and :echomsg can move the cursor off the end of the
                                    " line.
    1              0.000009         if l:cursor_position != getpos('.')
                                        call setpos('.', l:cursor_position)
                                    endif
    1              0.000002     finally
    1   0.000021   0.000012         let &l:shortmess = l:shortmess_options
    1              0.000002     endtry

FUNCTION  ale#engine#RunLinters()
Called 2 times
Total time:   0.033282
 Self time:   0.000894

count  total (s)   self (s)
                                " Initialise the buffer information if needed.
    2   0.000081   0.000035     let l:new_buffer = ale#engine#InitBufferInfo(a:buffer)
    2   0.000270   0.000037     call s:StopCurrentJobs(a:buffer, a:should_lint_file)
    2   0.000224   0.000050     call s:RemoveProblemsForDisabledLinters(a:buffer, a:linters)
                            
                                " We can only clear the results if we aren't checking the buffer.
    2   0.000071   0.000030     let l:can_clear_results = !ale#engine#IsCheckingBuffer(a:buffer)
                            
    2   0.000179   0.000138     silent doautocmd <nomodeline> User ALELintPre
                            
   12              0.000080     for l:linter in a:linters
                                    " Only run lint_file linters if we should.
   10              0.000044         if !l:linter.lint_file || a:should_lint_file
   10   0.032046   0.000195             if s:RunLinter(a:buffer, l:linter)
                                            " If a single linter ran, we shouldn't clear everything.
    4              0.000021                 let l:can_clear_results = 0
    4              0.000007             endif
   10              0.000013         else
                                        " If we skipped running a lint_file linter still in the list,
                                        " we shouldn't clear everything.
                                        let l:can_clear_results = 0
                                    endif
   10              0.000018     endfor
                            
                                " Clear the results if we can. This needs to be done when linters are
                                " disabled, or ALE itself is disabled.
    2              0.000006     if l:can_clear_results
                                    call ale#engine#SetResults(a:buffer, [])
                                elseif l:new_buffer
                                    call s:AddProblemsFromOtherBuffers(a:buffer, a:linters)
                                endif

FUNCTION  gitgutter#utility#setbufvar()
Called 24 times
Total time:   0.000964
 Self time:   0.000964

count  total (s)   self (s)
   24              0.000091   let buffer = +a:buffer
                              " Default value for getbufvar() was introduced in Vim 7.3.831.
   24              0.000119   let bvars = getbufvar(buffer, '')
   24              0.000077   if empty(bvars)
                                let bvars = {}
                              endif
   24              0.000127   let dict = get(bvars, 'gitgutter', {})
   24              0.000098   let needs_setting = empty(dict)
   24              0.000155   let dict[a:varname] = a:val
   24              0.000044   if needs_setting
                                call setbufvar(buffer, 'gitgutter', dict)
                              endif

FUNCTION  nerdtree#has_opt()
Called 60 times
Total time:   0.000510
 Self time:   0.000510

count  total (s)   self (s)
   60              0.000452     return has_key(a:options, a:name) && a:options[a:name] == 1

FUNCTION  <SNR>39_FileUpdate()
Called 1 time
Total time:   0.101504
 Self time:   0.000442

count  total (s)   self (s)
    1              0.000006     if g:NERDTreeUpdateOnWrite != 1
                                    return
                                endif
                            
    1   0.000084   0.000021     if !g:NERDTree.IsOpen()
                                    return
                                endif
                            
    1              0.000007     let l:winnr = winnr()
    1              0.000005     let l:altwinnr = winnr('#')
                            
    1   0.000314   0.000018     call g:NERDTree.CursorToTreeWin()
    1   0.011691   0.000107     let l:node = b:NERDTree.root.findNode(g:NERDTreePath.New(a:fname))
    1              0.000005     if l:node == {}
                                    return
                                endif
    1   0.064212   0.000038     call l:node.refreshFlags()
    1              0.000010     let l:node = l:node.parent
    3              0.000015     while !empty(l:node)
    2   0.002733   0.000031         call l:node.refreshDirFlags()
    2              0.000014         let l:node = l:node.parent
    2              0.000009     endwhile
                            
    1   0.022270   0.000029     call NERDTreeRender()
                            
    1              0.000013     exec l:altwinnr . 'wincmd w'
    1              0.000081     exec l:winnr . 'wincmd w'

FUNCTION  <SNR>165_find_current_signs()
Called 2 times
Total time:   0.003778
 Self time:   0.003524

count  total (s)   self (s)
    2              0.000009   let gitgutter_signs = {}  " <line_number (string)>: {'id': <id (number)>, 'name': <name (string)>}
    2              0.000007   let other_signs = []      " [<line_number (number),...]
    2              0.000008   let dummy_sign_placed = 0
                            
    2              0.000011   redir => signs
    2              0.000170     silent execute "sign place buffer=" . a:bufnr
    2              0.000013   redir END
                            
   27              0.000257   for sign_line in filter(split(signs, '\n')[2:], 'v:val =~# "="')
                                " Typical sign line:  line=88 id=1234 name=GitGutterLineAdded
                                " We assume splitting is faster than a regexp.
   25              0.000671     let components  = split(sign_line)
   25              0.000324     let name        = split(components[2], '=')[1]
   25              0.000196     if name =~# 'GitGutterDummy'
                                  let dummy_sign_placed = 1
                                else
   25              0.000363       let line_number = str2nr(split(components[0], '=')[1])
   25              0.000178       if name =~# 'GitGutter'
   20              0.000243         let id = str2nr(split(components[1], '=')[1])
                                    " Remove orphaned signs (signs placed on lines which have been deleted).
                                    " (When a line is deleted its sign lingers.  Subsequent lines' signs'
                                    " line numbers are decremented appropriately.)
   20              0.000116         if has_key(gitgutter_signs, line_number)
                                      execute "sign unplace" gitgutter_signs[line_number].id
                                    endif
   20              0.000162         let gitgutter_signs[line_number] = {'id': id, 'name': name}
   20              0.000028       else
    5              0.000027         call add(other_signs, line_number)
    5              0.000009       endif
   25              0.000024     end
   25              0.000029   endfor
                            
    2   0.000108   0.000031   call gitgutter#utility#setbufvar(a:bufnr, 'dummy_sign', dummy_sign_placed)
    2   0.000134   0.000027   call gitgutter#utility#setbufvar(a:bufnr, 'gitgutter_signs', gitgutter_signs)
    2   0.000093   0.000022   call gitgutter#utility#setbufvar(a:bufnr, 'other_signs', other_signs)

FUNCTION  airline#builder#should_change_group()
Called 36 times
Total time:   0.023932
 Self time:   0.001902

count  total (s)   self (s)
   36              0.000162   if a:group1 == a:group2
                                return 0
                              endif
   36   0.011724   0.000501   let color1 = airline#highlighter#get_highlight(a:group1)
   36   0.011316   0.000510   let color2 = airline#highlighter#get_highlight(a:group2)
   36              0.000127   if g:airline_gui_mode ==# 'gui'
                                return color1[1] != color2[1] || color1[0] != color2[0]
                              else
   36              0.000204     return color1[3] != color2[3] || color1[2] != color2[2]
                              endif

FUNCTION  <SNR>93_update_untracked()
Called 639 times
Total time:   0.217660
 Self time:   0.182338

count  total (s)   self (s)
  639              0.076776   let file = expand("%:p")
  639              0.014832   if empty(file) || isdirectory(file) || !empty(&buftype)
                                return
                              endif
                            
  639              0.002588   let needs_update = 1
  639              0.006369   let vcs_checks   = get(g:, "airline#extensions#branch#vcs_checks", ["untracked", "dirty"])
 1917              0.008453   for vcs in keys(s:vcs_config)
 1278              0.014748     if file =~ s:vcs_config[vcs].exclude
                                  " Skip check for files that live in the exclude directory
                                  let needs_update = 0
                                endif
 1278              0.008913     if has_key(s:vcs_config[vcs].untracked, file)
  635              0.002133       let needs_update = 0
  635   0.028450   0.009827       call airline#extensions#branch#update_untracked_config(file, vcs)
  635              0.000922     endif
 1278              0.002111   endfor
                            
  639              0.001557   if !needs_update
  635              0.000955     return
                              endif
                            
   12              0.000074   for vcs in keys(s:vcs_config)
                                " only check, for git, if fugitive is installed
                                " and for 'hg' if lawrencium is installed, else skip
    8   0.000130   0.000087     if vcs is# 'git' && !airline#util#has_fugitive()
                                  continue
                                elseif vcs is# 'mercurial' && !airline#util#has_lawrencium()
    4              0.000011       continue
                                endif
    4              0.000021     let config = s:vcs_config[vcs]
                                " Note that asynchronous update updates s:vcs_config only, and only
                                " s:update_untracked updates b:buffer_vcs_config. If s:vcs_config is
                                " invalidated again before s:update_untracked is called, then we lose the
                                " result of the previous call, i.e. the head string is not updated. It
                                " doesn't happen often in practice, so we let it be.
    4              0.000028     if index(vcs_checks, 'untracked') > -1
    4   0.005191   0.000108       call airline#async#vcs_untracked(config, file, vcs)
    4              0.000007     endif
                                " Check clean state of repo
    4              0.000030     if index(vcs_checks, 'dirty') > -1
    4   0.011660   0.000127       call airline#async#vcs_clean(config.dirty, file, vcs)
    4              0.000026     endif
    4              0.000009   endfor

FUNCTION  <SNR>129_previous_token()
Called 2 times
Total time:   0.000242
 Self time:   0.000170

count  total (s)   self (s)
    2              0.000013   let l:n = line('.')
    2   0.000070   0.000052   if (s:looking_at() !~ '\k' || search('\m\<','cbW')) && search('\m\S','bW')
    2              0.000052 	if (getline('.')[col('.')-2:col('.')-1] == '*/' || line('.') != l:n && getline('.') =~ '\%<'.col('.').'c\/\/') && s:syn_at(line('.'),col('.')) =~? s:syng_com
                            	  while search('\m\/\ze[/*]','cbW')
                            		if !search('\m\S','bW')
                            		  break
                            		elseif s:syn_at(line('.'),col('.')) !~? s:syng_com
                            		  return s:token()
                            		endif
                            	  endwhile
                            	else
    2   0.000068   0.000014 	  return s:token()
                            	endif
                              endif
                              return ''

FUNCTION  airline#highlighter#exec()
Called 824 times
Total time:   0.371775
 Self time:   0.089370

count  total (s)   self (s)
  824              0.002705   if pumvisible()
                                return
                              endif
  824              0.002394   let colors = a:colors
  824              0.001499   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
                              endif
  824   0.217618   0.010457   let old_hi = airline#highlighter#get_highlight(a:group)
  824              0.003080   if len(colors) == 4
  335              0.001377     call add(colors, '')
  335              0.000345   endif
  824              0.002259   if g:airline_gui_mode ==# 'gui'
                                let new_hi = [colors[0], colors[1], '', '', colors[4]]
                              else
  824              0.009956     let new_hi = ['', '', printf("%s", colors[2]), printf("%s", colors[3]), colors[4]]
  824              0.001026   endif
  824   0.050029   0.008576   let colors = s:CheckDefined(colors)
  824   0.030777   0.009268   if old_hi != new_hi || !s:hl_group_exists(a:group)
   84   0.013307   0.001025     let cmd = printf('hi %s%s', a:group, s:GetHiCmd(colors))
   84              0.001402     exe cmd
   84              0.000416     if has_key(s:hl_groups, a:group)
   84              0.000314       let s:hl_groups[a:group] = colors
   84              0.000081     endif
   84              0.000055   endif

FUNCTION  <SNR>118_Slash()
Called 3834 times
Total time:   0.056691
 Self time:   0.056691

count  total (s)   self (s)
 3834              0.022817   if exists('+shellslash')
                                return tr(a:path, '\', '/')
                              else
 3834              0.009187     return a:path
                              endif

FUNCTION  ale#util#FindItemAtCursor()
Called 4 times
Total time:   0.001015
 Self time:   0.000221

count  total (s)   self (s)
    4              0.000036     let l:info = get(g:ale_buffer_info, a:buffer, {})
    4              0.000027     let l:loclist = get(l:info, 'loclist', [])
    4              0.000024     let l:pos = getpos('.')
    4   0.000874   0.000080     let l:index = ale#util#BinarySearch(l:loclist, a:buffer, l:pos[1], l:pos[2])
    4              0.000025     let l:loc = l:index >= 0 ? l:loclist[l:index] : {}
                            
    4              0.000016     return [l:info, l:loc]

FUNCTION  ale#lsp#ReadMessageData()
Called 8 times
Total time:   0.004250
 Self time:   0.004250

count  total (s)   self (s)
    8              0.000039     let l:response_list = []
    8              0.000034     let l:remainder = a:data
                            
   20              0.000045     while 1
                                    " Look for the end of the HTTP headers
   20              0.000307         let l:body_start_index = matchend(l:remainder, "\r\n\r\n")
                            
   20              0.000066         if l:body_start_index < 0
                                        " No header end was found yet.
    8              0.000016             break
                                    endif
                            
                                    " Parse the Content-Length header.
   12              0.000087         let l:header_data = l:remainder[:l:body_start_index - 4]
   12              0.001902         let l:length_match = matchlist(   l:header_data,   '\vContent-Length: *(\d+)')
                            
   12              0.000068         if empty(l:length_match)
                                        throw "Invalid JSON-RPC header:\n" . l:header_data
                                    endif
                            
                                    " Split the body and the remainder of the text.
   12              0.000107         let l:remainder_start_index = l:body_start_index + str2nr(l:length_match[1])
                            
   12              0.000095         if len(l:remainder) < l:remainder_start_index
                                        " We don't have enough data yet.
                                        break
                                    endif
                            
   12              0.000085         let l:body = l:remainder[l:body_start_index : l:remainder_start_index - 1]
   12              0.000078         let l:remainder = l:remainder[l:remainder_start_index :]
                            
                                    " Parse the JSON object and add it to the list.
   12              0.000498         call add(l:response_list, json_decode(l:body))
   12              0.000035     endwhile
                            
    8              0.000040     return [l:remainder, l:response_list]

FUNCTION  airline#extensions#whitespace#check()
Called 639 times
Total time:   0.221333
 Self time:   0.183812

count  total (s)   self (s)
  639              0.005223   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
  639              0.007635   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
                              endif
  639              0.013365   let skip_check_ft = extend(s:skip_check_ft, get(g:, 'airline#extensions#whitespace#skip_indent_check_ft', {}), 'force')
                            
  639              0.004302   if !exists('b:airline_whitespace_check')
    1              0.000008     let b:airline_whitespace_check = ''
    1              0.000012     let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
    1              0.000004     let trailing = 0
    1              0.000003     let check = 'trailing'
    1              0.000019     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    1              0.000003       try
    1              0.000008         let regexp = get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$')
    1              0.000230         let trailing = search(regexp, 'nw')
    1              0.000003       catch
                                    call airline#util#warning(printf('Whitespace: error occurred evaluating "%s"', regexp))
                                    echomsg v:exception
                                    return ''
                                  endtry
    1              0.000001     endif
                            
    1              0.000004     let mixed = 0
    1              0.000003     let check = 'indent'
    1              0.000018     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    1   0.000978   0.000036       let mixed = s:check_mixed_indent()
    1              0.000004     endif
                            
    1              0.000008     let mixed_file = ''
    1              0.000004     let check = 'mixed-indent-file'
    1              0.000027     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    1   0.000239   0.000053       let mixed_file = s:check_mixed_indent_file()
    1              0.000002     endif
                            
    1              0.000003     let long = 0
    1              0.000006     if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
                                endif
                            
    1              0.000003     let conflicts = 0
    1              0.000005     if index(checks, 'conflicts') > -1
    1   0.000483   0.000028       let conflicts = s:conflict_marker()
    1              0.000002     endif
                            
    1              0.000007     if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file) || conflicts != 0
    1              0.000006       let b:airline_whitespace_check = s:symbol
    1              0.000005       if strlen(s:symbol) > 0
    1              0.000005         let space = (g:airline_symbols.space)
    1              0.000002       else
                                    let space = ''
                                  endif
                            
    1              0.000003       if s:show_message
    1              0.000002         if trailing != 0
    1              0.000009           let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
    1              0.000014           let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
    1              0.000002         endif
    1              0.000003         if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
                                    endif
    1              0.000003         if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
                                    endif
    1              0.000005         if !empty(mixed_file)
    1              0.000009           let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
    1              0.000012           let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
    1              0.000002         endif
    1              0.000003         if conflicts != 0
                                      let conflicts_fmt = get(g:, 'airline#extensions#whitespace#conflicts_format', '[%s]conflicts')
                                      let b:airline_whitespace_check .= space.printf(conflicts_fmt, conflicts)
                                    endif
    1              0.000001       endif
    1              0.000001     endif
    1              0.000001   endif
  639   0.044597   0.008659   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  NERDTreeGitStatusRefresh()
Called 1 time
Total time:   0.062571
 Self time:   0.001043

count  total (s)   self (s)
    1              0.000019     let b:NERDTreeCachedGitFileStatus = {}
    1              0.000006     let b:NERDTreeCachedGitDirtyDir   = {}
    1              0.000004     let b:NOT_A_GIT_REPOSITORY        = 1
                            
    1   0.000301   0.000052     let l:root = fnamemodify(b:NERDTree.root.path.str(), ':p:gs?\\?/?:S')
    1              0.000006     let l:gitcmd = 'git -c color.status=false status -s'
    1              0.000003     if g:NERDTreeShowIgnoredStatus
                                    let l:gitcmd = l:gitcmd . ' --ignored'
                                endif
    1              0.000006     if exists('g:NERDTreeGitStatusIgnoreSubmodules')
                                    let l:gitcmd = l:gitcmd . ' --ignore-submodules'
                                    if g:NERDTreeGitStatusIgnoreSubmodules ==# 'all' || g:NERDTreeGitStatusIgnoreSubmodules ==# 'dirty' || g:NERDTreeGitStatusIgnoreSubmodules ==# 'untracked'
                                        let l:gitcmd = l:gitcmd . '=' . g:NERDTreeGitStatusIgnoreSubmodules
                                    endif
                                endif
    1   0.060593   0.000049     let l:statusesStr = system(l:gitcmd . ' ' . l:root)
    1              0.000062     let l:statusesSplit = split(l:statusesStr, '\n')
    1              0.000025     if l:statusesSplit != [] && l:statusesSplit[0] =~# 'fatal:.*'
                                    let l:statusesSplit = []
                                    return
                                endif
    1              0.000004     let b:NOT_A_GIT_REPOSITORY = 0
                            
    5              0.000019     for l:statusLine in l:statusesSplit
                                    " cache git status of files
    4              0.000074         let l:pathStr = substitute(l:statusLine, '...', '', '')
    4              0.000051         let l:pathSplit = split(l:pathStr, ' -> ')
    4              0.000024         if len(l:pathSplit) == 2
                                        call s:NERDTreeCacheDirtyDir(l:pathSplit[0])
                                        let l:pathStr = l:pathSplit[1]
                                    else
    4              0.000018             let l:pathStr = l:pathSplit[0]
    4              0.000006         endif
    4   0.000218   0.000095         let l:pathStr = s:NERDTreeTrimDoubleQuotes(l:pathStr)
    4              0.000050         if l:pathStr =~# '\.\./.*'
                                        continue
                                    endif
    4   0.000191   0.000095         let l:statusKey = s:NERDTreeGetFileGitStatusKey(l:statusLine[0], l:statusLine[1])
    4              0.000050         let b:NERDTreeCachedGitFileStatus[fnameescape(l:pathStr)] = l:statusKey
                            
    4              0.000016         if l:statusKey == 'Ignored'
                                        if isdirectory(l:pathStr)
                                            let b:NERDTreeCachedGitDirtyDir[fnameescape(l:pathStr)] = l:statusKey
                                        endif
                                    else
    4   0.000587   0.000074             call s:NERDTreeCacheDirtyDir(l:pathStr)
    4              0.000007         endif
    4              0.000006     endfor

FUNCTION  <SNR>129_skip_func()
Called 1 time
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    1              0.000009   if !s:free || search('\m`\|\${\|\*\/','nW',s:looksyn)
                            	let s:free = !eval(s:skip_expr)
                            	let s:looksyn = line('.')
                            	return !s:free
                              endif
    1              0.000003   let s:looksyn = line('.')
    1              0.000016   return getline('.') =~ '\%<'.col('.').'c\/.\{-}\/\|\%>'.col('.').'c[''"]\|\\$' && eval(s:skip_expr)

FUNCTION  airline#extensions#tabline#formatters#default#format()
Called 15 times
Total time:   0.003827
 Self time:   0.003247

count  total (s)   self (s)
   15              0.000095   let fmod = get(g:, 'airline#extensions#tabline#fnamemod', ':~:.')
   15              0.000035   let _ = ''
                            
   15              0.000068   let name = bufname(a:bufnr)
   15              0.000049   if empty(name)
                                let _ .= '[No Name]'
                              else
   15              0.000027     if s:fnamecollapse
                                  " Does not handle non-ascii characters like Cyrillic: 'D/Учёба/t.c'
                                  "let _ .= substitute(fnamemodify(name, fmod), '\v\w\zs.{-}\ze(\\|/)', '', 'g')
   15              0.002308       let _ .= pathshorten(fnamemodify(name, fmod))
   15              0.000033     else
                                  let _ .= fnamemodify(name, fmod)
                                endif
   15              0.000107     if a:bufnr != bufnr('%') && s:fnametruncate && strlen(_) > s:fnametruncate
                                  let _ = strpart(_, 0, s:fnametruncate)
                                endif
   15              0.000016   endif
                            
   15   0.000800   0.000220   return airline#extensions#tabline#formatters#default#wrap_name(a:bufnr, _)

FUNCTION  nerdtree#exec()
Called 1 time
Total time:   0.000144
 Self time:   0.000144

count  total (s)   self (s)
    1              0.000014     let old_ei = &ei
    1              0.000017     set ei=BufEnter,BufLeave,VimEnter
    1              0.000092     exec a:cmd
    1              0.000018     let &ei = old_ei

FUNCTION  ale#lsp#CreateMessageData()
Called 4 times
Total time:   0.000732
 Self time:   0.000153

count  total (s)   self (s)
    4              0.000024     if a:message[1][:2] is# 'ts@'
    4   0.000699   0.000120         return s:CreateTSServerMessageData(a:message)
                                endif
                            
                                let l:is_notification = a:message[0]
                            
                                let l:obj = {   'method': a:message[1],   'jsonrpc': '2.0',}
                            
                                if !l:is_notification
                                    let l:obj.id = ale#lsp#GetNextMessageID()
                                endif
                            
                                if len(a:message) > 2
                                    let l:obj.params = a:message[2]
                                endif
                            
                                let l:body = json_encode(l:obj)
                                let l:data = 'Content-Length: ' . strlen(l:body) . "\r\n\r\n" . l:body
                            
                                return [l:is_notification ? 0 : l:obj.id, l:data]

FUNCTION  <SNR>148_RunJob()
Called 2 times
Total time:   0.011044
 Self time:   0.000518

count  total (s)   self (s)
    2   0.000029   0.000017     if ale#command#IsDeferred(a:command)
                                    let a:command.result_callback = {   command -> s:RunJob(command, a:options)}
                            
                                    return 1
                                endif
                            
    2              0.000005     let l:command = a:command
                            
    2              0.000005     if empty(l:command)
                                    return 0
                                endif
                            
    2              0.000006     let l:executable = a:options.executable
    2              0.000004     let l:buffer = a:options.buffer
    2              0.000004     let l:linter = a:options.linter
    2              0.000005     let l:output_stream = a:options.output_stream
    2              0.000005     let l:next_chain_index = a:options.next_chain_index
    2              0.000005     let l:read_buffer = a:options.read_buffer
    2              0.000008     let l:info = g:ale_buffer_info[l:buffer]
                            
    2              0.000028     let l:Callback = function('s:HandleExit', [{   'linter': l:linter,   'executable': l:executable,   'next_chain_index': l:next_chain_index,}])
    2   0.010135   0.000090     let l:result = ale#command#Run(l:buffer, l:command, l:Callback, {   'output_stream': l:output_stream,   'executable': l:executable,   'read_buffer': l:read_buffer,   'log_output': l:next_chain_index >= len(get(l:linter, 'command_chain', [])),})
                            
                                " Only proceed if the job is being run.
    2              0.000011     if empty(l:result)
                                    return 0
                                endif
                            
    2   0.000164   0.000070     call ale#engine#MarkLinterActive(l:info, l:linter)
                            
    2   0.000564   0.000189     silent doautocmd <nomodeline> User ALEJobStarted
                            
    2              0.000012     return 1

FUNCTION  ale#util#StartPartialTimer()
Called 4 times
Total time:   0.000150
 Self time:   0.000150

count  total (s)   self (s)
    4              0.000079     let l:timer_id = timer_start(a:delay, function('s:ApplyPartialTimer'))
    4              0.000045     let s:partial_timers[l:timer_id] = [a:callback, a:args]
                            
    4              0.000013     return l:timer_id

FUNCTION  <SNR>155_HandleTSServerDiagnostics()
Called 6 times
Total time:   0.052608
 Self time:   0.001571

count  total (s)   self (s)
    6              0.000032     let l:linter_name = 'tsserver'
    6              0.000358     let l:buffer = bufnr('^' . a:response.body.file . '$')
    6              0.000068     let l:info = get(g:ale_buffer_info, l:buffer, {})
                            
    6              0.000026     if empty(l:info)
                                    return
                                endif
                            
    6   0.000285   0.000166     call ale#engine#MarkLinterInactive(l:info, l:linter_name)
                            
    6   0.000742   0.000101     if s:ShouldIgnore(l:buffer, l:linter_name)
                                    return
                                endif
                            
    6   0.001181   0.000121     let l:thislist = ale#lsp#response#ReadTSServerDiagnostics(a:response)
    6              0.000024     let l:no_changes = 0
                            
                                " tsserver sends syntax and semantic errors in separate messages, so we
                                " have to collect the messages separately for each buffer and join them
                                " back together again.
    6              0.000026     if a:error_type is# 'syntax'
    3              0.000025         if len(l:thislist) is 0 && len(get(l:info, 'syntax_loclist', [])) is 0
                                        let l:no_changes = 1
                                    endif
                            
    3              0.000049         let l:info.syntax_loclist = l:thislist
    3              0.000005     else
    3              0.000024         if len(l:thislist) is 0 && len(get(l:info, 'semantic_loclist', [])) is 0
                                        let l:no_changes = 1
                                    endif
                            
    3              0.000033         let l:info.semantic_loclist = l:thislist
    3              0.000005     endif
                            
    6              0.000014     if l:no_changes
                                    return
                                endif
                            
    6              0.000081     let l:loclist = get(l:info, 'semantic_loclist', [])   + get(l:info, 'syntax_loclist', [])
                            
    6   0.049363   0.000147     call ale#engine#HandleLoclist(l:linter_name, l:buffer, l:loclist, 0)

FUNCTION  ale#command#InitData()
Called 9 times
Total time:   0.000191
 Self time:   0.000191

count  total (s)   self (s)
    9              0.000094     if !has_key(s:buffer_data, a:buffer)
    2              0.000026         let s:buffer_data[a:buffer] = {   'jobs': {},   'file_list': [],   'directory_list': [],}
    2              0.000003     endif

FUNCTION  <SNR>162_nvim_untracked_job_handler()
Called 1 time
Total time:   0.000101
 Self time:   0.000057

count  total (s)   self (s)
    1              0.000006     if a:event == 'exit'
    1   0.000070   0.000026       call s:untracked_output(self, self.buf)
    1              0.000007       if has_key(s:untracked_jobs, self.file)
    1              0.000011         call remove(s:untracked_jobs, self.file)
    1              0.000002       endif
    1              0.000001     endif

FUNCTION  fugitive#ReloadStatus()
Called 2 times
Total time:   0.000884
 Self time:   0.000884

count  total (s)   self (s)
    2              0.000017   if exists('s:reloading_status')
                                return
                              endif
    2              0.000004   try
    2              0.000022     let s:reloading_status = 1
    2              0.000011     let mytab = tabpagenr()
    6              0.000047     for tab in [mytab] + range(1,tabpagenr('$'))
   12              0.000061       for winnr in range(1,tabpagewinnr(tab,'$'))
    8              0.000094         if getbufvar(tabpagebuflist(tab)[winnr-1],'fugitive_type') ==# 'index'
                                      execute 'tabnext '.tab
                                      if winnr != winnr()
                                        execute winnr.'wincmd w'
                                        let restorewinnr = 1
                                      endif
                                      try
                                        if !&modified
                                          exe s:ReloadStatus()
                                        endif
                                      finally
                                        if exists('restorewinnr')
                                          unlet restorewinnr
                                          wincmd p
                                        endif
                                        execute 'tabnext '.mytab
                                      endtry
                                    endif
    8              0.000012       endfor
    4              0.000005     endfor
    2              0.000004   finally
    2              0.000007     unlet! s:reloading_status
    2              0.000003   endtry

FUNCTION  ale#util#LocItemCompare()
Called 19 times
Total time:   0.001231
 Self time:   0.001231

count  total (s)   self (s)
   19              0.000081     if a:left.bufnr < a:right.bufnr
                                    return -1
                                endif
                            
   19              0.000054     if a:left.bufnr > a:right.bufnr
                                    return 1
                                endif
                            
   19              0.000044     if a:left.bufnr == -1
                                    if a:left.filename < a:right.filename
                                        return -1
                                    endif
                            
                                    if a:left.filename > a:right.filename
                                        return 1
                                    endif
                                endif
                            
   19              0.000058     if a:left.lnum < a:right.lnum
    6              0.000012         return -1
                                endif
                            
   13              0.000034     if a:left.lnum > a:right.lnum
    6              0.000010         return 1
                                endif
                            
    7              0.000020     if a:left.col < a:right.col
    6              0.000010         return -1
                                endif
                            
    1              0.000003     if a:left.col > a:right.col
    1              0.000002         return 1
                                endif
                            
                                " When either of the items lacks a problem type, then the two items should
                                " be considered equal. This is important for loclist jumping.
                                if !has_key(a:left, 'type') || !has_key(a:right, 'type')
                                    return 0
                                endif
                            
                                let l:left_priority = ale#util#GetItemPriority(a:left)
                                let l:right_priority = ale#util#GetItemPriority(a:right)
                            
                                if l:left_priority < l:right_priority
                                    return -1
                                endif
                            
                                if l:left_priority > l:right_priority
                                    return 1
                                endif
                            
                                return 0

FUNCTION  gitgutter#utility#repo_path()
Called 8 times
Total time:   0.000573
 Self time:   0.000247

count  total (s)   self (s)
    8   0.000434   0.000172   let p = gitgutter#utility#getbufvar(a:bufnr, 'path')
    8   0.000127   0.000065   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  <SNR>67_addtomrufs()
Called 1 time
Total time:   0.000375
 Self time:   0.000375

count  total (s)   self (s)
    1              0.000158 	let fn = fnamemodify(a:fname, get(g:, 'ctrlp_tilde_homedir', 0) ? ':p:~' : ':p')
    1              0.000014 	let fn = exists('+ssl') ? tr(fn, '/', '\') : fn
    1              0.000020 	let abs_fn = fnamemodify(fn,':p')
    1              0.000137 	if ( !empty({s:in}) && fn !~# {s:in} ) || ( !empty({s:ex}) && fn =~# {s:ex} ) || !empty(getbufvar('^' . abs_fn . '$', '&bt')) || !filereadable(abs_fn)
                            		retu
                            	en
    1              0.000014 	let idx = index(s:mrufs, fn, 0, !{s:cseno})
    1              0.000002 	if idx
                            		cal filter(s:mrufs, 'v:val !='.( {s:cseno} ? '#' : '?' ).' fn')
                            		cal insert(s:mrufs, fn)
                            		if {s:soup} && idx < 0
                            			cal s:savetofile(s:mergelists())
                            		en
                            	en

FUNCTION  <SNR>91_get_hunks_gitgutter()
Called 639 times
Total time:   0.067523
 Self time:   0.018095

count  total (s)   self (s)
  639   0.018757   0.009595   if !get(g:, 'gitgutter_enabled', 0) || s:is_branch_empty()
    4              0.000007     return ''
                              endif
  635   0.045858   0.005592   return GitGutterGetHunkSummary()

FUNCTION  <SNR>42_exists_file()
Called 2 times
Total time:   0.001519
 Self time:   0.001227

count  total (s)   self (s)
    2   0.001517   0.001224   return filereadable(s:abs_path(a:bufnr, 0))

FUNCTION  <SNR>166_syn_sol()
Called 2 times
Total time:   0.000203
 Self time:   0.000203

count  total (s)   self (s)
    2              0.000009   let line = getline(a:lnum)
    2              0.000019   let sol = matchstr(line, '^\s*')
    2              0.000172   return map(synstack(a:lnum, len(sol) + 1), 'synIDattr(v:val, "name")')

FUNCTION  ale#highlight#CreatePositions()
Called 20 times
Total time:   0.000289
 Self time:   0.000289

count  total (s)   self (s)
   20              0.000086     if a:line >= a:end_line
                                    " For single lines, just return the one position.
   20              0.000153         return [[[a:line, a:col, a:end_col - a:col + 1]]]
                                endif
                            
                                " Get positions from the first line at the first column, up to a large
                                " integer for highlighting up to the end of the line, followed by
                                " the lines in-between, for highlighting entire lines, and
                                " a highlight for the last line, up to the end column.
                                let l:all_positions =   [[a:line, a:col, s:MAX_COL_SIZE]]   + range(a:line + 1, a:end_line - 1)   + [[a:end_line, 1, a:end_col]]
                            
                                return map(   range(0, len(l:all_positions) - 1, s:MAX_POS_VALUES),   'l:all_positions[v:val : v:val + s:MAX_POS_VALUES - 1]',)

FUNCTION  jsx_pretty#comment#update_commentstring()
Called 4 times
Total time:   0.005692
 Self time:   0.000547

count  total (s)   self (s)
    4   0.002859   0.000118   let syn_current = s:syn_name(line('.'), col('.'))
    4   0.002476   0.000072   let syn_start = s:syn_name(line('.'), 1)
    4              0.000028   let save_cursor = getcurpos()
                            
    4              0.000046   if syn_start =~? '^jsx'
                                let line = getline(".")
                                let start = len(matchstr(line, '^\s*'))
                                let syn_name = s:syn_name(line('.'), start + 1)
                            
                                if line =~ '^\s*//'
                                  let &l:commentstring = '// %s'
                                elseif s:syn_contains(line('.'), col('.'), 'jsxTaggedRegion')
                                  let &l:commentstring = '<!-- %s -->'
                                elseif syn_name =~? '^jsxAttrib'
                                  let &l:commentstring = '// %s'
                                else
                                  let &l:commentstring = '{/* %s */}'
                                endif
                              else
    4              0.000075     let &l:commentstring = a:original
    4              0.000006   endif
                            
                              " Restore the cursor position
    4              0.000029   call setpos('.', save_cursor)

FUNCTION  <SNR>119_IdentifierFinishedOperations()
Called 421 times
Total time:   0.642392
 Self time:   0.019502

count  total (s)   self (s)
  421   0.628885   0.005996   if !s:Pyeval( 'base.CurrentIdentifierFinished()' )
  419              0.002088     return
                              endif
    2              0.010526   exec s:python_command "ycm_state.OnCurrentIdentifierFinished()"
    2              0.000026   let s:force_semantic = 0
    2              0.000019   let s:completion = s:default_completion

FUNCTION  nerdtree#renderView()
Called 1 time
Total time:   0.022218
 Self time:   0.000022

count  total (s)   self (s)
    1   0.022217   0.000021     call b:NERDTree.render()

FUNCTION  ale#command#ManageDirectory()
Called 4 times
Total time:   0.000168
 Self time:   0.000090

count  total (s)   self (s)
    4   0.000132   0.000054     call ale#command#InitData(a:buffer)
    4              0.000030     call add(s:buffer_data[a:buffer].directory_list, a:directory)

FUNCTION  ale#sign#FindCurrentSigns()
Called 7 times
Total time:   0.009383
 Self time:   0.000350

count  total (s)   self (s)
    7   0.001126   0.000181     let l:line_list = ale#sign#ReadSigns(a:buffer)
                            
    7   0.008236   0.000148     return ale#sign#ParseSigns(l:line_list)

FUNCTION  <SNR>166_syn_jsx_escapejs()
Called 2 times
Total time:   0.000067
 Self time:   0.000067

count  total (s)   self (s)
    2              0.000065   return get(a:syns, -1) =~? '\(\(js\(Template\)\?\|javaScript\(Embed\)\?\|typescript\)Braces\|javascriptTemplateSB\|typescriptInterpolationDelimiter\)' && (get(a:syns, -2) =~? 'jsxEscapeJs' || get(a:syns, -3) =~? 'jsxEscapeJs')

FUNCTION  ale#statusline#Update()
Called 7 times
Total time:   0.002907
 Self time:   0.002801

count  total (s)   self (s)
    7              0.000082     if !exists('g:ale_buffer_info') || !has_key(g:ale_buffer_info, a:buffer)
                                    return
                                endif
                            
    7              0.000114     let l:loclist = filter(copy(a:loclist), 'v:val.bufnr == a:buffer')
    7   0.000216   0.000110     let l:count = s:CreateCountDict()
    7              0.000045     let l:count.total = len(l:loclist)
                            
                                " Allows easy access to the first instance of each problem type.
    7              0.000028     let l:first_problems = {}
                            
   27              0.000081     for l:entry in l:loclist
   20              0.000076         if l:entry.type is# 'W'
                                        if get(l:entry, 'sub_type', '') is# 'style'
                                            let l:count.style_warning += 1
                            
                                            if l:count.style_warning == 1
                                                let l:first_problems.style_warning = l:entry
                                            endif
                                        else
                                            let l:count.warning += 1
                            
                                            if l:count.warning == 1
                                                let l:first_problems.warning = l:entry
                                            endif
                                        endif
                                    elseif l:entry.type is# 'I'
                                        let l:count.info += 1
                            
                                        if l:count.info == 1
                                            let l:first_problems.info = l:entry
                                        endif
                                    elseif get(l:entry, 'sub_type', '') is# 'style'
                                        let l:count.style_error += 1
                            
                                        if l:count.style_error == 1
                                            let l:first_problems.style_error = l:entry
                                        endif
                                    else
   20              0.000072             let l:count.error += 1
                            
   20              0.000063             if l:count.error == 1
    7              0.000032                 let l:first_problems.error = l:entry
    7              0.000010             endif
   20              0.000022         endif
   20              0.000030     endfor
                            
                                " Set keys for backwards compatibility.
    7              0.000061     let l:count[0] = l:count.error + l:count.style_error
    7              0.000047     let l:count[1] = l:count.total - l:count[0]
                            
    7              0.000080     let g:ale_buffer_info[a:buffer].count = l:count
    7              0.000056     let g:ale_buffer_info[a:buffer].first_problems = l:first_problems

FUNCTION  gitgutter#utility#windows()
Called 2 times
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
    2              0.000035   return has('win64') || has('win32') || has('win16')

FUNCTION  airline#parts#spell()
Called 639 times
Total time:   0.036276
 Self time:   0.036276

count  total (s)   self (s)
  639              0.016775   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
  639              0.003050   if g:airline_detect_spell && &spell
                                let winwidth = airline#util#winwidth()
                                if winwidth >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth >= 70
                                  return g:airline_symbols.spell
                                else
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
                              endif
  639              0.001012   return ''

FUNCTION  <SNR>140_ApplyPartialTimer()
Called 4 times
Total time:   0.005770
 Self time:   0.000236

count  total (s)   self (s)
    4              0.000043     if has_key(s:partial_timers, a:timer_id)
    4              0.000063         let [l:Callback, l:args] = remove(s:partial_timers, a:timer_id)
    4   0.005647   0.000112         call call(l:Callback, [a:timer_id] + l:args)
    4              0.000006     endif

FUNCTION  <SNR>95_airline_ale_count()
Called 1244 times
Total time:   0.007477
 Self time:   0.007477

count  total (s)   self (s)
 1244              0.006283   return a:cnt ? a:symbol. a:cnt : ''

FUNCTION  ale#linter#GetAll()
Called 2 times
Total time:   0.000272
 Self time:   0.000216

count  total (s)   self (s)
                                " Don't return linters in the sandbox.
                                " Otherwise a sandboxed script could modify them.
    2   0.000080   0.000024     if ale#util#InSandbox()
                                    return []
                                endif
                            
    2              0.000009     let l:combined_linters = []
                            
    4              0.000016     for l:filetype in a:filetypes
                                    " Load linters from runtimepath if we haven't done that yet.
    2              0.000014         if !has_key(s:runtime_loaded_map, l:filetype)
                                        execute 'silent! runtime! ale_linters/' . l:filetype . '/*.vim'
                            
                                        let s:runtime_loaded_map[l:filetype] = 1
                                    endif
                            
    2              0.000049         call extend(l:combined_linters, get(s:linters, l:filetype, []))
    2              0.000005     endfor
                            
    2              0.000006     return l:combined_linters

FUNCTION  <SNR>168_BuildSignMap()
Called 7 times
Total time:   0.005160
 Self time:   0.002912

count  total (s)   self (s)
    7   0.000395   0.000114     let l:max_signs = ale#Var(a:buffer, 'max_signs')
                            
    7              0.000024     if l:max_signs is 0
                                    let l:selected_grouped_items = []
                                elseif type(l:max_signs) is v:t_number && l:max_signs > 0
                                    let l:selected_grouped_items = a:grouped_items[:l:max_signs - 1]
                                else
    7              0.000032         let l:selected_grouped_items = a:grouped_items
    7              0.000010     endif
                            
    7              0.000025     let l:sign_map = {}
    7              0.000033     let l:sign_offset = g:ale_sign_offset
                            
   19              0.000087     for [l:line, l:sign_id, l:name] in a:current_sign_list
   12              0.000197         let l:sign_info = get(l:sign_map, l:line, {   'current_id_list': [],   'current_name_list': [],   'new_id': 0,   'new_name': '',   'items': [],})
                            
                                    " Increment the sign offset for new signs, by the maximum sign ID.
   12              0.000047         if l:sign_id > l:sign_offset
   12              0.000044             let l:sign_offset = l:sign_id
   12              0.000018         endif
                            
                                    " Remember the sign names and IDs in separate Lists, so they are easy
                                    " to work with.
   12              0.000080         call add(l:sign_info.current_id_list, l:sign_id)
   12              0.000068         call add(l:sign_info.current_name_list, l:name)
                            
   12              0.000081         let l:sign_map[l:line] = l:sign_info
   12              0.000023     endfor
                            
   20              0.000065     for l:group in l:selected_grouped_items
   13              0.000057         let l:line = l:group[0].lnum
   13              0.000245         let l:sign_info = get(l:sign_map, l:line, {   'current_id_list': [],   'current_name_list': [],   'new_id': 0,   'new_name': '',   'items': [],})
                            
   13   0.002195   0.000229         let l:sign_info.new_name = ale#sign#GetSignName(l:group)
   13              0.000059         let l:sign_info.items = l:group
                            
   13              0.000107         let l:index = index(   l:sign_info.current_name_list,   l:sign_info.new_name)
                            
   13              0.000039         if l:index >= 0
                                        " We have a sign with this name already, so use the same ID.
   12              0.000065             let l:sign_info.new_id = l:sign_info.current_id_list[l:index]
   12              0.000020         else
                                        " This sign name replaces the previous name, so use a new ID.
    1              0.000005             let l:sign_info.new_id = l:sign_offset + 1
    1              0.000004             let l:sign_offset += 1
    1              0.000002         endif
                            
   13              0.000083         let l:sign_map[l:line] = l:sign_info
   13              0.000023     endfor
                            
    7              0.000021     return l:sign_map

FUNCTION  ale#Pad()
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000007     return !empty(a:string) ? ' ' . a:string : ''

FUNCTION  airline#extensions#tabline#load_theme()
Called 2 times
Total time:   0.014130
 Self time:   0.000714

count  total (s)   self (s)
    2              0.000007   if pumvisible()
                                return
                              endif
    2              0.000012   let colors    = get(a:palette, 'tabline', {})
    2              0.000013   let tablabel  = get(colors, 'airline_tablabel', a:palette.normal.airline_b)
                              " Theme for tabs on the left
    2              0.000010   let tab     = get(colors, 'airline_tab', a:palette.normal.airline_b)
    2              0.000010   let tabsel  = get(colors, 'airline_tabsel', a:palette.normal.airline_a)
    2              0.000010   let tabtype = get(colors, 'airline_tabtype', a:palette.visual.airline_a)
    2              0.000010   let tabfill = get(colors, 'airline_tabfill', a:palette.normal.airline_c)
    2              0.000025   let tabmod  = get(colors, 'airline_tabmod', a:palette.insert.airline_a)
    2              0.000011   let tabhid  = get(colors, 'airline_tabhid', a:palette.normal.airline_c)
    2              0.000014   if has_key(a:palette, 'normal_modified') && has_key(a:palette.normal_modified, 'airline_c')
    2              0.000012     let tabmodu = get(colors, 'airline_tabmod_unsel', a:palette.normal_modified.airline_c)
    2              0.000003   else
                                "Fall back to normal airline_c if modified airline_c isn't present
                                let tabmodu = get(colors, 'airline_tabmod_unsel', a:palette.normal.airline_c)
                              endif
    2   0.000825   0.000026   call airline#highlighter#exec('airline_tablabel', tablabel)
    2   0.000900   0.000026   call airline#highlighter#exec('airline_tab', tab)
    2   0.000996   0.000028   call airline#highlighter#exec('airline_tabsel', tabsel)
    2   0.001018   0.000031   call airline#highlighter#exec('airline_tabtype', tabtype)
    2   0.000997   0.000031   call airline#highlighter#exec('airline_tabfill', tabfill)
    2   0.000911   0.000028   call airline#highlighter#exec('airline_tabmod', tabmod)
    2   0.001471   0.000034   call airline#highlighter#exec('airline_tabmod_unsel', tabmodu)
    2   0.001056   0.000035   call airline#highlighter#exec('airline_tabhid', tabhid)
                            
                              " Theme for tabs on the right
                              " label on the right
    2              0.000018   let tablabel_r  = get(colors, 'airline_tablabel', a:palette.normal.airline_b)
    2              0.000015   let tabsel_right  = get(colors, 'airline_tabsel_right', a:palette.normal.airline_a)
    2              0.000015   let tab_right     = get(colors, 'airline_tab_right',    a:palette.inactive.airline_c)
    2              0.000014   let tabmod_right  = get(colors, 'airline_tabmod_right', a:palette.insert.airline_a)
    2              0.000013   let tabhid_right  = get(colors, 'airline_tabhid_right', a:palette.normal.airline_c)
    2              0.000015   if has_key(a:palette, 'normal_modified') && has_key(a:palette.normal_modified, 'airline_c')
    2              0.000021     let tabmodu_right = get(colors, 'airline_tabmod_unsel_right', a:palette.normal_modified.airline_c)
    2              0.000003   else
                                "Fall back to normal airline_c if modified airline_c isn't present
                                let tabmodu_right = get(colors, 'airline_tabmod_unsel_right', a:palette.normal.airline_c)
                              endif
    2   0.000904   0.000027   call airline#highlighter#exec('airline_tablabel_right', tablabel_r)
    2   0.000832   0.000033   call airline#highlighter#exec('airline_tab_right',    tab_right)
    2   0.000820   0.000026   call airline#highlighter#exec('airline_tabsel_right', tabsel_right)
    2   0.000815   0.000025   call airline#highlighter#exec('airline_tabmod_right', tabmod_right)
    2   0.000825   0.000025   call airline#highlighter#exec('airline_tabhid_right', tabhid_right)
    2   0.001453   0.000033   call airline#highlighter#exec('airline_tabmod_unsel_right', tabmodu_right)

FUNCTION  <SNR>165_upsert_new_gitgutter_signs()
Called 2 times
Total time:   0.001326
 Self time:   0.001098

count  total (s)   self (s)
    2   0.000098   0.000032   let other_signs         = gitgutter#utility#getbufvar(a:bufnr, 'other_signs')
    2   0.000094   0.000027   let old_gitgutter_signs = gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')
                            
                              " Handle special case where the first line is the site of two hunks:
                              " lines deleted above at the start of the file, and lines deleted
                              " immediately below.
    2              0.000022   if a:modified_lines[0:1] == [[1, 'removed_first_line'], [1, 'removed']]
                                let modified_lines = [[1, 'removed_above_and_below']] + a:modified_lines[2:]
                              else
    2              0.000007     let modified_lines = a:modified_lines
    2              0.000002   endif
                            
   22              0.000044   for line in modified_lines
   20              0.000064     let line_number = line[0]  " <number>
   20              0.000083     if index(other_signs, line_number) == -1  " don't clobber others' signs
   15   0.000263   0.000168       let name = s:highlight_name_for_change(line[1])
   15              0.000074       if !has_key(old_gitgutter_signs, line_number)  " insert
                                    let id = s:next_sign_id()
                                    execute "sign place" id "line=" . line_number "name=" . name "buffer=" . a:bufnr
                                  else  " update if sign has changed
   15              0.000065         let old_sign = old_gitgutter_signs[line_number]
   15              0.000051         if old_sign.name !=# name
                                      execute "sign place" old_sign.id "name=" . name "buffer=" . a:bufnr
                                    end
   15              0.000011       endif
   15              0.000011     endif
   20              0.000023   endfor
                              " At this point b:gitgutter_gitgutter_signs is out of date.

FUNCTION  ale#linter#ResolveFiletype()
Called 2 times
Total time:   0.000300
 Self time:   0.000075

count  total (s)   self (s)
    2   0.000273   0.000048     let l:filetype = s:GetAliasedFiletype(a:original_filetype)
                            
    2              0.000013     if type(l:filetype) isnot v:t_list
    2              0.000008         return [l:filetype]
                                endif
                            
                                return l:filetype

FUNCTION  <SNR>169_ShouldOpen()
Called 8 times
Total time:   0.000553
 Self time:   0.000296

count  total (s)   self (s)
    8   0.000411   0.000154     let l:val = ale#Var(a:buffer, 'open_list')
    8              0.000074     let l:saved = getbufvar(a:buffer, 'ale_save_event_fired', 0)
                            
    8              0.000045     return l:val is 1 || (l:val is# 'on_save' && l:saved)

FUNCTION  <SNR>119_InsideCommentOrStringAndShouldStop()
Called 421 times
Total time:   0.238355
 Self time:   0.041753

count  total (s)   self (s)
  421   0.228598   0.031997   let retval = s:InsideCommentOrString()
  421              0.001970   let inside_comment = retval == 1
  421              0.001563   let inside_string = retval == 2
                            
  421              0.002318   if inside_comment && g:ycm_complete_in_comments || inside_string && g:ycm_complete_in_strings
                                return 0
                              endif
                            
  421              0.000811   return retval

FUNCTION  airline#extensions#tagbar#currenttag()
Called 639 times
Total time:   0.033780
 Self time:   0.031640

count  total (s)   self (s)
  639              0.004163   if get(w:, 'airline_active', 0)
  639              0.001735     if !s:init
                                  try
                                    " try to load the plugin, if filetypes are disabled,
                                    " this will cause an error, so try only once
                                    let a=tagbar#currenttag('%', '', '')
                                  catch
                                  endtry
                                  unlet! a
                                  let s:init=1
                                endif
                                " function tagbar#currenttag does not exist, if filetype is not enabled
  639              0.004816     if s:airline_tagbar_last_lookup_time != localtime() && exists("*tagbar#currenttag")
   29   0.002682   0.000543       let s:airline_tagbar_last_lookup_val = tagbar#currenttag('%s', '', s:flags)
   29              0.000186       let s:airline_tagbar_last_lookup_time = localtime()
   29              0.000040     endif
  639              0.002021     return s:airline_tagbar_last_lookup_val
                              endif
                              return ''

FUNCTION  <SNR>150_AddHintsForTypeScriptParsingErrors()
Called 1 time
Total time:   0.000055
 Self time:   0.000055

count  total (s)   self (s)
    2              0.000008     for l:item in a:output
    1              0.000034         let l:item.text = substitute(   l:item.text,   '^\(Parsing error\)',   '\1 (You may need configure typescript-eslint-parser)',   '',)
    1              0.000002     endfor

FUNCTION  <SNR>104_hl_group_exists()
Called 740 times
Total time:   0.021509
 Self time:   0.021509

count  total (s)   self (s)
  740              0.007195   if !hlexists(a:group)
                                return 0
                              elseif empty(synIDattr(hlID(a:group), 'fg'))
                                return 0
                              endif
  740              0.000903   return 1

FUNCTION  ale#util#Mode()
Called 13 times
Total time:   0.000117
 Self time:   0.000117

count  total (s)   self (s)
   13              0.000101     return call('mode', a:000)

FUNCTION  <SNR>157_SendMessageData()
Called 4 times
Total time:   0.000374
 Self time:   0.000173

count  total (s)   self (s)
    4              0.000024     if has_key(a:conn, 'job_id')
    4   0.000277   0.000075         call ale#job#SendRaw(a:conn.job_id, a:data)
    4              0.000026     elseif has_key(a:conn, 'channel_id') && ale#socket#IsOpen(a:conn.channel_id)
                                    " Send the message to the server
                                    call ale#socket#Send(a:conn.channel_id, a:data)
                                else
                                    return 0
                                endif
                            
    4              0.000005     return 1

FUNCTION  <SNR>171_CreateCountDict()
Called 7 times
Total time:   0.000106
 Self time:   0.000106

count  total (s)   self (s)
                                " Keys 0 and 1 are for backwards compatibility.
                                " The count object used to be a List of [error_count, warning_count].
    7              0.000081     return {   '0': 0,   '1': 0,   'error': 0,   'warning': 0,   'info': 0,   'style_error': 0,   'style_warning': 0,   'total': 0,}

FUNCTION  <SNR>136_Init()
Called 29 times
Total time:   0.000257
 Self time:   0.000257

count  total (s)   self (s)
   29              0.000124     if s:checked_ctags == 2 && a:silent
   29              0.000086         return 0
                                elseif s:checked_ctags != 1
                                    if !s:CheckForExCtags(a:silent)
                                        return 0
                                    endif
                                endif
                            
                                if !s:type_init_done
                                    call s:InitTypes()
                                endif
                            
                                if !s:autocommands_done
                                    call s:CreateAutocommands()
                                    call s:AutoUpdate(fnamemodify(expand('%'), ':p'), 0)
                                endif
                            
                                let s:init_done = 1
                                return 1

FUNCTION  ale#util#InSandbox()
Called 17 times
Total time:   0.000638
 Self time:   0.000563

count  total (s)   self (s)
   17              0.000047     try
   17   0.000393   0.000318         let &l:equalprg=&l:equalprg
   17              0.000041     catch /E48/
                                    " E48 is the sandbox error.
                                    return 1
                                endtry
                            
   17              0.000029     return 0

FUNCTION  airline#parts#crypt()
Called 639 times
Total time:   0.010333
 Self time:   0.010333

count  total (s)   self (s)
  639              0.009650   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  <SNR>104_CheckDefined()
Called 824 times
Total time:   0.041453
 Self time:   0.041453

count  total (s)   self (s)
                              " Checks, whether the definition of the colors is valid and is not empty or NONE
                              " e.g. if the colors would expand to this:
                              " hi airline_c ctermfg=NONE ctermbg=NONE
                              " that means to clear that highlighting group, therefore, fallback to Normal
                              " highlighting group for the cterm values
                            
                              " This only works, if the Normal highlighting group is actually defined, so
                              " return early, if it has been cleared
  824              0.004819   if !exists("g:airline#highlighter#normal_fg_hi")
                                let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
                              endif
  824              0.004528   if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
                                return a:colors
                              endif
                            
 1598              0.004859   for val in a:colors
 1598              0.006977     if !empty(val) && val !=# 'NONE'
  824              0.001756       return a:colors
                                endif
  774              0.000940   endfor
                              " this adds the bold attribute to the term argument of the :hi command,
                              " but at least this makes sure, the group will be defined
                              let fg = g:airline#highlighter#normal_fg_hi
                              let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                              if bg < 0
                                " in case there is no background color defined for Normal
                                let bg = a:colors[3]
                              endif
                              return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  210()
Called 2 times
Total time:   0.000105
 Self time:   0.000067

count  total (s)   self (s)
    2   0.000074   0.000036     let flags = self._flagsForScope(a:scope)
    2              0.000013     if index(flags, a:flag) == -1
    2              0.000012         call add(flags, a:flag)
    2              0.000003     end

FUNCTION  211()
Called 3 times
Total time:   0.000054
 Self time:   0.000054

count  total (s)   self (s)
    3              0.000051     let self._flags[a:scope] = []

FUNCTION  212()
Called 2 times
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
    2              0.000020     if !has_key(self._flags, a:scope)
                                    let self._flags[a:scope] = []
                                endif
    2              0.000008     return self._flags[a:scope]

FUNCTION  213()
Called 1 time
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    1              0.000013     let newObj = copy(self)
    1              0.000005     let newObj._flags = {}
    1              0.000003     return newObj

FUNCTION  215()
Called 21 times
Total time:   0.000911
 Self time:   0.000911

count  total (s)   self (s)
   21              0.000083     let flagstring = ""
   42              0.000225     for i in values(self._flags)
   21              0.000166         let flagstring .= join(i)
   21              0.000044     endfor
                            
   21              0.000099     if len(flagstring) == 0
   17              0.000032         return ""
                                endif
                            
    4              0.000018     return '[' . flagstring . ']'

FUNCTION  <SNR>107_section_is_empty()
Called 63 times
Total time:   0.001395
 Self time:   0.001395

count  total (s)   self (s)
   63              0.000230   let start=1
                            
                              " do not check for inactive windows or the tabline
   63              0.000211   if a:self._context.active == 0
   16              0.000027     return 0
                              elseif get(a:self._context, 'tabline', 0)
   11              0.000022     return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
   36              0.000171   if get(g:, 'airline_skip_empty_sections', 0) == 0
   36              0.000059     return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
                              if get(w:, 'airline_skip_empty_sections', -1) == 0
                                return 0
                              endif
                              " assume accents sections to be never empty
                              " (avoides, that on startup the mode message becomes empty)
                              if match(a:content, '%#__accent_[^#]*#.*__restore__#') > -1
                                return 0
                              endif
                              if empty(a:content)
                                return 1
                              endif
                              let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              if empty(list)
                                return 0 " no function in statusline text
                              endif
                              while len(list) > 0
                                let expr = list[0]
                                try
                                  " catch all exceptions, just in case
                                  if !empty(eval(expr))
                                    return 0
                                  endif
                                catch
                                  return 0
                                endtry
                                let start += 1
                                let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              endw
                              return 1

FUNCTION  <SNR>149_ExitCallback()
Called 4 times
Total time:   0.049605
 Self time:   0.000811

count  total (s)   self (s)
    4              0.000045     if !has_key(s:buffer_data, a:buffer)
                                    return
                                endif
                            
    4              0.000030     let l:jobs = s:buffer_data[a:buffer].jobs
                            
    4              0.000026     if !has_key(l:jobs, a:data.job_id)
                                    return
                                endif
                            
    4              0.000036     let l:job_type = remove(l:jobs, a:data.job_id)
                            
    4              0.000013     if g:ale_history_enabled
    4   0.000526   0.000079         call ale#history#SetExitCode(a:buffer, a:data.job_id, a:data.exit_code)
                            
                                    " Log the output of the command for ALEInfo if we should.
    4              0.000019         if g:ale_history_log_output && a:data.log_output is 1
    2   0.000229   0.000044             call ale#history#RememberOutput(   a:buffer,   a:data.job_id,   a:line_list[:])
    2              0.000003         endif
    4              0.000004     endif
                            
                                " If the callback starts any new jobs, use the same job type for them.
    4              0.000049     call setbufvar(a:buffer, 'ale_job_type', l:job_type)
    4   0.043398   0.000211     let l:value = a:Callback(a:buffer, a:line_list, {   'exit_code': a:data.exit_code,   'temporary_file': a:data.temporary_file,})
                            
    4              0.000028     let l:result = a:data.result
    4              0.000020     let l:result.value = l:value
                            
    4              0.000034     if get(l:result, 'result_callback', v:null) isnot v:null
    1   0.005014   0.000038         call call(l:result.result_callback, [l:value])
    1              0.000004     endif

FUNCTION  ale#path#Upwards()
Called 1 time
Total time:   0.000340
 Self time:   0.000294

count  total (s)   self (s)
    1              0.000015     let l:pattern = has('win32') ? '\v/+|\\+' : '\v/+'
    1              0.000007     let l:sep = has('win32') ? '\' : '/'
    1   0.000161   0.000115     let l:parts = split(ale#path#Simplify(a:path), l:pattern)
    1              0.000005     let l:path_list = []
                            
    8              0.000019     while !empty(l:parts)
    7              0.000051         call add(l:path_list, join(l:parts, l:sep))
    7              0.000030         let l:parts = l:parts[:-2]
    7              0.000007     endwhile
                            
    1              0.000005     if has('win32') && a:path =~# '^[a-zA-z]:\'
                                    " Add \ to C: for C:\, etc.
                                    let l:path_list[-1] .= '\'
                                elseif a:path[0] is# '/'
                                    " If the path starts with /, even on Windows, add / and / to all paths.
    1              0.000013         call map(l:path_list, '''/'' . v:val')
    1              0.000003         call add(l:path_list, '/')
    1              0.000001     endif
                            
    1              0.000001     return l:path_list

FUNCTION  airline#extensions#branch#head()
Called 639 times
Total time:   1.657397
 Self time:   0.037241

count  total (s)   self (s)
  639              0.004300   if !exists('b:buffer_vcs_config')
                                call s:init_buffer()
                              endif
                            
  639   1.409841   0.007836   call s:update_branch()
  639   0.227314   0.009654   call s:update_untracked()
                            
  639              0.005686   if exists('b:airline_head') && !empty(b:airline_head)
  635              0.001867     return b:airline_head
                              endif
                            
    4              0.000013   let b:airline_head = ''
    4              0.000031   let vcs_priority = get(g:, "airline#extensions#branch#vcs_priority", ["git", "mercurial"])
                            
    4              0.000010   let heads = []
   12              0.000027   for vcs in vcs_priority
    8              0.000043     if !empty(b:buffer_vcs_config[vcs].branch)
    4              0.000020       let heads += [vcs]
    4              0.000005     endif
    8              0.000008   endfor
                            
    8              0.000020   for vcs in heads
    4              0.000016     if !empty(b:airline_head)
                                  let b:airline_head .= ' | '
                                endif
    4              0.000014     if len(heads) > 1
                                  let b:airline_head .= s:vcs_config[vcs].exe .':'
                                endif
    4   0.000615   0.000123     let b:airline_head .= s:format_name({s:vcs_config[vcs].display_branch}())
    4              0.000022     let additional = b:buffer_vcs_config[vcs].untracked
    4              0.000039     if empty(additional) && has_key(b:buffer_vcs_config[vcs], 'dirty') && b:buffer_vcs_config[vcs].dirty
    4              0.000025       let additional = g:airline_symbols['dirty']
    4              0.000005     endif
    4              0.000017     let b:airline_head .= additional
    4              0.000006   endfor
                            
    4              0.000013   if empty(heads)
                                if airline#util#has_vcscommand()
                                  noa call VCSCommandEnableBufferSetup()
                                  if exists('b:VCSCommandBufferInfo')
                                    let b:airline_head = s:format_name(get(b:VCSCommandBufferInfo, 0, ''))
                                  endif
                                endif
                              endif
                            
    4              0.000012   if empty(heads)
                                if airline#util#has_custom_scm()
                                  try
                                    let Fn = function(g:airline#extensions#branch#custom_head)
                                    let b:airline_head = Fn()
                                  endtry
                                endif
                              endif
                            
    4              0.000023   if exists("g:airline#extensions#branch#displayed_head_limit")
                                let w:displayed_head_limit = g:airline#extensions#branch#displayed_head_limit
                                if len(b:airline_head) > w:displayed_head_limit - 1
                                  let b:airline_head = b:airline_head[0:(w:displayed_head_limit - 1)].(&encoding ==? 'utf-8' ?  '…' : '.')
                                endif
                              endif
                            
    4              0.000010   return b:airline_head

FUNCTION  ale#handlers#eslint#GetExecutable()
Called 6 times
Total time:   0.006665
 Self time:   0.000147

count  total (s)   self (s)
    6   0.006659   0.000141     return ale#node#FindExecutable(a:buffer, 'javascript_eslint', [   'node_modules/.bin/eslint_d',   'node_modules/eslint/bin/eslint.js',   'node_modules/.bin/eslint',])

FUNCTION  <SNR>96_conflict_marker()
Called 1 time
Total time:   0.000455
 Self time:   0.000455

count  total (s)   self (s)
                              " Checks for git conflict markers
    1              0.000005   let annotation = '\%([0-9A-Za-z_.:]\+\)\?'
    1              0.000010   let pattern = '^\%(\%(<\{7} '.annotation. '\)\|\%(=\{7\}\)\|\%(>\{7\} '.annotation.'\)\)$'
    1              0.000437   return search(pattern, 'nw')

FUNCTION  ale#lsp_linter#FindProjectRoot()
Called 2 times
Total time:   0.001265
 Self time:   0.000251

count  total (s)   self (s)
    2              0.000021     let l:buffer_ale_root = getbufvar(a:buffer, 'ale_lsp_root', {})
                            
    2              0.000013     if type(l:buffer_ale_root) is v:t_string
                                    return l:buffer_ale_root
                                endif
                            
                                " Try to get a buffer-local setting for the root
    2              0.000013     if has_key(l:buffer_ale_root, a:linter.name)
                                    let l:Root = l:buffer_ale_root[a:linter.name]
                            
                                    if type(l:Root) is v:t_func
                                        return l:Root(a:buffer)
                                    else
                                        return l:Root
                                    endif
                                endif
                            
                                " Try to get a global setting for the root
    2              0.000022     if has_key(g:ale_lsp_root, a:linter.name)
                                    let l:Root = g:ale_lsp_root[a:linter.name]
                            
                                    if type(l:Root) is v:t_func
                                        return l:Root(a:buffer)
                                    else
                                        return l:Root
                                    endif
                                endif
                            
                                " Fall back to the linter-specific configuration
    2              0.000011     if has_key(a:linter, 'project_root')
    2              0.000014         let l:Root = a:linter.project_root
                            
    2   0.001068   0.000054         return type(l:Root) is v:t_func ? l:Root(a:buffer) : l:Root
                                endif
                            
                                return ale#util#GetFunction(a:linter.project_root_callback)(a:buffer)

FUNCTION  airline#extensions#load_theme()
Called 2 times
Total time:   0.024411
 Self time:   0.000072

count  total (s)   self (s)
    2   0.024409   0.000069   call airline#util#exec_funcrefs(s:ext._theme_funcrefs, g:airline#themes#{g:airline_theme}#palette)

FUNCTION  ale#lsp#NotifyForChanges()
Called 2 times
Total time:   0.002082
 Self time:   0.000396

count  total (s)   self (s)
    2              0.000016     let l:conn = get(s:connections, a:conn_id, {})
    2              0.000007     let l:notified = 0
                            
    2              0.000012     if !empty(l:conn) && has_key(l:conn.open_documents, a:buffer)
    2              0.000010         let l:new_tick = getbufvar(a:buffer, 'changedtick')
                            
    2              0.000007         if l:conn.open_documents[a:buffer] < l:new_tick
    2              0.000004             if l:conn.is_tsserver
    2   0.000907   0.000209                 let l:message = ale#lsp#tsserver_message#Change(a:buffer)
    2              0.000007             else
                                            let l:message = ale#lsp#message#DidChange(a:buffer)
                                        endif
                            
    2   0.001038   0.000050             call ale#lsp#Send(a:conn_id, l:message)
    2              0.000018             let l:conn.open_documents[a:buffer] = l:new_tick
    2              0.000006             let l:notified = 1
    2              0.000002         endif
    2              0.000002     endif
                            
    2              0.000004     return l:notified

FUNCTION  gitgutter#diff#run_diff()
Called 2 times
Total time:   0.030718
 Self time:   0.000984

count  total (s)   self (s)
    2   0.000123   0.000026   if gitgutter#utility#repo_path(a:bufnr, 0) == -1
                                throw 'gitgutter author fail'
                              endif
                            
    2   0.000191   0.000023   if gitgutter#utility#repo_path(a:bufnr, 0) == -2
                                throw 'gitgutter not tracked'
                              endif
                            
                              " Wrap compound commands in parentheses to make Windows happy.
                              " bash doesn't mind the parentheses.
    2              0.000006   let cmd = '('
                            
                              " Append buffer number to temp filenames to avoid race conditions between
                              " writing and reading the files when asynchronously processing multiple
                              " buffers.
                            
                              " Without the buffer number, buff_file would have a race between the
                              " second gitgutter#process_buffer() writing the file (synchronously, below)
                              " and the first gitgutter#process_buffer()'s async job reading it (with
                              " git-diff).
    2              0.000016   let buff_file = s:temp_buffer.'.'.a:bufnr
                            
                              " Add a counter to avoid a similar race with two quick writes of the same buffer.
                              " Use a modulus greater than a maximum reasonable number of visible buffers.
    2              0.000009   let s:counter = (s:counter + 1) % 20
    2              0.000012   let buff_file .= '.'.s:counter
                            
    2   0.000389   0.000037   let extension = gitgutter#utility#extension(a:bufnr)
    2              0.000010   if !empty(extension)
    2              0.000014     let buff_file .= '.'.extension
    2              0.000003   endif
                            
                              " Write buffer to temporary file.
                              " Note: this is synchronous.
    2   0.002671   0.000138   call s:write_buffer(a:bufnr, buff_file)
                            
    2              0.000015   if a:from ==# 'index'
                                " Without the buffer number, from_file would have a race in the shell
                                " between the second process writing it (with git-show) and the first
                                " reading it (with git-diff).
    2              0.000043     let from_file = s:temp_from.'.'.a:bufnr
                            
                                " Add a counter to avoid a similar race with two quick writes of the same buffer.
    2              0.000016     let from_file .= '.'.s:counter
                            
    2              0.000011     if !empty(extension)
    2              0.000012       let from_file .= '.'.extension
    2              0.000003     endif
                            
                                " Write file from index to temporary file.
    2   0.000223   0.000038     let index_name = g:gitgutter_diff_base.':'.gitgutter#utility#repo_path(a:bufnr, 1)
    2              0.000030     let cmd .= g:gitgutter_git_executable.' '.g:gitgutter_git_args.' --no-pager show '.index_name.' > '.from_file.' && '
                            
    2              0.000005   elseif a:from ==# 'working_tree'
                                let from_file = gitgutter#utility#repo_path(a:bufnr, 1)
                              endif
                            
                              " Call git-diff.
    2              0.000021   let cmd .= g:gitgutter_git_executable.' '.g:gitgutter_git_args.' --no-pager '.g:gitgutter_git_args
    2              0.000006   if s:c_flag
    2              0.000009     let cmd .= ' -c "diff.autorefreshindex=0"'
    2              0.000008     let cmd .= ' -c "diff.noprefix=false"'
    2              0.000008     let cmd .= ' -c "core.safecrlf=false"'
    2              0.000003   endif
    2              0.000023   let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' -- '.from_file.' '.buff_file
                            
                              " Pipe git-diff output into grep.
    2              0.000013   if !a:preserve_full_diff && !empty(g:gitgutter_grep)
    2   0.000169   0.000036     let cmd .= ' | '.g:gitgutter_grep.' '.gitgutter#utility#shellescape('^@@ ')
    2              0.000003   endif
                            
                              " grep exits with 1 when no matches are found; git-diff exits with 1 when
                              " differences are found.  However we want to treat non-matches and
                              " differences as non-erroneous behaviour; so we OR the command with one
                              " which always exits with success (0).
    2              0.000009   let cmd .= ' || exit 0'
                            
    2              0.000008   let cmd .= ')'
                            
    2   0.001280   0.000047   let cmd = gitgutter#utility#cd_cmd(a:bufnr, cmd)
                            
    2   0.000043   0.000033   if g:gitgutter_async && gitgutter#async#available()
    2   0.025158   0.000135     call gitgutter#async#execute(cmd, a:bufnr, {   'out': function('gitgutter#diff#handler'),   'err': function('gitgutter#hunk#reset'), })
    2              0.000015     return 'async'
                            
                              else
                                let diff = gitgutter#utility#system(cmd)
                            
                                if v:shell_error
                                  call gitgutter#debug#log(diff)
                                  throw 'gitgutter diff failed'
                                endif
                            
                                return diff
                              endif

FUNCTION  ale#util#FuzzyJSONDecode()
Called 1 time
Total time:   0.000125
 Self time:   0.000125

count  total (s)   self (s)
    1              0.000006     if empty(a:data)
                                    return a:default
                                endif
                            
    1              0.000017     let l:str = type(a:data) is v:t_string ? a:data : join(a:data, '')
                            
    1              0.000003     try
    1              0.000063         let l:result = json_decode(l:str)
                            
                                    " Vim 8 only uses the value v:none for decoding blank strings.
    1              0.000010         if !has('nvim') && l:result is v:none
                                        return a:default
                                    endif
                            
    1              0.000003         return l:result
                                catch /E474/
                                    return a:default
                                endtry

FUNCTION  221()
Called 1 time
Total time:   0.000297
 Self time:   0.000050

count  total (s)   self (s)
    1   0.000074   0.000012     call g:NERDTree.MustBeOpen()
    1   0.000221   0.000037     call nerdtree#exec(g:NERDTree.GetWinNum() . "wincmd w")

FUNCTION  227()
Called 3 times
Total time:   0.000115
 Self time:   0.000115

count  total (s)   self (s)
    3              0.000017     if exists("t:NERDTreeBufName")
    3              0.000094         return bufwinnr(t:NERDTreeBufName)
                                endif
                            
                                return -1

FUNCTION  228()
Called 2 times
Total time:   0.000110
 Self time:   0.000036

count  total (s)   self (s)
    2   0.000109   0.000034     return s:NERDTree.GetWinNum() != -1 || bufname('%') =~# '^' . g:NERDTreeCreator.BufNamePrefix() . '\d\+$'

FUNCTION  <SNR>17_Slash()
Called 1282 times
Total time:   0.018672
 Self time:   0.018672

count  total (s)   self (s)
 1282              0.007333   if exists('+shellslash')
                                return tr(a:path, '\', '/')
                              else
 1282              0.003283     return a:path
                              endif

FUNCTION  GitGutterGetHunkSummary()
Called 635 times
Total time:   0.040266
 Self time:   0.008913

count  total (s)   self (s)
  635   0.039689   0.008336   return gitgutter#hunk#summary(winbufnr(0))

FUNCTION  airline#parts#mode()
Called 639 times
Total time:   0.052333
 Self time:   0.012253

count  total (s)   self (s)
  639   0.051532   0.011452   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  <SNR>169_FixList()
Called 7 times
Total time:   0.005457
 Self time:   0.001811

count  total (s)   self (s)
    7   0.000352   0.000131     let l:format = ale#Var(a:buffer, 'loclist_msg_format')
    7              0.000029     let l:new_list = []
                            
   28              0.000089     for l:item in a:list
   21              0.000235         let l:fixed_item = copy(l:item)
                            
   21   0.003868   0.000442         let l:fixed_item.text = ale#GetLocItemMessage(l:item, l:format)
                            
   21              0.000083         if l:item.bufnr == -1
                                        " If the buffer number is invalid, remove it.
                                        call remove(l:fixed_item, 'bufnr')
                                    endif
                            
   21              0.000140         call add(l:new_list, l:fixed_item)
   21              0.000039     endfor
                            
    7              0.000019     return l:new_list

FUNCTION  ale#highlight#SetHighlights()
Called 7 times
Total time:   0.005412
 Self time:   0.000674

count  total (s)   self (s)
    7              0.000224     let l:new_list = getbufvar(a:buffer, 'ale_enabled', 1) && g:ale_enabled   ? filter(copy(a:loclist), 'v:val.bufnr == a:buffer && v:val.col > 0')   : []
                            
                                " Set the list in the buffer variable.
    7              0.000219     call setbufvar(str2nr(a:buffer), 'ale_highlight_items', l:new_list)
                            
                                " Update highlights for the current buffer, which may or may not
                                " be the buffer we just set highlights for.
    7   0.004919   0.000181     call ale#highlight#UpdateHighlights()

FUNCTION  airline#extensions#quickfix#apply()
Called 4 times
Total time:   0.000084
 Self time:   0.000084

count  total (s)   self (s)
    4              0.000024   if &buftype == 'quickfix'
                                let w:airline_section_a = airline#extensions#quickfix#get_type()
                                let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
                                let w:airline_section_c = ''
                                let w:airline_section_x = ''
                              endif

FUNCTION  ale#engine#SetResults()
Called 7 times
Total time:   0.047694
 Self time:   0.001509

count  total (s)   self (s)
    7   0.000304   0.000138     let l:linting_is_done = !ale#engine#IsCheckingBuffer(a:buffer)
                            
                                " Set signs first. This could potentially fix some line numbers.
                                " The List could be sorted again here by SetSigns.
    7              0.000020     if g:ale_set_signs
    7   0.031468   0.000219         call ale#sign#SetSigns(a:buffer, a:loclist)
    7              0.000024     endif
                            
    7              0.000032     if g:ale_set_quickfix || g:ale_set_loclist
    7   0.005103   0.000138         call ale#list#SetLists(a:buffer, a:loclist)
    7              0.000009     endif
                            
    7              0.000049     if exists('*ale#statusline#Update')
                                    " Don't load/run if not already loaded.
    7   0.003040   0.000133         call ale#statusline#Update(a:buffer, a:loclist)
    7              0.000012     endif
                            
    7              0.000020     if g:ale_set_highlights
    7   0.005556   0.000144         call ale#highlight#SetHighlights(a:buffer, a:loclist)
    7              0.000012     endif
                            
    7              0.000023     if l:linting_is_done
    1              0.000003         if g:ale_echo_cursor
                                        " Try and echo the warning now.
                                        " This will only do something meaningful if we're in normal mode.
    1   0.001335   0.000021             call ale#cursor#EchoCursorWarning()
    1              0.000001         endif
                            
    1              0.000003         if g:ale_virtualtext_cursor
                                        " Try and show the warning now.
                                        " This will only do something meaningful if we're in normal mode.
                                        call ale#virtualtext#ShowCursorWarning()
                                    endif
                            
                                    " Reset the save event marker, used for opening windows, etc.
    1              0.000008         call setbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Set a marker showing how many times a buffer has been checked.
    1              0.000010         call setbufvar(   a:buffer,   'ale_linted',   getbufvar(a:buffer, 'ale_linted', 0) + 1)
                            
                                    " Automatically remove all managed temporary files and directories
                                    " now that all jobs have completed.
    1   0.000073   0.000019         call ale#command#RemoveManagedFiles(a:buffer)
                            
                                    " Call user autocommands. This allows users to hook into ALE's lint cycle.
    1   0.000203   0.000084         silent doautocmd <nomodeline> User ALELintPost
    1              0.000002     endif

FUNCTION  ale#lsp_linter#OnInit()
Called 2 times
Total time:   0.003915
 Self time:   0.000423

count  total (s)   self (s)
    2              0.000015     let l:buffer = a:details.buffer
    2              0.000008     let l:conn_id = a:details.connection_id
    2              0.000006     let l:command = a:details.command
                            
    2   0.000123   0.000044     let l:config = ale#lsp_linter#GetConfig(l:buffer, a:linter)
    2   0.000171   0.000124     let l:language_id = ale#util#GetFunction(a:linter.language_callback)(l:buffer)
                            
    2   0.000074   0.000031     call ale#lsp#UpdateConfig(l:conn_id, l:buffer, l:config)
                            
    2   0.000155   0.000046     if ale#lsp#OpenDocument(l:conn_id, l:buffer, l:language_id)
                                    if g:ale_history_enabled && !empty(l:command)
                                        call ale#history#Add(l:buffer, 'started', l:conn_id, l:command)
                                    endif
                                endif
                            
                                " The change message needs to be sent for tsserver before doing anything.
    2              0.000007     if a:linter.lsp is# 'tsserver'
    2   0.002131   0.000049         call ale#lsp#NotifyForChanges(l:conn_id, l:buffer)
    2              0.000003     endif
                            
    2   0.001182   0.000050     call a:Callback(a:linter, a:details)

FUNCTION  gitgutter#hunk#increment_lines_removed()
Called 2 times
Total time:   0.000176
 Self time:   0.000045

count  total (s)   self (s)
    2   0.000083   0.000017   let summary = gitgutter#hunk#summary(a:bufnr)
    2              0.000006   let summary[2] += a:count
    2   0.000084   0.000018   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  ale#sign#ParseSigns()
Called 7 times
Total time:   0.008088
 Self time:   0.008088

count  total (s)   self (s)
                                " Matches output like :
                                " line=4  id=1  name=ALEErrorSign
                                " строка=1  id=1000001  имя=ALEErrorSign
                                " 行=1  識別子=1000001  名前=ALEWarningSign
                                " línea=12 id=1000001 nombre=ALEWarningSign
                                " riga=1 id=1000001, nome=ALEWarningSign
    7              0.000035     let l:pattern = '\v^.*\=(\d+).*\=(\d+).*\=(ALE[a-zA-Z]+Sign)'
    7              0.000022     let l:result = []
    7              0.000025     let l:is_dummy_sign_set = 0
                            
  108              0.000320     for l:line in a:line_list
  101              0.004596         let l:match = matchlist(l:line, l:pattern)
                            
  101              0.000546         if len(l:match) > 0
   19              0.000091             if l:match[3] is# 'ALEDummySign'
    7              0.000025                 let l:is_dummy_sign_set = 1
    7              0.000011             else
   12              0.000205                 call add(l:result, [   str2nr(l:match[1]),   str2nr(l:match[2]),   l:match[3],])
   12              0.000023             endif
   19              0.000023         endif
  101              0.000189     endfor
                            
    7              0.000036     return [l:is_dummy_sign_set, l:result]

FUNCTION  ale#fixers#eslint#ProcessFixDryRunOutput()
Called 1 time
Total time:   0.000185
 Self time:   0.000060

count  total (s)   self (s)
    1   0.000159   0.000035     for l:item in ale#util#FuzzyJSONDecode(a:output, [])
    1              0.000017         return split(get(l:item, 'output', ''), "\n")
                                endfor
                            
                                return []

FUNCTION  fugitive#Find()
Called 1278 times
Total time:   1.033884
 Self time:   0.718254

count  total (s)   self (s)
 1278              0.009043   if type(a:object) == type(0)
                                let name = bufname(a:object)
                                return s:PlatformSlash(name =~# '^$\|^/\|^\a\+:' ? name : getcwd() . '/' . name)
                              elseif a:object =~# '^[~$]'
                                let prefix = matchstr(a:object, '^[~$]\i*')
                                let owner = expand(prefix)
                                return s:PlatformSlash((len(owner) ? owner : prefix) . strpart(a:object, len(prefix)))
                              elseif s:Slash(a:object) =~# '^$\|^/\|^\%(\a\a\+:\).*\%(//\|::\)' . (has('win32') ? '\|^\a:/' : '')
                                return s:PlatformSlash(a:object)
                              elseif s:Slash(a:object) =~# '^\.\.\=\%(/\|$\)'
                                return s:PlatformSlash(simplify(getcwd() . '/' . a:object))
                              endif
 1278              0.009072   let dir = a:0 ? a:1 : s:Dir()
 1278              0.005520   if empty(dir)
                                let file = matchstr(a:object, '^\%(:\d:\|[^:]*:\)\zs.*', '', '')
                                let dir = FugitiveExtractGitDir(file)
                                if empty(dir)
                                  return fnamemodify(len(file) ? file : a:object, ':p')
                                endif
                              endif
 1278   0.034620   0.016351   let rev = s:Slash(a:object)
 1278   0.185317   0.015669   let tree = s:Tree(dir)
 1278              0.009123   let base = len(tree) ? tree : 'fugitive://' . dir . '//0'
 1278              0.004186   if rev ==# '.git'
                                let f = len(tree) ? tree . '/.git' : dir
                              elseif rev =~# '^\.git/'
 1278              0.020175     let f = substitute(rev, '^\.git', '', '')
 1278   0.086096   0.017462     let cdir = fugitive#CommonDir(dir)
 1278              0.016052     if f =~# '^/\.\./\.\.\%(/\|$\)'
                                  let f = simplify(len(tree) ? tree . f[3:-1] : dir . f)
                                elseif f =~# '^/\.\.\%(/\|$\)'
                                  let f = base . f[3:-1]
                                elseif cdir !=# dir && ( f =~# '^/\%(config\|hooks\|info\|logs/refs\|objects\|refs\|worktrees\)\%(/\|$\)' || f !~# '^/\%(index$\|index\.lock$\|\w*MSG$\|\w*HEAD$\|logs/\w*HEAD$\|logs$\|rebase-\w\+\)\%(/\|$\)' && getftime(dir . f) < 0 && getftime(cdir . f) >= 0)
                                  let f = simplify(cdir . f)
                                else
 1278              0.009946       let f = simplify(dir . f)
 1278              0.001885     endif
 1278              0.002443   elseif rev ==# ':/'
                                let f = base
                              elseif rev =~# '^\.\%(/\|$\)'
                                let f = base . rev[1:-1]
                              elseif rev =~# '^::\%(/\|\a\+\:\)'
                                let f = rev[2:-1]
                              elseif rev =~# '^::\.\.\=\%(/\|$\)'
                                let f = simplify(getcwd() . '/' . rev[2:-1])
                              elseif rev =~# '^::'
                                let f = base . '/' . rev[2:-1]
                              elseif rev =~# '^:\%([0-3]:\)\=\.\.\=\%(/\|$\)\|^:[0-3]:\%(/\|\a\+:\)'
                                let f = rev =~# '^:\%([0-3]:\)\=\.' ? simplify(getcwd() . '/' . matchstr(rev, '\..*')) : rev[3:-1]
                                if s:cpath(base . '/', (f . '/')[0 : len(base)])
                                  let f = 'fugitive://' . dir . '//' . +matchstr(rev, '^:\zs\d\ze:') . '/' . strpart(f, len(base) + 1)
                                else
                                  let altdir = FugitiveExtractGitDir(f)
                                  if len(altdir) && !s:cpath(dir, altdir)
                                    return fugitive#Find(a:object, altdir)
                                  endif
                                endif
                              elseif rev =~# '^:[0-3]:'
                                let f = 'fugitive://' . dir . '//' . rev[1] . '/' . rev[3:-1]
                              elseif rev ==# ':'
                                if $GIT_INDEX_FILE =~# '/[^/]*index[^/]*\.lock$' && s:cpath(fnamemodify($GIT_INDEX_FILE,':p')[0:strlen(dir)]) ==# s:cpath(dir . '/') && filereadable($GIT_INDEX_FILE)
                                  let f = fnamemodify($GIT_INDEX_FILE, ':p')
                                else
                                  let f = fugitive#Find('.git/index', dir)
                                endif
                              elseif rev =~# '^:(\%(top\|top,literal\|literal,top\|literal\))'
                                let f = base . '/' . matchstr(rev, ')\zs.*')
                              elseif rev =~# '^:/\@!'
                                let f = 'fugitive://' . dir . '//0/' . rev[1:-1]
                              else
                                if rev =~# 'HEAD$\|^refs/' && rev !~# ':'
                                  let cdir = rev =~# '^refs/' ? fugitive#CommonDir(dir) : dir
                                  if filereadable(cdir . '/' . rev)
                                    let f = simplify(cdir . '/' . rev)
                                  endif
                                endif
                                if !exists('f')
                                  let commit = substitute(matchstr(rev, '^[^:]\+\|^:.*'), '^@\%($\|[~^]\|@{\)\@=', 'HEAD', '')
                                  let file = substitute(matchstr(rev, '^[^:]\+\zs:.*'), '^:', '/', '')
                                  if file =~# '^/\.\.\=\%(/\|$\)\|^//\|^/\a\+:'
                                    let file = file =~# '^/\.' ? simplify(getcwd() . file) : file[1:-1]
                                    if s:cpath(base . '/', (file . '/')[0 : len(base)])
                                      let file = '/' . strpart(file, len(base) + 1)
                                    else
                                      let altdir = FugitiveExtractGitDir(file)
                                      if len(altdir) && !s:cpath(dir, altdir)
                                        return fugitive#Find(a:object, altdir)
                                      endif
                                      return file
                                    endif
                                  endif
                                  if commit !~# '^[0-9a-f]\{40\}$'
                                    let commit = system(s:Prepare(dir, 'rev-parse', '--verify', commit, '--'))[0:-2]
                                    let commit = v:shell_error ? '' : commit
                                  endif
                                  if len(commit)
                                    let f = 'fugitive://' . dir . '//' . commit . file
                                  else
                                    let f = base . '/' . substitute(rev, '^:/:\=\|^[^:]\+:', '', '')
                                  endif
                                endif
                              endif
 1278   0.036699   0.016042   return s:PlatformSlash(f)

FUNCTION  airline#util#strchars()
Called 5 times
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
    5              0.000024   if exists('*strchars')
    5              0.000017     return strchars(a:str)
                              else
                                return strlen(substitute(a:str, '.', 'a', 'g'))
                              endif

FUNCTION  231()
Called 1 time
Total time:   0.000062
 Self time:   0.000015

count  total (s)   self (s)
    1   0.000056   0.000009     if !s:NERDTree.IsOpen()
                                    throw "NERDTree.TreeNotOpen"
                                endif

FUNCTION  233()
Called 49 times
Total time:   0.000757
 Self time:   0.000757

count  total (s)   self (s)
   49              0.000364     if !exists('s:NERDTree._PathFilters')
                                    let s:NERDTree._PathFilters = []
                                endif
   49              0.000132     return s:NERDTree._PathFilters

FUNCTION  236()
Called 1 time
Total time:   0.022196
 Self time:   0.000024

count  total (s)   self (s)
    1   0.022194   0.000023     call self.ui.render()

FUNCTION  238()
Called 1 time
Total time:   0.000408
 Self time:   0.000397

count  total (s)   self (s)
    1   0.000025   0.000020     if self.getShowHelp()
                                    let help  = "\" NERDTree (" . nerdtree#version() . ") quickhelp~\n"
                                    let help .= "\" ============================\n"
                                    let help .= "\" File node mappings~\n"
                                    let help .= "\" ". (g:NERDTreeMouseMode ==# 3 ? "single" : "double") ."-click,\n"
                                    let help .= "\" <CR>,\n"
                                    if self.nerdtree.isTabTree()
                                        let help .= "\" ". g:NERDTreeMapActivateNode .": open in prev window\n"
                                    else
                                        let help .= "\" ". g:NERDTreeMapActivateNode .": open in current window\n"
                                    endif
                                    if self.nerdtree.isTabTree()
                                        let help .= "\" ". g:NERDTreeMapPreview .": preview\n"
                                    endif
                                    let help .= "\" ". g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= "\" ". g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= "\" middle-click,\n"
                                    let help .= "\" ". g:NERDTreeMapOpenSplit .": open split\n"
                                    let help .= "\" ". g:NERDTreeMapPreviewSplit .": preview split\n"
                                    let help .= "\" ". g:NERDTreeMapOpenVSplit .": open vsplit\n"
                                    let help .= "\" ". g:NERDTreeMapPreviewVSplit .": preview vsplit\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Directory node mappings~\n"
                                    let help .= "\" ". (g:NERDTreeMouseMode ==# 1 ? "double" : "single") ."-click,\n"
                                    let help .= "\" ". g:NERDTreeMapActivateNode .": open & close node\n"
                                    let help .= "\" ". g:NERDTreeMapOpenRecursively .": recursively open node\n"
                                    let help .= "\" ". g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= "\" ". g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= "\" ". g:NERDTreeMapCloseDir .": close parent of node\n"
                                    let help .= "\" ". g:NERDTreeMapCloseChildren .": close all child nodes of\n"
                                    let help .= "\"    current node recursively\n"
                                    let help .= "\" middle-click,\n"
                                    let help .= "\" ". g:NERDTreeMapOpenExpl.": explore selected dir\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Bookmark table mappings~\n"
                                    let help .= "\" double-click,\n"
                                    let help .= "\" ". g:NERDTreeMapActivateNode .": open bookmark\n"
                                    let help .= "\" ". g:NERDTreeMapPreview .": preview file\n"
                                    let help .= "\" ". g:NERDTreeMapPreview .": find dir in tree\n"
                                    let help .= "\" ". g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= "\" ". g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= "\" ". g:NERDTreeMapDeleteBookmark .": delete bookmark\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Tree navigation mappings~\n"
                                    let help .= "\" ". g:NERDTreeMapJumpRoot .": go to root\n"
                                    let help .= "\" ". g:NERDTreeMapJumpParent .": go to parent\n"
                                    let help .= "\" ". g:NERDTreeMapJumpFirstChild  .": go to first child\n"
                                    let help .= "\" ". g:NERDTreeMapJumpLastChild   .": go to last child\n"
                                    let help .= "\" ". g:NERDTreeMapJumpNextSibling .": go to next sibling\n"
                                    let help .= "\" ". g:NERDTreeMapJumpPrevSibling .": go to prev sibling\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Filesystem mappings~\n"
                                    let help .= "\" ". g:NERDTreeMapChangeRoot .": change tree root to the\n"
                                    let help .= "\"    selected dir\n"
                                    let help .= "\" ". g:NERDTreeMapUpdir .": move tree root up a dir\n"
                                    let help .= "\" ". g:NERDTreeMapUpdirKeepOpen .": move tree root up a dir\n"
                                    let help .= "\"    but leave old root open\n"
                                    let help .= "\" ". g:NERDTreeMapRefresh .": refresh cursor dir\n"
                                    let help .= "\" ". g:NERDTreeMapRefreshRoot .": refresh current root\n"
                                    let help .= "\" ". g:NERDTreeMapMenu .": Show menu\n"
                                    let help .= "\" ". g:NERDTreeMapChdir .":change the CWD to the\n"
                                    let help .= "\"    selected dir\n"
                                    let help .= "\" ". g:NERDTreeMapCWD .":change tree root to CWD\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Tree filtering mappings~\n"
                                    let help .= "\" ". g:NERDTreeMapToggleHidden .": hidden files (" . (self.getShowHidden() ? "on" : "off") . ")\n"
                                    let help .= "\" ". g:NERDTreeMapToggleFilters .": file filters (" . (self.isIgnoreFilterEnabled() ? "on" : "off") . ")\n"
                                    let help .= "\" ". g:NERDTreeMapToggleFiles .": files (" . (self.getShowFiles() ? "on" : "off") . ")\n"
                                    let help .= "\" ". g:NERDTreeMapToggleBookmarks .": bookmarks (" . (self.getShowBookmarks() ? "on" : "off") . ")\n"
                            
                                    " add quickhelp entries for each custom key map
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Custom mappings~\n"
                                    for i in g:NERDTreeKeyMap.All()
                                        if !empty(i.quickhelpText)
                                            let help .= "\" ". i.key .": ". i.quickhelpText ."\n"
                                        endif
                                    endfor
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Other mappings~\n"
                                    let help .= "\" ". g:NERDTreeMapQuit .": Close the NERDTree window\n"
                                    let help .= "\" ". g:NERDTreeMapToggleZoom .": Zoom (maximize-minimize)\n"
                                    let help .= "\"    the NERDTree window\n"
                                    let help .= "\" ". g:NERDTreeMapHelp .": toggle help\n"
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Bookmark commands~\n"
                                    let help .= "\" :Bookmark [<name>]\n"
                                    let help .= "\" :BookmarkToRoot <name>\n"
                                    let help .= "\" :RevealBookmark <name>\n"
                                    let help .= "\" :OpenBookmark <name>\n"
                                    let help .= "\" :ClearBookmarks [<names>]\n"
                                    let help .= "\" :ClearAllBookmarks\n"
                                    let help .= "\" :ReadBookmarks\n"
                                    let help .= "\" :WriteBookmarks\n"
                                    let help .= "\" :EditBookmarks\n"
                                    silent! put =help
                                elseif !self.isMinimal()
                                    let help ="\" Press ". g:NERDTreeMapHelp ." for help\n"
                                    silent! put =help
                                endif

FUNCTION  gitgutter#async#execute()
Called 2 times
Total time:   0.025023
 Self time:   0.024853

count  total (s)   self (s)
    2   0.000176   0.000035   call gitgutter#debug#log('[async] '.a:cmd)
                            
    2              0.000018   let options = {   'stdoutbuffer': [],   'buffer': a:bufnr,   'handler': a:handler }
    2   0.000238   0.000209   let command = s:build_command(a:cmd)
                            
    2              0.000012   if has('nvim')
    2              0.024434     call jobstart(command, extend(options, {   'on_stdout': function('s:on_stdout_nvim'),   'on_stderr': function('s:on_stderr_nvim'),   'on_exit':   function('s:on_exit_nvim') }))
    2              0.000022   else
                                call job_start(command, {   'out_cb':   function('s:on_stdout_vim', options),   'err_cb':   function('s:on_stderr_vim', options),   'close_cb': function('s:on_exit_vim', options) })
                              endif

FUNCTION  <SNR>87_invoke_funcrefs()
Called 8 times
Total time:   0.104998
 Self time:   0.000862

count  total (s)   self (s)
    8   0.000534   0.000099   let builder = airline#builder#new(a:context)
    8   0.015111   0.000202   let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
    8              0.000017   if err == 1
    8   0.088936   0.000145     let a:context.line = builder.build()
    8              0.000103     let s:contexts[a:context.winnr] = a:context
    8              0.000068     let option = get(g:, 'airline_statusline_ontop', 0) ? '&tabline' : '&statusline'
    8              0.000187     call setwinvar(a:context.winnr, option, '%!airline#statusline('.a:context.winnr.')')
    8              0.000013   endif

FUNCTION  ale#lsp_linter#HandleLSPResponse()
Called 12 times
Total time:   0.053752
 Self time:   0.001144

count  total (s)   self (s)
   12              0.000108     let l:method = get(a:response, 'method', '')
                            
   12              0.000105     if get(a:response, 'jsonrpc', '') is# '2.0' && has_key(a:response, 'error')
                                    let l:linter_name = get(s:lsp_linter_map, a:conn_id, '')
                            
                                    call s:HandleLSPErrorMessage(l:linter_name, a:response)
                                elseif l:method is# 'textDocument/publishDiagnostics'
                                    call s:HandleLSPDiagnostics(a:conn_id, a:response)
                                elseif get(a:response, 'type', '') is# 'event'&& get(a:response, 'event', '') is# 'semanticDiag'
    3   0.033017   0.000080         call s:HandleTSServerDiagnostics(a:response, 'semantic')
    3              0.000023     elseif get(a:response, 'type', '') is# 'event'&& get(a:response, 'event', '') is# 'syntaxDiag'
    3   0.019765   0.000094         call s:HandleTSServerDiagnostics(a:response, 'syntax')
    3              0.000005     endif

FUNCTION  airline#extensions#wordcount#apply()
Called 4 times
Total time:   0.000263
 Self time:   0.000263

count  total (s)   self (s)
    4              0.000065   let filetypes = get(g:, 'airline#extensions#wordcount#filetypes',  ['asciidoc', 'help', 'mail', 'markdown', 'org', 'rst', 'tex', 'text'])
                              " export current filetypes settings to global namespace
    4              0.000018   let g:airline#extensions#wordcount#filetypes = filetypes
                            
                              " Check if filetype needs testing
    4              0.000015   if did_filetype()
                            
                                " Select test based on type of "filetypes": new=list, old=string
                                if type(filetypes) == get(v:, 't_list', type([])) ? index(filetypes, &filetype) > -1 || index(filetypes, 'all') > -1 : match(&filetype, filetypes) > -1
                                  let b:airline_changedtick = -1
                                  call s:update_wordcount(1) " force update: ensures initial worcount exists
                                elseif exists('b:airline_wordcount') " cleanup when filetype is removed
                                  unlet b:airline_wordcount
                                endif
                              endif
                            
    4              0.000017   if exists('b:airline_wordcount')
                                call airline#extensions#prepend_to_section( 'z', '%{airline#extensions#wordcount#get()}')
                              endif

FUNCTION  <SNR>119_CloseCompletionMenu()
Called 890 times
Total time:   0.011567
 Self time:   0.011567

count  total (s)   self (s)
  890              0.004071   if pumvisible()
                                call s:SendKeys( "\<C-e>" )
                              endif

FUNCTION  <SNR>166_syn_eol()
Called 2 times
Total time:   0.000159
 Self time:   0.000159

count  total (s)   self (s)
    2              0.000008   let lnum = prevnonblank(a:lnum)
    2              0.000008   let col = strlen(getline(lnum))
    2              0.000140   return map(synstack(lnum, col), 'synIDattr(v:val, "name")')

FUNCTION  <SNR>129_alternatePair()
Called 1 time
Total time:   0.000154
 Self time:   0.000089

count  total (s)   self (s)
    1              0.000007   let pos = getpos('.')[1:2]
    1              0.000014   while search('\m[][(){}]','bW',a:stop)
    1   0.000046   0.000010 	if !s:skip_func()
    1   0.000024   0.000016 	  let idx = stridx('])}',s:looking_at())
    1              0.000002 	  if idx + 1
    1   0.000045   0.000024 		if s:GetPair(['\[','(','{'][idx], '])}'[idx],'bW','s:skip_func()',2000,a:stop) <= 0
    1              0.000002 		  break
                            		endif
                            	  else
                            		return
                            	  endif
                            	endif
                              endwhile
    1              0.000006   call call('cursor',pos)

FUNCTION  <SNR>164_save_last_seen_change()
Called 2 times
Total time:   0.000109
 Self time:   0.000031

count  total (s)   self (s)
    2   0.000107   0.000029   call gitgutter#utility#setbufvar(a:bufnr, 'tick', getbufvar(a:bufnr, 'changedtick'))

FUNCTION  <SNR>96_check_mixed_indent()
Called 1 time
Total time:   0.000942
 Self time:   0.000942

count  total (s)   self (s)
    1              0.000010   let indent_algo = get(g:, 'airline#extensions#whitespace#mixed_indent_algo', 0)
    1              0.000003   if indent_algo == 1
                                " [<tab>]<space><tab>
                                " spaces before or between tabs are not allowed
                                let t_s_t = '(^\t* +\t\s*\S)'
                                " <tab>(<space> x count)
                                " count of spaces at the end of tabs should be less than tabstop value
                                let t_l_s = '(^\t+ {' . &ts . ',}' . '\S)'
                                return search('\v' . t_s_t . '|' . t_l_s, 'nw')
                              elseif indent_algo == 2
                                return search('\v(^\t* +\t\s*\S)', 'nw')
                              else
    1              0.000904     return search('\v(^\t+ +)|(^ +\t+)', 'nw')
                              endif

FUNCTION  <SNR>149_GatherOutput()
Called 3 times
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
    3              0.000035     call add(a:line_list, a:line)

FUNCTION  243()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003     return self._showBookmarks

FUNCTION  244()
Called 49 times
Total time:   0.000234
 Self time:   0.000234

count  total (s)   self (s)
   49              0.000195     return self._showFiles

FUNCTION  245()
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000004     return self._showHelp

FUNCTION  246()
Called 49 times
Total time:   0.000198
 Self time:   0.000198

count  total (s)   self (s)
   49              0.000156     return self._showHidden

FUNCTION  249()
Called 49 times
Total time:   0.000222
 Self time:   0.000222

count  total (s)   self (s)
   49              0.000180     return self._ignoreEnabled == 1

FUNCTION  <SNR>130_IsStyledDefinition()
Called 1 time
Total time:   0.000281
 Self time:   0.000030

count  total (s)   self (s)
                              " iterate through all syntax items in the given line
    1   0.000265   0.000015   for item in s:SynSOL(a:lnum)
                                " if syntax-item is a jsTemplateString return 1 - true
                                " `==#` is a match case comparison of the item
                                if item ==# 'styledDefinition'
                                  return 1
                                endif
                              endfor
                            
                              " fallback to 0 - false
    1              0.000002   return 0

FUNCTION  <SNR>161_syn_name()
Called 8 times
Total time:   0.005145
 Self time:   0.005145

count  total (s)   self (s)
    8              0.005069   let syn_id = get(synstack(a:lnum, a:cnum), -1)
    8              0.000061   return synIDattr(syn_id, "name")

FUNCTION  <SNR>108_build_sections()
Called 12 times
Total time:   0.009169
 Self time:   0.001401

count  total (s)   self (s)
   56              0.000168   for key in a:keys
   44              0.000275     if (key == 'warning' || key == 'error') && !a:context.active
                                  continue
                                endif
   44   0.008322   0.000555     call s:add_section(a:builder, a:context, key)
   44              0.000090   endfor

FUNCTION  ale#command#CreateTempFile()
Called 7 times
Total time:   0.005954
 Self time:   0.004366

count  total (s)   self (s)
    7              0.000033     if empty(a:temporary_file)
                                    " There is no file, so we didn't create anything.
    3              0.000006         return 0
                                endif
                            
                                " Use an existing list of lines of input if we have it, or get the lines
                                " from the file.
    4              0.000087     let l:lines = a:input isnot v:null ? a:input : getbufline(a:buffer, 1, '$')
                            
    4              0.000025     let l:temporary_directory = fnamemodify(a:temporary_file, ':h')
                                " Create the temporary directory for the file, unreadable by 'other'
                                " users.
    4              0.003983     call mkdir(l:temporary_directory, '', 0750)
                                " Automatically delete the directory later.
    4   0.000252   0.000084     call ale#command#ManageDirectory(a:buffer, l:temporary_directory)
                                " Write the buffer out to a file.
    4   0.001493   0.000072     call ale#util#Writefile(a:buffer, l:lines, a:temporary_file)
                            
    4              0.000016     return 1

FUNCTION  <SNR>138_on_stderr_nvim()
Called 2 times
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    2              0.000011   if a:data != ['']  " With Neovim there is always [''] reported on stderr.
                                call self.handler.err(self.buffer)
                              endif

FUNCTION  ale#lsp_linter#GetConfig()
Called 2 times
Total time:   0.000080
 Self time:   0.000080

count  total (s)   self (s)
    2              0.000016     if has_key(a:linter, 'lsp_config_callback')
                                    return ale#util#GetFunction(a:linter.lsp_config_callback)(a:buffer)
                                endif
                            
    2              0.000008     if has_key(a:linter, 'lsp_config')
                                    let l:Config = a:linter.lsp_config
                            
                                    if type(l:Config) is v:t_func
                                        let l:Config = l:Config(a:buffer)
                                    endif
                            
                                    return l:Config
                                endif
                            
    2              0.000004     return {}

FUNCTION  <SNR>138_build_command()
Called 2 times
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    2              0.000015   if has('unix')
    2              0.000011     return ['sh', '-c', a:cmd]
                              endif
                            
                              if has('win32')
                                return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                              endif
                            
                              throw 'unknown os'

FUNCTION  ale#cursor#EchoCursorWarning()
Called 5 times
Total time:   0.003010
 Self time:   0.000563

count  total (s)   self (s)
    5              0.000039     let l:buffer = bufnr('')
                            
    5              0.000018     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
                                endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
    5              0.000047     if mode(1) isnot# 'n'
    1              0.000001         return
                                endif
                            
    4   0.000930   0.000058     if ale#ShouldDoNothing(l:buffer)
                                    return
                                endif
                            
    4   0.001088   0.000073     let [l:info, l:loc] = ale#util#FindItemAtCursor(l:buffer)
                            
    4              0.000011     if g:ale_echo_cursor
    4              0.000015         if !empty(l:loc)
    1   0.000045   0.000015             let l:format = ale#Var(l:buffer, 'echo_msg_format')
    1   0.000151   0.000021             let l:msg = ale#GetLocItemMessage(l:loc, l:format)
    1   0.000429   0.000028             call ale#cursor#TruncatedEcho(l:msg)
    1              0.000005             let l:info.echoed = 1
    1              0.000004         elseif get(l:info, 'echoed')
                                        " We'll only clear the echoed message when moving off errors once,
                                        " so we don't continually clear the echo line.
                                        execute 'echo'
                                        let l:info.echoed = 0
                                    endif
    4              0.000003     endif
                            
    4              0.000008     if g:ale_cursor_detail
                                    if !empty(l:loc)
                                        call s:ShowCursorDetailForItem(l:loc, {'stay_here': 1})
                                    else
                                        call ale#preview#CloseIfTypeMatches('ale-preview')
                                    endif
                                endif

FUNCTION  <lambda>1()
Called 2 times
Total time:   0.001145
 Self time:   0.000054

count  total (s)   self (s)
    2   0.001142   0.000051 return ale#node#FindExecutable(b, 'typescript_tsserver', [       'node_modules/.bin/tsserver',   ])

FUNCTION  airline#async#nvim_vcs_clean()
Called 4 times
Total time:   0.011154
 Self time:   0.010918

count  total (s)   self (s)
    4   0.000463   0.000278     let config = { 'buf': '', 'vcs': a:vcs, 'file': a:file, 'cwd': s:valid_dir(fnamemodify(a:file, ':p:h')), 'on_stdout': function('s:nvim_output_handler'), 'on_stderr': function('s:nvim_output_handler'), 'on_exit': function('s:on_exit_clean')}
    4              0.000019     if g:airline#init#is_windows && &shell =~ 'cmd'
                                  let cmd = a:cmd
                                else
    4              0.000023       let cmd = ['sh', '-c', a:cmd]
    4              0.000006     endif
                            
    4              0.000030     if !has_key(s:clean_jobs, a:vcs)
                                  let s:clean_jobs[a:vcs] = {}
                                endif
    4              0.000093     if has_key(s:clean_jobs[a:vcs], a:file)
                                  " still running
    3              0.000005       return
                                  " jobs dict should be cleaned on exit, so not needed here
                                  " call remove(s:clean_jobs[a:vcs], a:file)
                                endif
    1              0.010268     let id = jobstart(cmd, config)
    1   0.000162   0.000111     call s:set_clean_jobs_variable(a:vcs, a:file, id)

FUNCTION  airline#extensions#tabline#builder#new()
Called 1 time
Total time:   0.000130
 Self time:   0.000051

count  total (s)   self (s)
    1   0.000100   0.000020   let builder = airline#builder#new(a:context)
    1              0.000006   let builder._build = builder.build
    1              0.000019   call extend(builder, s:prototype, 'force')
    1              0.000003   return builder

FUNCTION  ale#lsp#tsserver_message#Geterr()
Called 2 times
Total time:   0.000233
 Self time:   0.000233

count  total (s)   self (s)
    2              0.000231     return [1, 'ts@geterr', {'files': [expand('#' . a:buffer . ':p')]}]

FUNCTION  <SNR>129_iscontOne()
Called 1 time
Total time:   0.000335
 Self time:   0.000073

count  total (s)   self (s)
    1              0.000010   let [l:i, l:num, bL] = [a:i, a:num + !a:num, 0]
    1              0.000006   let pind = a:num ? indent(l:num) + s:W : 0
    1              0.000007   let ind = indent(l:i) + (a:cont ? 0 : s:W)
    1              0.000005   while l:i >= l:num && (ind > pind || l:i == l:num)
    1   0.000283   0.000022 	if indent(l:i) < ind && s:OneScope(l:i)
                            	  let bL += s:W
                            	  let l:i = line('.')
                            	elseif !a:cont || bL || ind < indent(a:i)
    1              0.000001 	  break
                            	endif
                            	let ind = min([ind, indent(l:i)])
                            	let l:i = s:PrevCodeLine(l:i - 1)
                              endwhile
    1              0.000001   return bL

FUNCTION  <SNR>150_FilterResult()
Called 1 time
Total time:   0.000079
 Self time:   0.000046

count  total (s)   self (s)
    1   0.000053   0.000020     if ale#Var(a:buffer, 'javascript_eslint_suppress_eslintignore')
                                    if a:obj.text =~# '^File ignored'
                                        return 0
                                    endif
                                endif
                            
    1              0.000009     if has_key(a:obj, 'code') && a:obj.code is# 'no-trailing-spaces'&& !ale#Var(a:buffer, 'warn_about_trailing_whitespace')
                                    return 0
                                endif
                            
    1              0.000002     return 1

FUNCTION  <SNR>155_CheckWithLSP()
Called 2 times
Total time:   0.001132
 Self time:   0.000287

count  total (s)   self (s)
    2              0.000011     let l:buffer = a:details.buffer
    2              0.000015     let l:info = get(g:ale_buffer_info, l:buffer)
                            
    2              0.000007     if empty(l:info)
                                    return
                                endif
                            
    2              0.000007     let l:id = a:details.connection_id
                            
                                " Register a callback now for handling errors now.
    2              0.000015     let l:Callback = function('ale#lsp_linter#HandleLSPResponse')
    2   0.000106   0.000041     call ale#lsp#RegisterCallback(l:id, l:Callback)
                            
                                " Remember the linter this connection is for.
    2              0.000014     let s:lsp_linter_map[l:id] = a:linter.name
                            
    2              0.000008     if a:linter.lsp is# 'tsserver'
    2   0.000273   0.000040         let l:message = ale#lsp#tsserver_message#Geterr(l:buffer)
    2   0.000482   0.000034         let l:notified = ale#lsp#Send(l:id, l:message) != 0
                            
    2              0.000004         if l:notified
    2   0.000122   0.000023             call ale#engine#MarkLinterActive(l:info, a:linter)
    2              0.000002         endif
    2              0.000002     else
                                    let l:notified = ale#lsp#NotifyForChanges(l:id, l:buffer)
                                endif
                            
                                " If this was a file save event, also notify the server of that.
    2              0.000010     if a:linter.lsp isnot# 'tsserver'&& getbufvar(l:buffer, 'ale_save_event_fired', 0)
                                    let l:save_message = ale#lsp#message#DidSave(l:buffer)
                                    let l:notified = ale#lsp#Send(l:id, l:save_message) != 0
                                endif

FUNCTION  250()
Called 3 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    3              0.000011     return g:NERDTreeMinimalUI

FUNCTION  257()
Called 1 time
Total time:   0.022172
 Self time:   0.000562

count  total (s)   self (s)
    1              0.000033     setlocal noreadonly modifiable
                            
                                " remember the top line of the buffer and the current line so we can
                                " restore the view exactly how it was
    1              0.000008     let curLine = line(".")
    1              0.000006     let curCol = col(".")
    1              0.000006     let topLine = line("w0")
                            
                                " delete all lines in the buffer (being careful not to clobber a register)
    1              0.000103     silent 1,$delete _
                            
    1   0.000434   0.000026     call self._dumpHelp()
                            
                                " delete the blank line before the help and add one after it
    1   0.000016   0.000012     if !self.isMinimal()
                                    call setline(line(".")+1, "")
                                    call cursor(line(".")+1, col("."))
                                endif
                            
    1   0.000019   0.000015     if self.getShowBookmarks()
                                    call self._renderBookmarks()
                                endif
                            
                                " add the 'up a dir' line
    1   0.000012   0.000009     if !self.isMinimal()
                                    call setline(line(".")+1, s:UI.UpDirLine())
                                    call cursor(line(".")+1, col("."))
                                endif
                            
                                " draw the header line
    1   0.000564   0.000024     let header = self.nerdtree.root.path.str({'format': 'UI', 'truncateTo': winwidth(0)})
    1              0.000017     call setline(line(".")+1, header)
    1              0.000009     call cursor(line(".")+1, col("."))
                            
                                " draw the tree
    1   0.020761   0.000113     silent put =self.nerdtree.root.renderToString()
                            
                                " delete the blank line at the top of the buffer
    1              0.000026     silent 1,1delete _
                            
                                " restore the view
    1              0.000008     let old_scrolloff=&scrolloff
    1              0.000012     let &scrolloff=0
    1              0.000007     call cursor(topLine, 1)
    1              0.000039     normal! zt
    1              0.000007     call cursor(curLine, curCol)
    1              0.000011     let &scrolloff = old_scrolloff
                            
    1              0.000013     setlocal readonly nomodifiable

FUNCTION  airline#statusline()
Called 653 times
Total time:   0.017873
 Self time:   0.017873

count  total (s)   self (s)
  653              0.007160   if has_key(s:contexts, a:winnr)
  653              0.009300     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  ale#path#FindNearestFile()
Called 22 times
Total time:   0.010996
 Self time:   0.010996

count  total (s)   self (s)
   22              0.002452     let l:buffer_filename = fnamemodify(bufname(a:buffer), ':p')
   22              0.000248     let l:buffer_filename = fnameescape(l:buffer_filename)
                            
   22              0.007047     let l:relative_path = findfile(a:filename, l:buffer_filename . ';')
                            
   22              0.000145     if !empty(l:relative_path)
   10              0.000904         return fnamemodify(l:relative_path, ':p')
                                endif
                            
   12              0.000020     return ''

FUNCTION  <lambda>13()
Called 1 time
Total time:   0.011270
 Self time:   0.000047

count  total (s)   self (s)
    1   0.011269   0.000046 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <lambda>15()
Called 1 time
Total time:   0.009967
 Self time:   0.000068

count  total (s)   self (s)
    1   0.009965   0.000066 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <lambda>17()
Called 1 time
Total time:   0.008190
 Self time:   0.000073

count  total (s)   self (s)
    1   0.008188   0.000072 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  ale#statusline#FirstProblem()
Called 622 times
Total time:   0.061672
 Self time:   0.020979

count  total (s)   self (s)
  622   0.048892   0.008199     let l:first_problems = s:GetFirstProblems(a:buffer)
                            
  622              0.004946     if !empty(l:first_problems) && has_key(l:first_problems, a:type)
  622              0.006162         return copy(l:first_problems[a:type])
                                endif
                            
                                return {}

FUNCTION  ale#fix#ApplyQueuedFixes()
Called 1 time
Total time:   0.017692
 Self time:   0.000413

count  total (s)   self (s)
    1              0.000017     let l:data = get(g:ale_fix_buffer_data, a:buffer, {'done': 0})
    1              0.000011     let l:has_bufline_api = exists('*deletebufline') && exists('*setbufline')
                            
    1              0.000009     if !l:data.done || (!l:has_bufline_api && a:buffer isnot bufnr(''))
                                    return
                                endif
                            
    1              0.000009     call remove(g:ale_fix_buffer_data, a:buffer)
                            
    1              0.000003     if l:data.changes_made
                                    " If the file is in DOS mode, we have to remove carriage returns from
                                    " the ends of lines before calling setline(), or we will see them
                                    " twice.
                                    let l:new_lines = getbufvar(a:buffer, '&fileformat') is# 'dos'   ? map(copy(l:data.output), 'substitute(v:val, ''\r\+$'', '''', '''')')   : l:data.output
                                    let l:first_line_to_remove = len(l:new_lines) + 1
                            
                                    " Use a Vim API for setting lines in other buffers, if available.
                                    if l:has_bufline_api
                                        call setbufline(a:buffer, 1, l:new_lines)
                                        call deletebufline(a:buffer, l:first_line_to_remove, '$')
                                    " Fall back on setting lines the old way, for the current buffer.
                                    else
                                        let l:old_line_length = len(l:data.lines_before)
                            
                                        if l:old_line_length >= l:first_line_to_remove
                                            let l:save = winsaveview()
                                            silent execute   l:first_line_to_remove . ',' . l:old_line_length . 'd_'
                                            call winrestview(l:save)
                                        endif
                            
                                        call setline(1, l:new_lines)
                                    endif
                            
                                    if l:data.should_save
                                        if a:buffer is bufnr('')
                                            if empty(&buftype)
                                                noautocmd :w!
                                            else
                                                set nomodified
                                            endif
                                        else
                                            call writefile(l:new_lines, expand(a:buffer . ':p')) " no-custom-checks
                                            call setbufvar(a:buffer, '&modified', 0)
                                        endif
                                    endif
                                endif
                            
    1              0.000003     if l:data.should_save
    1   0.000099   0.000034         let l:should_lint = ale#Var(a:buffer, 'fix_on_save')   && ale#Var(a:buffer, 'lint_on_save')
    1              0.000002     else
                                    let l:should_lint = l:data.changes_made
                                endif
                            
    1   0.000173   0.000128     silent doautocmd <nomodeline> User ALEFixPost
                            
                                " If ALE linting is enabled, check for problems with the file again after
                                " fixing problems.
    1   0.000035   0.000022     if g:ale_enabled&& l:should_lint&& !ale#events#QuitRecently(a:buffer)
    1   0.017182   0.000026         call ale#Queue(0, l:data.should_save ? 'lint_file' : '')
    1              0.000002     endif

FUNCTION  ale#lsp#StartProgram()
Called 2 times
Total time:   0.000263
 Self time:   0.000162

count  total (s)   self (s)
    2              0.000014     let l:conn = s:connections[a:conn_id]
    2              0.000006     let l:started = 0
                            
    2   0.000139   0.000038     if !has_key(l:conn, 'job_id') || !ale#job#HasOpenChannel(l:conn.job_id)
                                    let l:options = {   'mode': 'raw',   'out_cb': {_, message -> ale#lsp#HandleMessage(a:conn_id, message)},}
                            
                                    if has('win32')
                                        let l:job_id = ale#job#StartWithCmd(a:command, l:options)
                                    else
                                        let l:job_id = ale#job#Start(a:command, l:options)
                                    endif
                            
                                    let l:started = 1
                                else
    2              0.000008         let l:job_id = l:conn.job_id
    2              0.000002     endif
                            
    2              0.000005     if l:job_id > 0
    2              0.000007         let l:conn.job_id = l:job_id
    2              0.000002     endif
                            
    2              0.000005     if l:started && !l:conn.is_tsserver
                                    call s:SendInitMessage(l:conn)
                                endif
                            
    2              0.000005     return l:job_id > 0

FUNCTION  <SNR>108_add_section()
Called 44 times
Total time:   0.007768
 Self time:   0.002721

count  total (s)   self (s)
   44              0.000398     let condition = (a:key is# "warning" || a:key is# "error") && (v:version == 704 && !has("patch1511"))
                                " i have no idea why the warning section needs special treatment, but it's
                                " needed to prevent separators from showing up
   44   0.001314   0.000476     if ((a:key == 'error' || a:key == 'warning') && empty(s:get_section(a:context.winnr, a:key)))
                                  return
                                endif
   44              0.000078     if condition
                                  call a:builder.add_raw('%(')
                                endif
   44   0.005193   0.000984     call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
   44              0.000100     if condition
                                  call a:builder.add_raw('%)')
                                endif

FUNCTION  ale#Set()
Called 1 time
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
    1              0.000012     let l:full_name = 'ale_' . a:variable_name
                            
    1              0.000008     if !has_key(g:, l:full_name)
    1              0.000012         let g:[l:full_name] = a:default
    1              0.000002     endif

FUNCTION  ale#history#Get()
Called 6 times
Total time:   0.000106
 Self time:   0.000106

count  total (s)   self (s)
    6              0.000099     return copy(getbufvar(a:buffer, 'ale_history', []))

FUNCTION  <SNR>129_continues()
Called 1 time
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
    1              0.000036   return !cursor(a:ln, match(' '.a:con,s:continuation)) && eval( (['s:syn_at(line("."),col(".")) !~? "regex"'] + repeat(['getline(".")[col(".")-2] != tr(s:looking_at(),">","=")'],3) + repeat(['s:previous_token() != "."'],5) + [1])[ index(split('/ > - + typeof in instanceof void delete'),s:token())])

FUNCTION  gitgutter#utility#is_active()
Called 2 times
Total time:   0.002346
 Self time:   0.000147

count  total (s)   self (s)
    2   0.002344   0.000144   return g:gitgutter_enabled && gitgutter#utility#getbufvar(a:bufnr, 'enabled', 1) && !pumvisible() && s:is_file_buffer(a:bufnr) && s:exists_file(a:bufnr) && s:not_git_dir(a:bufnr)

FUNCTION  ale#lsp#tsserver_message#Change()
Called 2 times
Total time:   0.000698
 Self time:   0.000698

count  total (s)   self (s)
    2              0.000115     let l:lines = getbufline(a:buffer, 1, '$')
                            
                                " We will always use a very high endLine number, so we can delete
                                " lines from files. tsserver will gladly accept line numbers beyond the
                                " end.
    2              0.000573     return [1, 'ts@change', {   'file': expand('#' . a:buffer . ':p'),   'line': 1,   'offset': 1,   'endLine': 1073741824,   'endOffset': 1,   'insertString': join(l:lines, "\n") . "\n",}]

FUNCTION  266()
Called 3 times
Total time:   0.000099
 Self time:   0.000099

count  total (s)   self (s)
    3              0.000034     let newObj = copy(self)
    3              0.000013     let newObj.nerdtree = a:nerdtree
    3              0.000012     let newObj.subject = a:subject
    3              0.000014     let newObj.action = a:action
    3              0.000012     let newObj.params = a:params
    3              0.000007     return newObj

FUNCTION  airline#extensions#apply()
Called 8 times
Total time:   0.001840
 Self time:   0.000975

count  total (s)   self (s)
    8              0.000079   let filetype_overrides = get(s:, 'filetype_overrides', {})
    8              0.000113   call extend(filetype_overrides, get(g:, 'airline_filetype_overrides', {}), 'force')
                            
    8   0.000974   0.000109   if s:is_excluded_window()
                                return -1
                              endif
                            
    8              0.000032   if &buftype == 'terminal'
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                              endif
                            
    8              0.000019   if &previewwindow
                                let w:airline_section_a = 'Preview'
                                let w:airline_section_b = ''
                                let w:airline_section_c = bufname(winbufnr(winnr()))
                              endif
                            
    8              0.000087   if has_key(filetype_overrides, &ft) && ((&filetype == 'help' && &buftype == 'help') || &filetype !~ 'help')
                                " for help files only override it, if the buftype is also of type 'help',
                                " else it would trigger when editing Vim help files
                                let args = filetype_overrides[&ft]
                                call airline#extensions#apply_left_override(args[0], args[1])
                              endif
                            
    8              0.000024   if &buftype == 'help'
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                                let w:airline_render_right = 1
                              endif
                            
    8              0.000058   for item in items(s:filetype_regex_overrides)
                                if match(&ft, item[0]) >= 0
                                  call airline#extensions#apply_left_override(item[1][0], item[1][1])
                                endif
                              endfor

FUNCTION  269()
Called 3 times
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
    3              0.000026     if !exists("s:refreshListenersMap")
                                    let s:refreshListenersMap = {}
                                endif
    3              0.000009     return s:refreshListenersMap

FUNCTION  <SNR>164_is_removed()
Called 2 times
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    2              0.000007   return a:from_count > 0 && a:to_count == 0

FUNCTION  ale#lsp#OpenDocument()
Called 2 times
Total time:   0.000109
 Self time:   0.000109

count  total (s)   self (s)
    2              0.000018     let l:conn = get(s:connections, a:conn_id, {})
    2              0.000006     let l:opened = 0
                            
    2              0.000016     if !empty(l:conn) && !has_key(l:conn.open_documents, a:buffer)
                                    if l:conn.is_tsserver
                                        let l:message = ale#lsp#tsserver_message#Open(a:buffer)
                                    else
                                        let l:message = ale#lsp#message#DidOpen(a:buffer, a:language_id)
                                    endif
                            
                                    call ale#lsp#Send(a:conn_id, l:message)
                                    let l:conn.open_documents[a:buffer] = getbufvar(a:buffer, 'changedtick')
                                    let l:opened = 1
                                endif
                            
    2              0.000005     return l:opened

FUNCTION  ale#path#ResolveLocalPath()
Called 1 time
Total time:   0.000525
 Self time:   0.000022

count  total (s)   self (s)
                                " Search for a locally installed file first.
    1   0.000514   0.000010     let l:path = ale#path#FindNearestFile(a:buffer, a:search_string)
                            
                                " If the serach fails, try the global executable instead.
    1              0.000003     if empty(l:path)
    1              0.000003         let l:path = a:global_fallback
    1              0.000001     endif
                            
    1              0.000001     return l:path

FUNCTION  <SNR>165_highlight_name_for_change()
Called 15 times
Total time:   0.000095
 Self time:   0.000095

count  total (s)   self (s)
   15              0.000052   if a:text ==# 'added'
   15              0.000028     return 'GitGutterLineAdded'
                              elseif a:text ==# 'removed'
                                return 'GitGutterLineRemoved'
                              elseif a:text ==# 'removed_first_line'
                                return 'GitGutterLineRemovedFirstLine'
                              elseif a:text ==# 'modified'
                                return 'GitGutterLineModified'
                              elseif a:text ==# 'modified_removed'
                                return 'GitGutterLineModifiedRemoved'
                              elseif a:text ==# 'removed_above_and_below'
                                return 'GitGutterLineRemovedAboveAndBelow'
                              endif

FUNCTION  airline#util#has_lawrencium()
Called 643 times
Total time:   0.005333
 Self time:   0.005333

count  total (s)   self (s)
  643              0.004695   return exists('*lawrencium#statusline')

FUNCTION  <SNR>166_syn_attr_jsx()
Called 2 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    2              0.000012   return a:synattr =~? "^jsx"

FUNCTION  airline#highlighter#get_highlight()
Called 1566 times
Total time:   0.421853
 Self time:   0.208600

count  total (s)   self (s)
 1566              0.051751   let reverse = get(g:, 'airline_gui_mode', '') ==# 'gui' ? synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'gui') : synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')|| synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'term')
 1566              0.010509   if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                let res = s:hl_groups[a:group]
                                return reverse ? [ res[1], res[0], res[3], res[2], res[4] ] : res
                              else
 1566   0.112692   0.018772     let fg = s:get_syn(a:group, 'fg')
 1566   0.111858   0.017325     let bg = s:get_syn(a:group, 'bg')
 1566              0.020519     let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
 1566              0.003063     if reverse
                                  let res = s:get_array(bg, fg, bold ? ['bold'] : a:000)
                                else
 1566   0.043814   0.019013       let res = s:get_array(fg, bg, bold ? ['bold'] : a:000)
 1566              0.001941     endif
 1566              0.001143   endif
 1566              0.010560   let s:hl_groups[a:group] = res
 1566              0.002947   return res

FUNCTION  ale#history#Add()
Called 11 times
Total time:   0.001223
 Self time:   0.001223

count  total (s)   self (s)
   11              0.000062     if g:ale_max_buffer_history_size <= 0
                                    " Don't save anything if the history isn't a positive number.
                                    call setbufvar(a:buffer, 'ale_history', [])
                            
                                    return
                                endif
                            
   11              0.000111     let l:history = getbufvar(a:buffer, 'ale_history', [])
                            
                                " Remove the first item if we hit the max history size.
   11              0.000068     if len(l:history) >= g:ale_max_buffer_history_size
   10              0.000251         let l:history = l:history[1:]
   10              0.000018     endif
                            
   11              0.000145     call add(l:history, {   'status': a:status,   'job_id': a:job_id,   'command': a:command,})
                            
   11              0.000354     call setbufvar(a:buffer, 'ale_history', l:history)

FUNCTION  <SNR>162_set_clean_jobs_variable()
Called 1 time
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
    1              0.000020   if !has_key(s:clean_jobs, a:vcs)
                                let s:clean_jobs[a:vcs] = {}
                              endif
    1              0.000018   let s:clean_jobs[a:vcs][a:file]=a:id

FUNCTION  ale#util#JoinNeovimOutput()
Called 15 times
Total time:   0.061377
 Self time:   0.001161

count  total (s)   self (s)
   15              0.000072     if a:mode is# 'raw'
    8   0.060485   0.000314         call a:callback(a:job, join(a:data, "\n"))
                            
    8              0.000020         return ''
                                endif
                            
    7              0.000052     let l:lines = a:data[:-2]
                            
    7              0.000038     if len(a:data) > 1
    3              0.000029         let l:lines[0] = a:last_line . l:lines[0]
    3              0.000053         let l:new_last_line = a:data[-1]
    3              0.000012     else
    4              0.000069         let l:new_last_line = a:last_line . get(a:data, 0, '')
    4              0.000007     endif
                            
   10              0.000081     for l:line in l:lines
    3   0.000120   0.000075         call a:callback(a:job, l:line)
    3              0.000008     endfor
                            
    7              0.000022     return l:new_last_line

FUNCTION  gitgutter#diff#parse_diff()
Called 2 times
Total time:   0.000931
 Self time:   0.000350

count  total (s)   self (s)
    2              0.000008   let hunks = []
   12              0.000056   for line in split(a:diff, '\n')
   10   0.000739   0.000158     let hunk_info = gitgutter#diff#parse_hunk(line)
   10              0.000035     if len(hunk_info) == 4
   10              0.000037       call add(hunks, hunk_info)
   10              0.000011     endif
   10              0.000010   endfor
    2              0.000003   return hunks

FUNCTION  airline#extensions#ctrlp#load_theme()
Called 2 times
Total time:   0.010013
 Self time:   0.000552

count  total (s)   self (s)
    2              0.000015   if exists('a:palette.ctrlp')
    2              0.000009     let theme = a:palette.ctrlp
    2              0.000003   else
                                let s:color_template = has_key(a:palette, s:color_template) ? s:color_template : 'insert'
                                let theme = airline#extensions#ctrlp#generate_color_map( a:palette[s:color_template]['airline_c'], a:palette[s:color_template]['airline_b'], a:palette[s:color_template]['airline_a'])
                              endif
   20              0.000076   for key in keys(theme)
   18   0.009821   0.000360     call airline#highlighter#exec(key, theme[key])
   18              0.000034   endfor

FUNCTION  airline#util#shorten()
Called 1917 times
Total time:   0.112442
 Self time:   0.070944

count  total (s)   self (s)
 1917   0.070548   0.029050   if airline#util#winwidth() < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
                                if get(a:000, 0, 0)
                                  " shorten from tail
                                  return '…'.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                else
                                  " shorten from beginning of string
                                  return matchstr(a:text, '^.\{'.a:minwidth.'}').'…'
                                endif
                              else
 1917              0.004640     return a:text
                              endif

FUNCTION  270()
Called 3 times
Total time:   0.000126
 Self time:   0.000070

count  total (s)   self (s)
    3   0.000101   0.000045     let listenersMap = s:Notifier.GetListenersMap()
    3              0.000022     return get(listenersMap, a:name, [])

FUNCTION  <SNR>119_Pyeval()
Called 1588 times
Total time:   1.788063
 Self time:   1.788063

count  total (s)   self (s)
 1588              0.006249   if s:using_python3
 1588              1.778936     return py3eval( a:eval_string )
                              endif
                              return pyeval( a:eval_string )

FUNCTION  ale#linter#GetExecutable()
Called 10 times
Total time:   0.007226
 Self time:   0.000400

count  total (s)   self (s)
   10              0.000140     let l:Executable = has_key(a:linter, 'executable_callback')   ? function(a:linter.executable_callback)   : a:linter.executable
                            
   10   0.007064   0.000238     return type(l:Executable) is v:t_func   ? l:Executable(a:buffer)   : l:Executable

FUNCTION  <SNR>104_get_array()
Called 1566 times
Total time:   0.024801
 Self time:   0.024801

count  total (s)   self (s)
 1566              0.010516   let opts=empty(a:opts) ? '' : join(a:opts, ',')
 1566              0.012537   return g:airline_gui_mode ==# 'gui' ? [ a:fg, a:bg, '', '', opts ] : [ '', '', a:fg, a:bg, opts ]

FUNCTION  jsx_pretty#indent#get()
Called 1 time
Total time:   0.002237
 Self time:   0.000448

count  total (s)   self (s)
    1              0.000005   let lnum = v:lnum
    1              0.000086   let line = substitute(getline(lnum), '^\s*\|\s*$', '', 'g')
    1   0.000179   0.000023   let current_syn = s:syn_sol(lnum)
    1   0.000152   0.000016   let current_syn_eol = s:syn_eol(lnum)
    1   0.000056   0.000009   let prev_syn_sol = s:syn_sol(lnum - 1)
    1   0.000033   0.000010   let prev_syn_eol = s:syn_eol(lnum - 1)
    1   0.000039   0.000013   let prev_line = s:prev_line(lnum)
    1   0.000036   0.000021   let prev_ind = s:prev_indent(lnum)
                            
    1   0.000044   0.000022   if s:syn_xmlish(current_syn)
                            
                                " {
                                "   <div></div>
                                " ##} <--
                                if s:syn_jsx_element(current_syn) && line =~ '}$'
                                  let pair_line = searchpair('{', '', '}', 'b')
                                  return indent(pair_line)
                                elseif line =~ '^-->$'
                                  if prev_line =~ '^<!--'
                                    return prev_ind
                                  else
                                    return prev_ind - s:sw()
                                  endif
                                elseif prev_line =~ '-->$'
                                  return prev_ind
                                " close tag </tag> or /> including </>
                                elseif prev_line =~ s:end_tag . '$'
                                  if line =~ '^<\s*' . s:end_tag
                                    return prev_ind - s:sw()
                                  elseif s:syn_jsx_attrib(prev_syn_sol)
                                    return prev_ind - s:sw()
                                  else
                                    return prev_ind
                                  endif
                                elseif line =~ '^\(>\|/\s*>\)'
                                  if prev_line =~ '^<'
                                    return prev_ind
                                  else
                                    return prev_ind - s:sw()
                                  endif
                                elseif prev_line =~ '^\(<\|>\)' && (s:syn_xmlish(prev_syn_eol) || s:syn_js_comment(prev_syn_eol))
                                  if line =~ '^<\s*' . s:end_tag
                                    return prev_ind
                                  else
                                    return prev_ind + s:sw()
                                  endif
                                elseif line =~ '^<\s*' . s:end_tag
                                  if !s:syn_xmlish(prev_syn_sol) 
                                    if s:syn_jsx_escapejs(prev_syn_eol) || s:syn_jsx_escapejs(prev_syn_sol)
                                      return prev_ind - s:sw()
                                    else
                                      return prev_ind
                                    endif
                                  elseif prev_line =~ '^\<return'
                                    return prev_ind
                                  else
                                    return prev_ind - s:sw()
                                  endif
                                elseif !s:syn_xmlish(prev_syn_eol)
                                  if prev_line =~ '\(&&\|||\|=>\|[([{]\|`\)$'
                                    " <div>
                                    "   {
                                    "   }
                                    " </div>
                                    if line =~ '^[)\]}]'
                                      return prev_ind
                                    else
                                      return prev_ind + s:sw()
                                    endif
                                  else
                                    return prev_ind
                                  endif
                                elseif !s:syn_xmlish(prev_syn_sol)
                                  if prev_line =~ '^\<\(return\|default\|await\|yield\)'
                                    if line !~ '^/\s*>' || line !~ '^<\s*' . s:end_tag
                                      return prev_ind + s:sw()
                                    else
                                      return prev_ind
                                    endif
                                  else
                                    return prev_ind
                                  endif
                                else
                                  return prev_ind
                                endif
                              elseif s:syn_jsx_escapejs(current_syn)
                                if line =~ '^}'
                                  let char = getline('.')[col('.') - 1]
                                  " When pressing enter after the }, keep the indent
                                  if char != '}' && search('}', 'b', lnum)
                                    return indent(lnum)
                                  else
                                    let pair_line = searchpair('{', '', '}', 'bW')
                                    return indent(pair_line)
                                  endif
                                elseif line =~ '^{' || line =~ '^\${'
                                  if s:syn_jsx_escapejs(prev_syn_eol) || s:syn_jsx_attrib(prev_syn_sol)
                                    return prev_ind
                                  elseif s:syn_xmlish(prev_syn_eol) && (prev_line =~ s:end_tag || prev_line =~ '-->$')
                                    return prev_ind
                                  else
                                    return prev_ind + s:sw()
                                  endif
                                endif
                              elseif s:syn_jsx_escapejs(current_syn_eol)
                                let pair_line = searchpair('{', '', '}', 'bW')
                                return indent(pair_line)
                              elseif line =~ '^/[/*]' " js comment in jsx tag
                                if get(prev_syn_sol, -1) =~ 'Punct'
                                  return prev_ind + s:sw()
                                elseif synIDattr(synID(lnum - 1, 1, 1), 'name') =~ 'jsxTag'
                                  return prev_ind
                                else
                                  return a:js_indent()
                                endif
                              else
    1   0.001298   0.000014     let ind = a:js_indent()
                            
                                " Issue #68
                                " return (<div>
                                " |<div>)
    1              0.000006     if prev_line =~ '^\<return' && line =~ '^<\s*' . s:end_tag
                                  return prev_ind
                                endif 
                            
                                " If current syntax is not a jsx syntax group
    1   0.000026   0.000011     if s:syn_xmlish(prev_syn_eol) && line !~ '^[)\]}]'
                                  let sol = matchstr(line, s:opfirst)
                                  if sol is ''
                                    " Fix javascript continue indent
                                    return ind - s:sw()
                                  else
                                    return ind
                                  endif
                                endif
    1              0.000001     return ind
                              endif
                            

FUNCTION  <SNR>95_new_airline_ale_get_line_number()
Called 1244 times
Total time:   0.113104
 Self time:   0.051433

count  total (s)   self (s)
                              " The FirstProblem call in ALE is a far more efficient way
                              " of obtaining line number data. If the installed ALE supports
                              " it, we should use this method of getting line data.
 1244              0.003702   if a:cnt == 0
  622              0.001126     return ''
                              endif
  622              0.003392   let l:buffer = bufnr('')
                            
                              " Try to get the first error from ALE.
  622   0.070208   0.008536   let l:result = ale#statusline#FirstProblem(l:buffer, a:type)
  622              0.002522   if empty(l:result)
                                " If there are no errors then try and check for style errors.
                                let l:result =  ale#statusline#FirstProblem(l:buffer, 'style_' . a:type)
                              endif
                            
  622              0.001963   if empty(l:result)
                                  return ''
                              endif
                            
  622              0.004789   let l:open_lnum_symbol  = get(g:, 'airline#extensions#ale#open_lnum_symbol', '(L')
  622              0.004639   let l:close_lnum_symbol = get(g:, 'airline#extensions#ale#close_lnum_symbol', ')')
                            
  622              0.004558   return open_lnum_symbol . l:result.lnum . close_lnum_symbol

FUNCTION  airline#highlighter#highlight_modified_inactive()
Called 14 times
Total time:   0.010406
 Self time:   0.000974

count  total (s)   self (s)
   14              0.000106   if getbufvar(a:bufnr, '&modified')
    9              0.000137     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
    9              0.000011   else
    5              0.000103     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
    5              0.000008   endif
                            
   14              0.000047   if !empty(colors)
   14   0.009736   0.000304     call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
   14              0.000017   endif

FUNCTION  <SNR>166_syn_xmlish()
Called 2 times
Total time:   0.000036
 Self time:   0.000023

count  total (s)   self (s)
    2   0.000035   0.000022   return s:syn_attr_jsx(get(a:syns, -1))

FUNCTION  ale#job#PrepareCommand()
Called 7 times
Total time:   0.001078
 Self time:   0.000883

count  total (s)   self (s)
    7   0.000293   0.000099     let l:wrapper = ale#Var(a:buffer, 'command_wrapper')
                            
                                " The command will be executed in a subshell. This fixes a number of
                                " issues, including reading the PATH variables correctly, %PATHEXT%
                                " expansion on Windows, etc.
                                "
                                " NeoVim handles this issue automatically if the command is a String,
                                " but we'll do this explicitly, so we use the same exact command for both
                                " versions.
    7              0.000077     let l:command = !empty(l:wrapper) ? s:PrepareWrappedCommand(l:wrapper, a:command) : a:command
                            
                                " If a custom shell is specified, use that.
    7              0.000033     if exists('g:ale_shell')
                                    let l:shell_arguments = get(g:, 'ale_shell_arguments', &shellcmdflag)
                            
                                    return split(g:ale_shell) + split(l:shell_arguments) + [l:command]
                                endif
                            
    7              0.000041     if has('win32')
                                    return 'cmd /s/c "' . l:command . '"'
                                endif
                            
    7              0.000151     if &shell =~? 'fish$\|pwsh$'
                                    return ['/bin/sh', '-c', l:command]
                                endif
                            
    7              0.000276     return split(&shell) + split(&shellcmdflag) + [l:command]

FUNCTION  <SNR>141_LanguageGetter()
Called 2 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    2              0.000011     return l:self.language

FUNCTION  ale#util#GetFunction()
Called 38 times
Total time:   0.000729
 Self time:   0.000729

count  total (s)   self (s)
   38              0.000293     if type(a:string_or_ref) is v:t_string
    3              0.000019         return function(a:string_or_ref)
                                endif
                            
   35              0.000100     return a:string_or_ref

FUNCTION  280()
Called 9 times
Total time:   0.000079
 Self time:   0.000079

count  total (s)   self (s)
    9              0.000070   call add(self._sections, ['|', a:0 ? a:1 : '%='])

FUNCTION  281()
Called 1 time
Total time:   0.000074
 Self time:   0.000063

count  total (s)   self (s)
    1              0.000014   let spc = empty(a:contents) ? '' : g:airline_symbols.space
    1   0.000058   0.000047   call self.add_section(a:group, spc.a:contents.spc)

FUNCTION  282()
Called 47 times
Total time:   0.000418
 Self time:   0.000418

count  total (s)   self (s)
   47              0.000377   call add(self._sections, [a:group, a:contents])

FUNCTION  284()
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000005   call insert(self._sections, [a:group, a:contents], a:position)

FUNCTION  285()
Called 2 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    2              0.000011   call insert(self._sections, ['', a:text], a:position)

FUNCTION  286()
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000008   return len(self._sections)

FUNCTION  287()
Called 10 times
Total time:   0.102351
 Self time:   0.012307

count  total (s)   self (s)
   10              0.000031   let side = 1
   10              0.000023   let line = ''
   10              0.000021   let i = 0
   10              0.000047   let length = len(self._sections)
   10              0.000025   let split = 0
   10              0.000025   let is_empty = 0
   10              0.000025   let prev_group = ''
                            
   73              0.000217   while i < length
   63              0.000294     let section = self._sections[i]
   63              0.000249     let group = section[0]
   63              0.000273     let contents = section[1]
   63              0.000204     let pgroup = prev_group
   63   0.002524   0.000924     let prev_group = airline#builder#get_prev_group(self._sections, i)
   63              0.000333     if group ==# 'airline_c' && &buftype ==# 'terminal' && self._context.active
                                  let group = 'airline_term'
                                elseif group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
    4              0.000022       let group = 'airline_c'. self._context.bufnr
    4              0.000021     elseif prev_group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
    4              0.000020       let prev_group = 'airline_c'. self._context.bufnr
    4              0.000005     endif
   63              0.000112     if is_empty
                                  let prev_group = pgroup
                                endif
   63   0.002309   0.000914     let is_empty = s:section_is_empty(self, contents)
                            
   63              0.000122     if is_empty
                                  " need to fix highlighting groups, since we
                                  " have skipped a section, we actually need
                                  " the previous previous group and so the
                                  " seperator goes from the previous previous group
                                  " to the current group
                                  let pgroup = group
                                endif
                            
   63              0.000177     if group == ''
    2              0.000010       let line .= contents
    2              0.000004     elseif group == '|'
   10              0.000024       let side = 0
   10              0.000045       let line .= contents
   10              0.000021       let split = 1
   10              0.000013     else
   51              0.000134       if prev_group == ''
   10              0.000061         let line .= '%#'.group.'#'
   10              0.000019       elseif split
    6              0.000010         if !is_empty
    6   0.008537   0.000106           let line .= s:get_transitioned_seperator(self, prev_group, group, side)
    6              0.000010         endif
    6              0.000016         let split = 0
    6              0.000008       else
   35              0.000070         if !is_empty
   35   0.073289   0.000615           let line .= s:get_seperator(self, prev_group, group, side)
   35              0.000059         endif
   35              0.000034       endif
   51   0.007023   0.001080       let line .= is_empty ? '' : s:get_accented_line(self, group, contents)
   51              0.000080     endif
                            
   63              0.000221     let i = i + 1
   63              0.000138   endwhile
                            
   10              0.000031   if !self._context.active
                                "let line = substitute(line, '%#airline_c#', '%#airline_c'.self._context.bufnr.'#', '')
    4              0.000266     let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
    4              0.000007   endif
   10              0.000025   return line

FUNCTION  288()
Called 1 time
Total time:   0.000089
 Self time:   0.000080

count  total (s)   self (s)
    1              0.000006   let self._first_title = a:first " lowest index
    1              0.000004   let self._last_title = a:last " highest index
    1              0.000004   let self._left_title = a:current " next index to add on the left
    1              0.000021   let self._right_title = a:current + 1 " next index to add on the right
    1   0.000045   0.000035   let self._left_position = self.get_position() " left end of titles
    1              0.000006   let self._right_position = self._left_position " right end of the titles

FUNCTION  289()
Called 1 time
Total time:   0.000701
 Self time:   0.000099

count  total (s)   self (s)
    1   0.000225   0.000016   let title = self.get_title(a:index)
    1   0.000373   0.000009   let title_size = s:tabline_evaluated_length(title) + a:sep_size
    1              0.000002   if a:force || self._remaining_space >= title_size
    1              0.000002     let pos = a:pos
    1              0.000003     if has_key(self, "get_pretitle")
    1   0.000034   0.000018       call self.insert_raw(self.get_pretitle(a:index), pos)
    1              0.000003       let self._right_position += 1
    1              0.000002       let pos += 1
    1              0.000001     endif
                            
    1   0.000015   0.000009     call self.insert_section(a:group, title, pos)
    1              0.000002     let self._right_position += 1
    1              0.000002     let pos += 1
                            
    1              0.000003     if has_key(self, "get_posttitle")
    1   0.000021   0.000013       call self.insert_raw(self.get_posttitle(a:index), pos)
    1              0.000002       let self._right_position += 1
    1              0.000002       let pos += 1
    1              0.000001     endif
                            
    1              0.000002     let self._remaining_space -= title_size
    1              0.000001     return 1
                              endif
                              return 0

FUNCTION  <SNR>116_get_separator_change_with_end()
Called 2 times
Total time:   0.000524
 Self time:   0.000099

count  total (s)   self (s)
    2              0.000010   let sep_change = 0
    2              0.000011   if !empty(a:new_end_group) " Separator between title and the end
    1   0.000440   0.000015     let sep_change += airline#builder#should_change_group(a:new_group, a:new_end_group) ? a:sep_size : a:alt_sep_size
    1              0.000001   endif
    2              0.000007   if !empty(a:old_group) " Separator between the title and the one adjacent
                                let sep_change += airline#builder#should_change_group(a:new_group, a:old_group) ? a:sep_size : a:alt_sep_size
                                if !empty(a:old_end_group) " Remove mis-predicted separator
                                  let sep_change -= airline#builder#should_change_group(a:old_group, a:old_end_group) ? a:sep_size : a:alt_sep_size
                                endif
                              endif
    2              0.000005   return sep_change

FUNCTION  308()
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000005       let bufnum = get(self.buffers, a:i, -1)
    1              0.000004       return '%'.bufnum.'@airline#extensions#tabline#buffers#clickbuf@'

FUNCTION  <SNR>148_RunLinter()
Called 10 times
Total time:   0.031851
 Self time:   0.000524

count  total (s)   self (s)
   10              0.000062     if !empty(a:linter.lsp)
    2   0.009255   0.000051         return ale#lsp_linter#CheckWithLSP(a:buffer, a:linter)
                                else
    8   0.006133   0.000131         let l:executable = ale#linter#GetExecutable(a:buffer, a:linter)
                            
    8   0.016322   0.000201         return s:RunIfExecutable(a:buffer, a:linter, l:executable)
                                endif
                            
                                return 0

FUNCTION  airline#extensions#ctrlp#apply()
Called 4 times
Total time:   0.000067
 Self time:   0.000067

count  total (s)   self (s)
                              " disable statusline overwrite if ctrlp already did it
    4              0.000059   return match(&statusline, 'CtrlPwhite') >= 0 ? -1 : 0

FUNCTION  <SNR>166_prev_indent()
Called 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000009   let lnum = prevnonblank(a:lnum - 1)
    1              0.000004   return indent(lnum)

FUNCTION  <SNR>172_AddSubCallbacks()
Called 1 time
Total time:   0.000063
 Self time:   0.000063

count  total (s)   self (s)
    1              0.000008     if type(a:callbacks) is v:t_string
                                    call add(a:full_list, a:callbacks)
                                elseif type(a:callbacks) is v:t_list
    1              0.000009         call extend(a:full_list, a:callbacks)
    1              0.000002     else
                                    return 0
                                endif
                            
    1              0.000002     return 1

FUNCTION  airline#extensions#hunks#get_hunks()
Called 639 times
Total time:   0.306428
 Self time:   0.141970

count  total (s)   self (s)
  639              0.004367   if !get(w:, 'airline_active', 0)
                                return ''
                              endif
                              " Cache values, so that it isn't called too often
  639   0.021984   0.017201   if exists("b:airline_hunks") && get(b:,  'airline_changenr', 0) == b:changedtick && airline#util#winwidth() == get(s:, 'airline_winwidth', 0) && get(b:, 'source_func', '') isnot# 's:get_hunks_signify' && get(b:, 'source_func', '') isnot# 's:get_hunks_gitgutter' && get(b:, 'source_func', '') isnot# 's:get_hunks_empty' && get(b:, 'source_func', '') isnot# 's:get_hunks_changes'
                                return b:airline_hunks
                              endif
  639   0.111587   0.007822   let hunks = airline#extensions#hunks#get_raw_hunks()
  639              0.002244   let string = ''
  639   0.014674   0.009190   let winwidth = get(airline#parts#get('hunks'), 'minwidth', 100)
  639              0.003071   if !empty(hunks)
 2540              0.008245     for i in [0, 1, 2]
 1905   0.062835   0.024805       if (s:non_zero_only == 0 && airline#util#winwidth() > winwidth) || hunks[i] > 0
 1905              0.024800         let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
 1905              0.003270       endif
 1905              0.003031     endfor
  635              0.000743   endif
  639              0.002756   let b:airline_hunks = string
  639              0.002698   let b:airline_changenr = b:changedtick
  639   0.019394   0.006998   let s:airline_winwidth = airline#util#winwidth()
  639              0.001571   return string

FUNCTION  <SNR>162_valid_dir()
Called 8 times
Total time:   0.000309
 Self time:   0.000309

count  total (s)   self (s)
    8              0.000159   if empty(a:dir) || !isdirectory(a:dir)
                                return getcwd()
                              endif
    8              0.000086   return a:dir

FUNCTION  290()
Called 1 time
Total time:   0.016013
 Self time:   0.000444

count  total (s)   self (s)
    1              0.000009   if has_key(self, '_left_position') && self._first_title <= self._last_title
    1   0.005534   0.000052     let self._remaining_space = &columns - s:tabline_evaluated_length(self._build())
                            
    1              0.000009     let center_active = get(g:, 'airline#extensions#tabline#center_active', 0)
                            
    1   0.000147   0.000018     let sep_size = s:tabline_evaluated_length(self._context.left_sep)
    1   0.000109   0.000014     let alt_sep_size = s:tabline_evaluated_length(self._context.left_alt_sep)
                            
    1   0.000031   0.000011     let outer_left_group = airline#builder#get_prev_group(self._sections, self._left_position)
    1   0.000078   0.000029     let outer_right_group = airline#builder#get_next_group(self._sections, self._right_position)
                            
    1              0.000011     let overflow_marker = get(g:, 'airline#extensions#tabline#overflow_marker', g:airline_symbols.ellipsis)
    1   0.000096   0.000013     let overflow_marker_size = s:tabline_evaluated_length(overflow_marker)
                                " Allow space for the markers before we begin filling in titles.
    1              0.000002     if self._left_title > self._first_title
                                  let self._remaining_space -= overflow_marker_size + s:get_separator_change(self.overflow_group, "", outer_left_group, sep_size, alt_sep_size)
                                endif
    1              0.000002     if self._left_title < self._last_title
                                  let self._remaining_space -= overflow_marker_size + s:get_separator_change(self.overflow_group, "", outer_right_group, sep_size, alt_sep_size)
                                endif
                            
                                " Add the current title
    1   0.000116   0.000013     let group = self.get_group(self._left_title)
    1              0.000004     if self._left_title == self._first_title
    1   0.000114   0.000031       let sep_change = s:get_separator_change(group, "", outer_left_group, sep_size, alt_sep_size)
    1              0.000002     else
                                  let sep_change = s:get_separator_change(group, "", self.overflow_group, sep_size, alt_sep_size)
                                endif
    1              0.000004     if self._left_title == self._last_title
    1   0.000514   0.000017       let sep_change += s:get_separator_change(group, "", outer_right_group, sep_size, alt_sep_size)
    1              0.000001     else
                                  let sep_change += s:get_separator_change(group, "", self.overflow_group, sep_size, alt_sep_size)
                                endif
    1              0.000004     let left_group = group
    1              0.000004     let right_group = group
    1   0.000722   0.000021     let self._left_title -= self.try_insert_title(self._left_title, group, self._left_position, sep_change, 1)
                            
    1              0.000004     if get(g:, 'airline#extensions#tabline#current_first', 0)
                                  " always have current title first
                                  let self._left_position += 1
                                endif
                            
    1              0.000002     if !center_active && self._right_title <= self._last_title
                                  " Add the title to the right
                                  let group = self.get_group(self._right_title)
                                  if self._right_title == self._last_title
                                    let sep_change = s:get_separator_change_with_end(group, right_group, outer_right_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
                                  else
                                    let sep_change = s:get_separator_change(group, right_group, self.overflow_group, sep_size, alt_sep_size)
                                  endif
                                  let right_group = group
                                  let self._right_title += self.try_insert_title(self._right_title, group, self._right_position, sep_change, 1)
                                endif
                            
    1              0.000002     while self._remaining_space > 0
    1              0.000002       let done = 0
    1              0.000002       if self._left_title >= self._first_title
                                    " Insert next title to the left
                                    let group = self.get_group(self._left_title)
                                    if self._left_title == self._first_title
                                      let sep_change = s:get_separator_change_with_end(group, left_group, outer_left_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
                                    else
                                      let sep_change = s:get_separator_change(group, left_group, self.overflow_group, sep_size, alt_sep_size)
                                    endif
                                    let left_group = group
                                    let done = self.try_insert_title(self._left_title, group, self._left_position, sep_change, 0)
                                    let self._left_title -= done
                                  endif
                                  " If center_active is set, this |if| operates as an independent |if|,
                                  " otherwise as an |elif|.
    1              0.000003       if self._right_title <= self._last_title && (center_active || !done)
                                    " Insert next title to the right
                                    let group = self.get_group(self._right_title)
                                    if self._right_title == self._last_title
                                      let sep_change = s:get_separator_change_with_end(group, right_group, outer_right_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
                                    else
                                      let sep_change = s:get_separator_change(group, right_group, self.overflow_group, sep_size, alt_sep_size)
                                    endif
                                    let right_group = group
                                    let done = self.try_insert_title(self._right_title, group, self._right_position, sep_change, 0)
                                    let self._right_title += done
                                  endif
    1              0.000001       if !done
    1              0.000001         break
                                  endif
                                endwhile
                            
    1              0.000002     if self._left_title >= self._first_title
                                  if get(g:, 'airline#extensions#tabline#current_first', 0)
                                    let self._left_position -= 1
                                  endif
                                  call self.insert_section(self.overflow_group, overflow_marker, self._left_position)
                                  let self._right_position += 1
                                endif
                            
    1              0.000002     if self._right_title <= self._last_title
                                  call self.insert_section(self.overflow_group, overflow_marker, self._right_position)
                                endif
    1              0.000001   endif
                            
    1   0.008339   0.000011   return self._build()

FUNCTION  ale#command#FormatCommand()
Called 7 times
Total time:   0.008084
 Self time:   0.001583

count  total (s)   self (s)
    7              0.000028     let l:temporary_file = ''
    7              0.000021     let l:command = a:command
                            
                                " First replace all uses of %%, used for literal percent characters,
                                " with an ugly string.
    7              0.000098     let l:command = substitute(l:command, '%%', '<<PERCENTS>>', 'g')
                            
                                " Replace %e with the escaped executable, if available.
    7              0.000063     if !empty(a:executable) && l:command =~# '%e'
    2   0.000111   0.000049         let l:command = substitute(l:command, '%e', '\=ale#Escape(a:executable)', 'g')
    2              0.000003     endif
                            
                                " Replace all %s occurrences in the string with the name of the current
                                " file.
    7              0.000043     if l:command =~# '%s'
    3              0.000295         let l:filename = fnamemodify(bufname(a:buffer), ':p')
    3   0.000153   0.000076         let l:command = substitute(l:command, '%s', '\=ale#Escape(l:filename)', 'g')
    3              0.000004     endif
                            
    7              0.000069     if a:input isnot v:false && l:command =~# '%t'
                                    " Create a temporary filename, <temp_dir>/<original_basename>
                                    " The file itself will not be created by this function.
    1   0.000067   0.000009         let l:temporary_file = s:TemporaryFilename(a:buffer)
    1   0.000036   0.000017         let l:command = substitute(l:command, '%t', '\=ale#Escape(l:temporary_file)', 'g')
    1              0.000001     endif
                            
                                " Finish formatting so %% becomes %.
    7              0.000092     let l:command = substitute(l:command, '<<PERCENTS>>', '%', 'g')
                            
    7              0.000036     if a:pipe_file_if_needed && empty(l:temporary_file)
                                    " If we are to send the Vim buffer to a command, we'll do it
                                    " in the shell. We'll write out the file to a temporary file,
                                    " and then read it back in, in the shell.
    3   0.000321   0.000061         let l:temporary_file = s:TemporaryFilename(a:buffer)
    3   0.000110   0.000039         let l:command = l:command . ' < ' . ale#Escape(l:temporary_file)
    3              0.000004     endif
                            
    7   0.006177   0.000222     let l:file_created = ale#command#CreateTempFile(   a:buffer,   l:temporary_file,   a:input,)
                            
    7              0.000047     return [l:temporary_file, l:command, l:file_created]

FUNCTION  gitgutter#utility#getbufvar()
Called 667 times
Total time:   0.021077
 Self time:   0.021077

count  total (s)   self (s)
  667              0.005576   let bvars = getbufvar(a:buffer, '')
  667              0.002809   if !empty(bvars)
  667              0.004825     let dict = get(bvars, 'gitgutter', {})
  667              0.003579     if has_key(dict, a:varname)
  665              0.002676       return dict[a:varname]
                                endif
    2              0.000002   endif
    2              0.000004   if a:0
    2              0.000005     return a:1
                              endif

FUNCTION  <SNR>93_update_git_branch()
Called 639 times
Total time:   1.262513
 Self time:   0.035815

count  total (s)   self (s)
  639   0.012586   0.006474   if !airline#util#has_fugitive()
                                let s:vcs_config['git'].branch = ''
                                return
                              endif
                            
  639   1.235202   0.014616   let s:vcs_config['git'].branch = exists("*FugitiveHead") ? FugitiveHead(s:sha1size) : fugitive#head(s:sha1size)
  639              0.005491   if s:vcs_config['git'].branch is# 'master' && airline#util#winwidth() < 81
                                " Shorten default a bit
                                let s:vcs_config['git'].branch='mas'
                              endif

FUNCTION  ale#command#RemoveManagedFiles()
Called 3 times
Total time:   0.001733
 Self time:   0.001685

count  total (s)   self (s)
    3              0.000034     let l:info = get(s:buffer_data, a:buffer, {})
                            
    3              0.000021     if !empty(l:info) && empty(l:info.jobs)
                                    " We can't delete anything in a sandbox, so wait until we escape from
                                    " it to delete temporary files and directories.
    1   0.000069   0.000021         if ale#util#InSandbox()
                                        return
                                    endif
                            
                                    " Delete files with a call akin to a plan `rm` command.
    1              0.000006         for l:filename in l:info.file_list
                                        call delete(l:filename)
                                    endfor
                            
                                    " Delete directories like `rm -rf`.
                                    " Directories are handled differently from files, so paths that are
                                    " intended to be single files can be set up for automatic deletion
                                    " without accidentally deleting entire directories.
    4              0.000018         for l:directory in l:info.directory_list
    3              0.001410             call delete(l:directory, 'rf')
    3              0.000015         endfor
                            
    1              0.000040         call remove(s:buffer_data, a:buffer)
    1              0.000004     endif

FUNCTION  FugitiveParse()
Called 4 times
Total time:   0.000183
 Self time:   0.000122

count  total (s)   self (s)
    4   0.000127   0.000066   let path = s:Slash(a:0 ? a:1 : @%)
    4              0.000036   if path !~# '^fugitive:'
    4              0.000011     return ['', '']
                              endif
                              let vals = matchlist(path, '\c^fugitive:\%(//\)\=\(.\{-\}\)\%(//\|::\)\(\x\{40\}\|[0-3]\)\(/.*\)\=$')
                              if len(vals)
                                return [(vals[2] =~# '^.$' ? ':' : '') . vals[2] . substitute(vals[3], '^/', ':', ''), vals[1]]
                              endif
                              let v:errmsg = 'fugitive: invalid Fugitive URL ' . path
                              throw v:errmsg

FUNCTION  <SNR>42_abs_path()
Called 10 times
Total time:   0.001666
 Self time:   0.001666

count  total (s)   self (s)
   10              0.001571   let p = resolve(expand('#'.a:bufnr.':p'))
   10              0.000081   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  <SNR>129_syn_at()
Called 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000013   return synIDattr(synID(a:l,a:c,0),'name')

FUNCTION  <SNR>155_StartWithCommand()
Called 2 times
Total time:   0.006062
 Self time:   0.000114

count  total (s)   self (s)
    2   0.000039   0.000022     if ale#command#IsDeferred(a:command)
                                    let a:command.result_callback = {   command -> s:StartWithCommand(a:options, a:executable, command)}
                            
                                    return 1
                                endif
                            
    2              0.000007     if empty(a:command)
                                    return 0
                                endif
                            
    2   0.005980   0.000050     return s:StartLSP(a:options, '', a:executable, a:command)

FUNCTION  ale#fix#registry#GetFunc()
Called 2 times
Total time:   0.000060
 Self time:   0.000060

count  total (s)   self (s)
                                " Use the exact name, or an alias.
    2              0.000029     let l:resolved_name = !has_key(s:entries, a:name)   ? get(s:aliases, a:name, a:name)   : a:name
                            
    2              0.000023     return get(s:entries, l:resolved_name, {'function': ''}).function

FUNCTION  ale#sign#GetSignCommands()
Called 7 times
Total time:   0.001896
 Self time:   0.001896

count  total (s)   self (s)
    7              0.000034     let l:command_list = []
    7              0.000035     let l:is_dummy_sign_set = a:was_sign_set
                            
                                " Set the dummy sign if we need to.
                                " The dummy sign is needed to keep the sign column open while we add
                                " and remove signs.
    7              0.000047     if !l:is_dummy_sign_set && (!empty(a:sign_map) || g:ale_sign_column_always)
                                    call add(l:command_list, 'sign place '   .  g:ale_sign_offset   . ' line=1 name=ALEDummySign buffer='   . a:buffer)
                                    let l:is_dummy_sign_set = 1
                                endif
                            
                                " Place new items first.
   20              0.000132     for [l:line_str, l:info] in items(a:sign_map)
   13              0.000038         if l:info.new_id
                                        " Save the sign IDs we are setting back on our loclist objects.
                                        " These IDs will be used to preserve items which are set many times.
   33              0.000092             for l:item in l:info.items
   20              0.000091                 let l:item.sign_id = l:info.new_id
   20              0.000034             endfor
                            
   13              0.000076             if index(l:info.current_id_list, l:info.new_id) < 0
    1              0.000019                 call add(l:command_list, 'sign place '   . (l:info.new_id)   . ' line=' . l:line_str   . ' name=' . (l:info.new_name)   . ' buffer=' . a:buffer)
    1              0.000002             endif
   13              0.000015         endif
   13              0.000015     endfor
                            
                                " Remove signs without new IDs.
   20              0.000086     for l:info in values(a:sign_map)
   25              0.000076         for l:current_id in l:info.current_id_list
   12              0.000043             if l:current_id isnot l:info.new_id
                                            call add(l:command_list, 'sign unplace '   . l:current_id   . ' buffer=' . a:buffer)
                                        endif
   12              0.000016         endfor
   13              0.000020     endfor
                            
                                " Remove the dummy sign to close the sign column if we need to.
    7              0.000032     if l:is_dummy_sign_set && !g:ale_sign_column_always
                                    call add(l:command_list, 'sign unplace '   . g:ale_sign_offset   . ' buffer=' . a:buffer)
                                endif
                            
    7              0.000018     return l:command_list

FUNCTION  airline#highlighter#reset_hlcache()
Called 2 times
Total time:   0.001493
 Self time:   0.001493

count  total (s)   self (s)
    2              0.001488   let s:hl_groups = {}

FUNCTION  airline#util#prepend()
Called 2556 times
Total time:   0.039700
 Self time:   0.039700

count  total (s)   self (s)
 2556              0.014428   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
                              endif
 2556              0.014756   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  <SNR>110_setup_maps()
Called 2 times
Total time:   0.000110
 Self time:   0.000051

count  total (s)   self (s)
    2              0.000008   if !g:gitgutter_map_keys
                                return
                              endif
                            
    2   0.000089   0.000029   if gitgutter#utility#getbufvar(a:bufnr, 'mapped', 0)
    2              0.000003     return
                              endif
                            
                              if !hasmapto('<Plug>GitGutterPrevHunk') && maparg('[c', 'n') ==# ''
                                nmap <buffer> [c <Plug>GitGutterPrevHunk
                              endif
                              if !hasmapto('<Plug>GitGutterNextHunk') && maparg(']c', 'n') ==# ''
                                nmap <buffer> ]c <Plug>GitGutterNextHunk
                              endif
                            
                              if !hasmapto('<Plug>GitGutterStageHunk') && maparg('<Leader>hs', 'n') ==# ''
                                nmap <buffer> <Leader>hs <Plug>GitGutterStageHunk
                              endif
                              if !hasmapto('<Plug>GitGutterUndoHunk') && maparg('<Leader>hu', 'n') ==# ''
                                nmap <buffer> <Leader>hu <Plug>GitGutterUndoHunk
                              endif
                              if !hasmapto('<Plug>GitGutterPreviewHunk') && maparg('<Leader>hp', 'n') ==# ''
                                nmap <buffer> <Leader>hp <Plug>GitGutterPreviewHunk
                              endif
                            
                              if !hasmapto('<Plug>GitGutterTextObjectInnerPending') && maparg('ic', 'o') ==# ''
                                omap <buffer> ic <Plug>GitGutterTextObjectInnerPending
                              endif
                              if !hasmapto('<Plug>GitGutterTextObjectOuterPending') && maparg('ac', 'o') ==# ''
                                omap <buffer> ac <Plug>GitGutterTextObjectOuterPending
                              endif
                              if !hasmapto('<Plug>GitGutterTextObjectInnerVisual') && maparg('ic', 'x') ==# ''
                                xmap <buffer> ic <Plug>GitGutterTextObjectInnerVisual
                              endif
                              if !hasmapto('<Plug>GitGutterTextObjectOuterVisual') && maparg('ac', 'x') ==# ''
                                xmap <buffer> ac <Plug>GitGutterTextObjectOuterVisual
                              endif
                            
                              call gitgutter#utility#setbufvar(a:bufnr, 'mapped', 1)

FUNCTION  ale#command#StopJobs()
Called 4 times
Total time:   0.000240
 Self time:   0.000240

count  total (s)   self (s)
    4              0.000034     let l:info = get(s:buffer_data, a:buffer, {})
                            
    4              0.000013     if !empty(l:info)
    1              0.000003         let l:new_map = {}
                            
    2              0.000015         for [l:job_id, l:job_type] in items(l:info.jobs)
    1              0.000007             let l:job_id = str2nr(l:job_id)
                            
    1              0.000007             if a:job_type is# 'all' || a:job_type is# l:job_type
                                            call ale#job#Stop(l:job_id)
                                        else
    1              0.000007                 let l:new_map[l:job_id] = l:job_type
    1              0.000002             endif
    1              0.000002         endfor
                            
    1              0.000012         let l:info.jobs = l:new_map
    1              0.000002     endif

FUNCTION  143()
Called 8 times
Total time:   0.003110
 Self time:   0.000151

count  total (s)   self (s)
    8   0.003072   0.000113     if !self.isCascadable()
    8              0.000026         return [self]
                                endif
                            
                                let vc = self.getVisibleChildren()
                                let visChild = vc[0]
                            
                                return [self] + visChild.getCascade()

FUNCTION  <SNR>165_remove_signs()
Called 2 times
Total time:   0.000983
 Self time:   0.000983

count  total (s)   self (s)
    2              0.000016   if a:all_signs && s:supports_star && empty(gitgutter#utility#getbufvar(a:bufnr, 'other_signs'))
                                let dummy_sign_present = gitgutter#utility#getbufvar(a:bufnr, 'dummy_sign')
                                execute "sign unplace * buffer=" . a:bufnr
                                if dummy_sign_present
                                  execute "sign place" s:dummy_sign_id "line=" . 9999 "name=GitGutterDummy buffer=" . a:bufnr
                                endif
                              else
    3              0.000012     for id in a:sign_ids
    1              0.000896       execute "sign unplace" id
    1              0.000004     endfor
    2              0.000003   endif

FUNCTION  ale#sign#SetSigns()
Called 7 times
Total time:   0.031248
 Self time:   0.012530

count  total (s)   self (s)
    7              0.000051     if !bufexists(str2nr(a:buffer))
                                    " Stop immediately when attempting to set signs for a buffer which
                                    " does not exist.
                                    return
                                endif
                            
                                " Find the current markers
    7   0.009570   0.000187     let [l:is_dummy_sign_set, l:current_sign_list] =   ale#sign#FindCurrentSigns(a:buffer)
                            
                                " Update the line numbers for items from before which may have moved.
    7   0.001374   0.000181     call s:UpdateLineNumbers(a:buffer, l:current_sign_list, a:loclist)
                            
                                " Group items after updating the line numbers.
    7   0.001230   0.000144     let l:grouped_items = s:GroupLoclistItems(a:buffer, a:loclist)
                            
                                " Build a map of current and new signs, with the lines as the keys.
    7   0.005426   0.000266     let l:sign_map = s:BuildSignMap(   a:buffer,   l:current_sign_list,   l:grouped_items,)
                            
    7   0.002050   0.000154     let l:command_list = ale#sign#GetSignCommands(   a:buffer,   l:is_dummy_sign_set,   l:sign_map,)
                            
                                " Change the sign column color if the option is on.
    7              0.000039     if g:ale_change_sign_column_color && !empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithErrors
                                endif
                            
    8              0.000035     for l:command in l:command_list
    1              0.011132         silent! execute l:command
    1              0.000011     endfor
                            
                                " Reset the sign column color when there are no more errors.
    7              0.000041     if g:ale_change_sign_column_color && empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithoutErrors
                                endif

FUNCTION  ale#cursor#EchoCursorWarningWithDelay()
Called 4 times
Total time:   0.000554
 Self time:   0.000398

count  total (s)   self (s)
    4              0.000037     let l:buffer = bufnr('')
                            
    4              0.000016     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
                                endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
    4              0.000021     if mode(1) isnot# 'n'
                                    return
                                endif
                            
    4   0.000134   0.000065     call s:StopCursorTimer()
                            
    4              0.000039     let l:pos = getpos('.')[0:2]
                            
                                " Check the current buffer, line, and column number against the last
                                " recorded position. If the position has actually changed, *then*
                                " we should echo something. Otherwise we can end up doing processing
                                " the echo message far too frequently.
    4              0.000016     if l:pos != s:last_pos
    3   0.000133   0.000045         let l:delay = ale#Var(l:buffer, 'echo_delay')
                            
    3              0.000023         let s:last_pos = l:pos
    3              0.000044         let s:cursor_timer = timer_start(   l:delay,   function('ale#cursor#EchoCursorWarning'))
    3              0.000005     endif

FUNCTION  <SNR>176_GetVersion()
Called 1 time
Total time:   0.000120
 Self time:   0.000061

count  total (s)   self (s)
    1              0.000009     let l:version = get(s:version_cache, a:executable, [])
    1   0.000087   0.000028     let l:parsed_version = ale#semver#ParseVersion(a:version_lines)
                            
    1              0.000004     if !empty(l:parsed_version)
    1              0.000004         let l:version = l:parsed_version
    1              0.000007         let s:version_cache[a:executable] = l:version
    1              0.000001     endif
                            
    1              0.000002     return l:version

FUNCTION  nerdtree#runningWindows()
Called 138 times
Total time:   0.002144
 Self time:   0.002144

count  total (s)   self (s)
  138              0.002017     return has("win16") || has("win32") || has("win64")

FUNCTION  <SNR>118_CanAutoReloadStatus()
Called 2 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    2              0.000038   return get(g:, 'fugitive_autoreload_status', !has('win32'))

FUNCTION  <lambda>3()
Called 8 times
Total time:   0.060171
 Self time:   0.000355

count  total (s)   self (s)
    8   0.060162   0.000346 return ale#lsp#HandleMessage(a:conn_id, message)

FUNCTION  ale#sign#ReadSigns()
Called 7 times
Total time:   0.000945
 Self time:   0.000945

count  total (s)   self (s)
    7              0.000057     redir => l:output
    7              0.000648         silent execute 'sign place buffer=' . a:buffer
    7              0.000049     redir end
                            
    7              0.000162     return split(l:output, "\n")

FUNCTION  <SNR>150_CheckForBadConfig()
Called 1 time
Total time:   0.001017
 Self time:   0.001017

count  total (s)   self (s)
    1              0.000013     let l:config_error_pattern = '\v^ESLint couldn''t find a configuration file'   . '|^Cannot read config file'   . '|^.*Configuration for rule .* is invalid'   . '|^ImportDeclaration should appear'
                            
                                " Look for a message in the first few lines which indicates that
                                " a configuration file couldn't be found.
    2              0.000013     for l:line in a:lines[:10]
    1              0.000928         let l:match = matchlist(l:line, l:config_error_pattern)
                            
    1              0.000007         if len(l:match) > 0
                                        " Don't show the missing config error if we've disabled it.
                                        if ale#Var(a:buffer, 'javascript_eslint_suppress_missing_config')&& l:match[0] is# 'ESLint couldn''t find a configuration file'
                                            return 0
                                        endif
                            
                                        return 1
                                    endif
    1              0.000002     endfor
                            
    1              0.000002     return 0

FUNCTION  gitgutter#diff#process_hunks()
Called 2 times
Total time:   0.003652
 Self time:   0.000238

count  total (s)   self (s)
    2              0.000008   let modified_lines = []
   12              0.000028   for hunk in a:hunks
   10   0.003568   0.000154     call extend(modified_lines, s:process_hunk(a:bufnr, hunk))
   10              0.000018   endfor
    2              0.000005   return modified_lines

FUNCTION  <SNR>17_Tree()
Called 1278 times
Total time:   0.037740
 Self time:   0.037740

count  total (s)   self (s)
 1278              0.006288   let dir = a:path
 1278              0.018877   if dir =~# '/\.git$'
 1278              0.010451     return len(dir) ==# 5 ? '/' : dir[0:-6]
                              elseif dir ==# ''
                                return ''
                              endif
                              if !has_key(s:worktree_for_dir, dir)
                                let s:worktree_for_dir[dir] = ''
                                let config_file = dir . '/config'
                                if filereadable(config_file)
                                  let config = readfile(config_file,'',10)
                                  call filter(config,'v:val =~# "^\\s*worktree *="')
                                  if len(config) == 1
                                    let worktree = matchstr(config[0], '= *\zs.*')
                                  endif
                                elseif filereadable(dir . '/gitdir')
                                  let worktree = fnamemodify(readfile(dir . '/gitdir')[0], ':h')
                                  if worktree ==# '.'
                                    unlet! worktree
                                  endif
                                endif
                                if exists('worktree')
                                  let s:worktree_for_dir[dir] = worktree
                                  let s:dir_for_worktree[s:worktree_for_dir[dir]] = dir
                                endif
                              endif
                              if s:worktree_for_dir[dir] =~# '^\.'
                                return simplify(dir . '/' . s:worktree_for_dir[dir])
                              else
                                return s:worktree_for_dir[dir]
                              endif

FUNCTION  ale#job#Start()
Called 5 times
Total time:   0.014905
 Self time:   0.014847

count  total (s)   self (s)
    5   0.000127   0.000070     call ale#job#ValidateArguments(a:command, a:options)
                            
    5              0.000039     let l:job_info = copy(a:options)
    5              0.000016     let l:job_options = {}
                            
    5              0.000024     if has('nvim')
    5              0.000023         if has_key(a:options, 'out_cb')
    4              0.000043             let l:job_options.on_stdout = function('s:NeoVimCallback')
    4              0.000016             let l:job_info.out_cb_line = ''
    4              0.000005         endif
                            
    5              0.000022         if has_key(a:options, 'err_cb')
    1              0.000011             let l:job_options.on_stderr = function('s:NeoVimCallback')
    1              0.000004             let l:job_info.err_cb_line = ''
    1              0.000002         endif
                            
    5              0.000022         if has_key(a:options, 'exit_cb')
    5              0.000050             let l:job_options.on_exit = function('s:NeoVimCallback')
    5              0.000007         endif
                            
    5              0.013552         let l:job_info.job = jobstart(a:command, l:job_options)
    5              0.000070         let l:job_id = l:job_info.job
    5              0.000017     else
                                    let l:job_options = {   'in_mode': l:job_info.mode,   'out_mode': l:job_info.mode,   'err_mode': l:job_info.mode,}
                            
                                    if has_key(a:options, 'out_cb')
                                        let l:job_options.out_cb = function('s:VimOutputCallback')
                                    endif
                            
                                    if has_key(a:options, 'err_cb')
                                        let l:job_options.err_cb = function('s:VimErrorCallback')
                                    endif
                            
                                    if has_key(a:options, 'exit_cb')
                                        " Set a close callback to which simply calls job_status()
                                        " when the channel is closed, which can trigger the exit callback
                                        " earlier on.
                                        let l:job_options.close_cb = function('s:VimCloseCallback')
                                        let l:job_options.exit_cb = function('s:VimExitCallback')
                                    endif
                            
                                    " Use non-blocking writes for Vim versions that support the option.
                                    if has('patch-8.1.350')
                                        let l:job_options.noblock = 1
                                    endif
                            
                                    " Vim 8 will read the stdin from the file's buffer.
                                    let l:job_info.job = job_start(a:command, l:job_options)
                                    let l:job_id = ale#job#ParseVim8ProcessID(string(l:job_info.job))
                                endif
                            
    5              0.000019     if l:job_id > 0
                                    " Store the job in the map for later only if we can get the ID.
    5              0.000066         let s:job_map[l:job_id] = l:job_info
    5              0.000009     endif
                            
    5              0.000023     return l:job_id

FUNCTION  <SNR>119_OnTextChangedInsertMode()
Called 421 times
Total time:   8.944999
 Self time:   0.959411

count  total (s)   self (s)
  421   0.060250   0.005249   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
  421              0.001049   if s:completion_stopped
                                let s:completion_stopped = 0
                                let s:completion = s:default_completion
                                return
                              endif
                            
  421   0.647917   0.005525   call s:IdentifierFinishedOperations()
                            
                              " We have to make sure we correctly leave semantic mode even when the user
                              " inserts something like a "operator[]" candidate string which fails
                              " CurrentIdentifierFinished check.
  421              0.004763   if s:force_semantic && !s:Pyeval( 'base.LastEnteredCharIsIdentifierChar()' )
                                let s:force_semantic = 0
                              endif
                            
  421   0.587885   0.016248   if &completefunc == "youcompleteme#CompleteFunc" && ( g:ycm_auto_trigger || s:force_semantic ) && !s:InsideCommentOrStringAndShouldStop() && !s:OnBlankLine()
                                " Immediately call previous completion to avoid flickers.
  421   0.031097   0.007868     call s:Complete()
  421   6.698398   0.005070     call s:InvokeCompletion()
  421              0.000921   endif
                            
  421              0.889554   exec s:python_command "ycm_state.OnCursorMoved()"
                            
  421              0.004073   if g:ycm_autoclose_preview_window_after_completion
                                call s:ClosePreviewWindowIfNeeded()
                              endif

FUNCTION  airline#extensions#ale#get_warning()
Called 639 times
Total time:   0.223136
 Self time:   0.011281

count  total (s)   self (s)
  639   0.222480   0.010624   return airline#extensions#ale#get('warning')

FUNCTION  airline#extensions#tabline#add_tab_label()
Called 1 time
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    1              0.000011   if get(g:, 'airline#extensions#tabline#show_tab_count', 1) && tabpagenr('$') > 1
                                call a:dict.add_section_spaced('airline_tabmod', printf('%s %d/%d', "tab", tabpagenr(), tabpagenr('$')))
                              endif

FUNCTION  gitgutter#hunk#set_hunks()
Called 2 times
Total time:   0.000266
 Self time:   0.000063

count  total (s)   self (s)
    2   0.000131   0.000034   call gitgutter#utility#setbufvar(a:bufnr, 'hunks', a:hunks)
    2   0.000133   0.000026   call s:reset_summary(a:bufnr)

FUNCTION  airline#builder#new()
Called 9 times
Total time:   0.000515
 Self time:   0.000515

count  total (s)   self (s)
    9              0.000131   let builder = copy(s:prototype)
    9              0.000042   let builder._context = a:context
    9              0.000033   let builder._sections = []
                            
    9              0.000249   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
    9              0.000028   return builder

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
  421   8.944999   0.959411  <SNR>119_OnTextChangedInsertMode()
 2439   8.761339             provider#python3#Call()
  421   6.693328   6.141964  <SNR>119_InvokeCompletion()
 1588   1.788063             <SNR>119_Pyeval()
  639   1.750205   0.050641  airline#extensions#branch#get_head()
  639   1.657397   0.037241  airline#extensions#branch#head()
  639   1.402005   0.068019  <SNR>93_update_branch()
  639   1.262513   0.035815  <SNR>93_update_git_branch()
  639   1.220587   0.023445  FugitiveHead()
  639   1.189592   0.155708  fugitive#Head()
 1278   1.033884   0.718254  fugitive#Find()
  578   0.883091   0.037854  <SNR>119_PollCompletion()
  421   0.642392   0.019502  <SNR>119_IdentifierFinishedOperations()
   16   0.606188   0.082376  airline#highlighter#highlight()
  653   0.555718   0.158599  airline#check_mode()
 1278   0.500999   0.179960  airline#extensions#ale#get()
 1566   0.421853   0.208600  airline#highlighter#get_highlight()
  824   0.371775   0.089370  airline#highlighter#exec()
  335   0.369857   0.023727  <SNR>104_exec_separator()
    2   0.358228   0.000336  <SNR>44_airline_refresh()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
 2439              8.761339  provider#python3#Call()
  421   6.693328   6.141964  <SNR>119_InvokeCompletion()
 1588              1.788063  <SNR>119_Pyeval()
  421   8.944999   0.959411  <SNR>119_OnTextChangedInsertMode()
 1278   1.033884   0.718254  fugitive#Find()
 1566   0.421853   0.208600  airline#highlighter#get_highlight()
  421              0.196602  <SNR>119_InsideCommentOrString()
 3132              0.188452  <SNR>104_get_syn()
  639   0.221333   0.183812  airline#extensions#whitespace#check()
  639   0.217660   0.182338  <SNR>93_update_untracked()
 1278   0.500999   0.179960  airline#extensions#ale#get()
  846              0.171256  <SNR>74_Highlight_Matching_Pair()
  653   0.555718   0.158599  airline#check_mode()
  639   1.189592   0.155708  fugitive#Head()
  639   0.306428   0.141970  airline#extensions#hunks#get_hunks()
  639   0.144791   0.138812  airline#extensions#fugitiveline#bufname()
 6656              0.135472  airline#util#winwidth()
 4473              0.103802  airline#util#append()
  865   0.102144   0.092315  <SNR>119_AllowedToCompleteInBuffer()
  824   0.371775   0.089370  airline#highlighter#exec()

